<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tennis Betting Lab - ATP & WTA</title>
    <link rel="manifest" href="manifest.json">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Tennis Lab">
    <link rel="apple-touch-icon" href="icon-192.png">
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&family=Outfit:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root{--bg:#0a0a0f;--card:#12121a;--border:#2a2a3a;--text:#fff;--muted:#888;--green:#22c55e;--red:#ef4444;--blue:#4d9fff;--yellow:#eab308;--pink:#ec4899;--purple:#a855f7;--orange:#f97316;--atp:#22c55e;--wta:#ec4899}
        *{margin:0;padding:0;box-sizing:border-box}
        body{font-family:'Outfit',sans-serif;background:var(--bg);color:var(--text);min-height:100vh;transition:all .3s;font-size:16px}
        body.light-mode{--bg:#f5f5f5;--card:#fff;--border:#ddd;--text:#1a1a1a;--muted:#666}
        
        .week-alert{background:linear-gradient(135deg,rgba(34,197,94,.15),rgba(236,72,153,.15));border:1px solid var(--green);border-radius:8px;padding:.75rem 1.25rem;margin:.75rem 1rem;display:flex;align-items:center;gap:1rem;flex-wrap:wrap}
        .week-alert-title{font-weight:700;color:var(--green);font-size:1rem}
        .week-alert-tournaments{font-size:.95rem}
        
        .streak-box{display:flex;gap:.75rem;margin-bottom:1rem}
        .streak{flex:1;background:var(--card);border:1px solid var(--border);border-radius:8px;padding:.75rem;text-align:center}
        .streak.win{border-color:var(--green)}
        .streak.loss{border-color:var(--red)}
        .streak .num{font-family:'JetBrains Mono',monospace;font-size:1.5rem;font-weight:700}
        .streak .lbl{font-size:.75rem;color:var(--muted)}
        
        .progress-container{margin-bottom:1rem}
        .progress-header{display:flex;justify-content:space-between;font-size:.9rem;margin-bottom:.4rem}
        .progress-bar{height:24px;background:var(--bg);border-radius:12px;overflow:hidden;position:relative}
        .progress-fill{height:100%;background:linear-gradient(90deg,var(--green),var(--blue));border-radius:12px;transition:width .5s}
        .progress-text{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:.8rem;font-weight:600}
        
        .quick-check{background:var(--card);border:1px solid var(--border);border-radius:8px;padding:1rem;margin-bottom:1rem}
        .quick-check-title{font-weight:600;font-size:.95rem;margin-bottom:.75rem}
        .quick-check-result{padding:.75rem;border-radius:6px;margin-top:.75rem;font-size:.9rem;text-align:center}
        .quick-check-result.valid{background:rgba(34,197,94,.15);border:1px solid var(--green);color:var(--green)}
        .quick-check-result.invalid{background:rgba(239,68,68,.15);border:1px solid var(--red);color:var(--red)}
        
        .theme-toggle{background:var(--bg);border:1px solid var(--border);border-radius:4px;padding:.4rem .8rem;cursor:pointer;font-size:.85rem;margin-right:.5rem}
        
        .celebration{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:var(--card);border:3px solid var(--green);border-radius:12px;padding:2rem;text-align:center;z-index:1000;animation:pop .3s}
        .celebration h2{font-size:1.5rem;margin-bottom:.75rem}
        .overlay{position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,.7);z-index:999}
        @keyframes pop{0%{transform:translate(-50%,-50%) scale(0)}100%{transform:translate(-50%,-50%) scale(1)}}
        @keyframes slideIn{0%{transform:translateX(100%);opacity:0}100%{transform:translateX(0);opacity:1}}
        
        .header{display:flex;align-items:center;gap:1rem;padding:1rem 1.25rem;border-bottom:1px solid var(--border);background:var(--card)}
        .header h1{font-size:1.4rem;background:linear-gradient(135deg,#22c55e,#ec4899);-webkit-background-clip:text;-webkit-text-fill-color:transparent}
        .main-tabs{display:flex;gap:.4rem;margin-left:1rem}
        .main-tab{padding:.5rem 1rem;background:transparent;border:1px solid var(--border);border-radius:6px;color:var(--muted);font-size:.9rem;font-weight:600;cursor:pointer;font-family:inherit}
        .main-tab:hover{border-color:var(--blue)}
        .main-tab.active{background:var(--blue);border-color:var(--blue);color:#000}
        .main-tab.atp{border-color:var(--atp);color:var(--atp)}
        .main-tab.atp.active{background:var(--atp);color:#000}
        .main-tab.wta{border-color:var(--wta);color:var(--wta)}
        .main-tab.wta.active{background:var(--wta);color:#000}
        .header-bankroll{margin-left:auto;text-align:right}
        .header-bankroll .value{font-family:'JetBrains Mono',monospace;font-size:1.4rem;font-weight:600;color:var(--green)}
        .header-bankroll .label{font-size:.7rem;color:var(--muted);text-transform:uppercase}
        
        .circuit-tabs{display:flex;gap:.75rem;padding:.75rem 1rem;background:var(--card);border-bottom:1px solid var(--border)}
        .circuit-tab{padding:.6rem 1.75rem;border-radius:6px;font-weight:600;cursor:pointer;font-size:1rem;border:2px solid transparent}
        .circuit-tab.atp{background:rgba(34,197,94,.1);color:var(--atp);border-color:var(--atp)}
        .circuit-tab.atp.active{background:var(--atp);color:#000}
        .circuit-tab.wta{background:rgba(236,72,153,.1);color:var(--wta);border-color:var(--wta)}
        .circuit-tab.wta.active{background:var(--wta);color:#000}
        .circuit-tab.global{background:rgba(77,159,255,.1);color:var(--blue);border-color:var(--blue)}
        .circuit-tab.global.active{background:var(--blue);color:#000}
        
        .main-content{display:none;padding:1.25rem;overflow-x:hidden}
        .main-content.active{display:block}
        .grid{display:grid;grid-template-columns:320px 1fr;gap:1.25rem;max-width:100%;overflow:hidden}
        @media(max-width:900px){.grid{grid-template-columns:1fr}}

        /* ========== MOBILE RESPONSIVE ========== */
        @media(max-width:600px){
            body{font-size:14px}
            .header{flex-wrap:wrap;padding:.75rem;gap:.5rem}
            .header h1{font-size:1.1rem;width:100%;text-align:center}
            .main-tabs{width:100%;justify-content:center;flex-wrap:wrap;margin:0}
            .main-tab{padding:.4rem .6rem;font-size:.75rem}
            .header-bankroll{width:100%;text-align:center;margin:0}
            .header-bankroll .value{font-size:1.2rem}
            .main-content{padding:.75rem}
            .circuit-tabs{padding:.5rem;gap:.4rem;flex-wrap:wrap;justify-content:center}
            .circuit-tab{padding:.5rem 1rem;font-size:.85rem}
            .card{padding:.75rem}
            .card-title{font-size:.8rem}
            .form-row{grid-template-columns:1fr}
            .stats{grid-template-columns:repeat(3,1fr);gap:.5rem}
            .stat{padding:.5rem}
            .stat .val{font-size:1rem}
            .stat .lbl{font-size:.6rem}
            .btn{padding:.6rem 1rem;font-size:.85rem}
            .niches{max-height:200px}
            .niche{padding:.5rem;font-size:.8rem}
            table{font-size:.75rem}
            th,td{padding:.4rem}
            .bet-card{padding:.6rem}
            .bet-player{font-size:.9rem}
            .bet-odds{font-size:1rem}
            .years{grid-template-columns:repeat(auto-fill,minmax(70px,1fr))}
            .tabs{flex-wrap:wrap}
            .tab{padding:.4rem .6rem;font-size:.75rem}
            .chart-box{height:180px}
            .streak-box{flex-direction:column;gap:.5rem}
            .quick-check{padding:.75rem}
            #simYearSelector{gap:.2rem}
            #simYearSelector button{padding:.3rem .4rem;font-size:.6rem}
            .sim-top-grid{grid-template-columns:1fr!important;gap:.75rem!important}
            .sim-stats-grid{grid-template-columns:1fr!important;gap:.5rem!important}
        }

        /* ========== EXTRA SMALL (iPhone 12 mini portrait 375px) ========== */
        @media(max-width:400px){
            body{font-size:13px}
            .header{padding:.5rem}
            .header h1{font-size:1rem}
            .main-tabs{gap:.25rem}
            .main-tab{padding:.35rem .5rem;font-size:.7rem;white-space:nowrap}
            .header-bankroll .value{font-size:1rem}
            .main-content{padding:.5rem}
            .circuit-tabs{padding:.4rem;gap:.3rem}
            .circuit-tab{padding:.4rem .6rem;font-size:.7rem;white-space:nowrap}
            .card{padding:.5rem}
            .card-title{font-size:.7rem;margin-bottom:.5rem}
            .stats{grid-template-columns:repeat(2,1fr);gap:.4rem}
            .stat{padding:.4rem}
            .stat .val{font-size:.9rem}
            .stat .lbl{font-size:.55rem}
            .btn{padding:.5rem .75rem;font-size:.75rem}
            .niches{max-height:150px}
            .niche{padding:.4rem;font-size:.7rem}
            .niche .roi{font-size:.7rem}
            table{font-size:.65rem}
            th,td{padding:.3rem}
            th{font-size:.6rem}
            .bet-card{padding:.5rem}
            .bet-player{font-size:.8rem}
            .bet-odds{font-size:.9rem}
            .bet-details{font-size:.7rem}
            .years{grid-template-columns:repeat(auto-fill,minmax(55px,1fr))}
            .year{padding:.3rem;font-size:.65rem}
            .tabs{gap:.25rem}
            .tab{padding:.3rem .5rem;font-size:.65rem}
            .chart-box{height:150px}
            .week-alert{padding:.5rem .75rem;font-size:.8rem}
            .week-alert-title{font-size:.85rem}
            .table-wrap{max-height:250px}
            textarea{font-size:.7rem!important;height:120px!important}
            select,input[type="date"]{font-size:.75rem!important;padding:.4rem!important}
            .form-group label{font-size:.7rem}
            .form-group input,.form-group select{font-size:.8rem;padding:.5rem}

            /* ===== NICHE CARDS MOBILE VERTICAL LAYOUT ===== */
            .niche-manager-card{margin-bottom:.6rem}
            .niche-manager-header{
                display:grid!important;
                grid-template-columns:1fr auto!important;
                grid-template-rows:auto auto!important;
                gap:.5rem .75rem!important;
                padding:.75rem!important;
                position:relative!important;
            }
            /* Cacher les √©l√©ments inutiles sur mobile */
            .niche-manager-header .niche-score{display:none!important}
            .expand-indicator{display:none!important}

            /* ROI en haut √† gauche */
            .niche-manager-roi{
                grid-column:1!important;
                grid-row:1!important;
                display:flex!important;
                align-items:center!important;
                gap:.75rem!important;
                min-width:unset!important;
                text-align:left!important;
            }
            .niche-manager-roi > div:first-child{
                font-size:1.8rem!important;
                font-weight:700!important;
                line-height:1!important;
            }
            .niche-manager-roi > div:first-child > div:last-child{
                font-size:.6rem!important;
                margin-top:.15rem!important;
            }

            /* Toggle en haut √† droite */
            .niche-manager-roi .toggle-switch{
                padding:.6rem 1.2rem!important;
                font-size:.85rem!important;
            }

            /* Info (nom + meta) en bas, pleine largeur */
            .niche-manager-info{
                grid-column:1 / -1!important;
                grid-row:2!important;
                width:100%!important;
                padding-top:.5rem!important;
                border-top:1px solid var(--border)!important;
            }
            .niche-manager-name{
                font-size:.95rem!important;
                white-space:normal!important;
                line-height:1.4!important;
                display:flex!important;
                flex-wrap:wrap!important;
                gap:.4rem!important;
                align-items:center!important;
            }
            .niche-manager-meta{
                display:flex!important;
                flex-wrap:wrap!important;
                gap:.5rem!important;
                margin-top:.4rem!important;
                font-size:.75rem!important;
            }

            /* Delete cach√© par d√©faut, visible au clic */
            .niche-manager-actions{
                position:absolute!important;
                top:.5rem!important;
                right:.5rem!important;
                opacity:0.3!important;
            }
            .niche-manager-card:active .niche-manager-actions{opacity:1!important}
            .delete-btn{padding:.3rem .5rem!important;font-size:.7rem!important}

            /* Niche details */
            .niche-manager-details{padding:.75rem!important}
            .niche-metrics{grid-template-columns:repeat(2,1fr)!important;gap:.5rem!important}
            .niche-metric{padding:.6rem!important}
            .niche-metric .val{font-size:1rem!important}
            .niche-metric .lbl{font-size:.6rem!important}
            .niche-years-detailed{gap:4px!important}
            .niche-year-detail{min-width:42px!important;padding:5px 7px!important}
            .niche-year-detail .year-label{font-size:.6rem!important}
            .niche-year-detail .year-roi{font-size:.7rem!important}

            /* Niche detector cards */
            .niche-card .niche-header{
                flex-direction:column!important;
                align-items:stretch!important;
                gap:.5rem!important;
            }
            .niche-card .niche-score{width:100%!important;height:auto!important;padding:.5rem!important;border-radius:8px!important}
            .niche-card .niche-info{width:100%}
            .niche-card .niche-name{font-size:.9rem!important}
            .niche-card .niche-stats{justify-content:space-between!important;width:100%!important;margin-top:.5rem}
            .niche-card .niche-roi{font-size:1.3rem!important}
            .niche-action{width:100%!important;justify-content:center!important}

            /* Filter bar */
            .filter-bar{flex-direction:column!important;gap:.5rem!important;padding:.75rem!important}
            .filter-group{width:100%;flex-wrap:wrap}
            .filter-btn{flex:1;text-align:center}

            /* Detector summary */
            .detector-summary{grid-template-columns:repeat(3,1fr)!important;gap:.4rem!important}
            .detector-stat{padding:.6rem!important}
            .detector-stat .num{font-size:1.2rem!important}
            .detector-stat .lbl{font-size:.6rem!important}
            .detector-stat .icon{font-size:1.2rem!important;margin-bottom:.25rem!important}
        }

        .card{background:var(--card);border:1px solid var(--border);border-radius:10px;padding:1rem;margin-bottom:1rem;overflow:hidden}
        .card-title{font-size:.9rem;font-weight:600;margin-bottom:.75rem;color:var(--muted);text-transform:uppercase}
        .card.atp-border{border-left:4px solid var(--atp)}
        .card.wta-border{border-left:4px solid var(--wta)}
        
        .form-row{display:grid;grid-template-columns:1fr 1fr;gap:.75rem;margin-bottom:.75rem}
        .form-row.full{grid-template-columns:1fr}
        .form-group{display:flex;flex-direction:column;gap:.3rem}
        .form-group label{font-size:.8rem;color:var(--muted)}
        .form-group input,.form-group select{padding:.6rem;background:var(--bg);border:1px solid var(--border);border-radius:6px;color:var(--text);font-size:.95rem;font-family:inherit}
        .form-group input:focus,.form-group select:focus{outline:none;border-color:var(--blue)}
        
        .btn{padding:.65rem 1.25rem;background:linear-gradient(135deg,#22c55e,#4d9fff);border:none;border-radius:6px;color:#000;font-weight:600;font-size:.95rem;cursor:pointer;font-family:inherit}
        .btn:hover{opacity:.9}
        .btn-sm{padding:.4rem .7rem;font-size:.8rem}
        .btn-secondary{background:var(--bg);border:1px solid var(--border);color:var(--muted)}
        .btn-green{background:var(--green);color:#000}
        .btn-red{background:var(--red);color:#fff}
        .btn-row{display:flex;gap:.5rem;flex-wrap:wrap}
        
        .stats{display:grid;grid-template-columns:repeat(auto-fit,minmax(100px,1fr));gap:.75rem;margin-bottom:1rem}
        .stat{background:var(--card);border:1px solid var(--border);border-radius:8px;padding:.75rem;text-align:center}
        .stat .val{font-family:'JetBrains Mono',monospace;font-size:1.3rem;font-weight:600}
        .stat .val.pos{color:var(--green)}
        .stat .val.neg{color:var(--red)}
        .stat .lbl{font-size:.7rem;color:var(--muted);text-transform:uppercase}
        
        .upload{border:2px dashed var(--border);border-radius:8px;padding:1.25rem;text-align:center;cursor:pointer;font-size:1rem}
        .upload:hover{border-color:var(--blue)}
        .upload.loaded{border-color:var(--green);background:rgba(34,197,94,.1)}
        .upload input{display:none}
        
        .niches{display:flex;flex-direction:column;gap:.4rem;max-height:320px;overflow-y:auto}
        .niche{display:flex;justify-content:space-between;align-items:center;padding:.6rem .75rem;background:var(--bg);border:1px solid var(--border);border-radius:6px;cursor:pointer;font-size:.85rem}
        .niche:hover{border-color:var(--blue)}
        .niche.active{border-color:var(--green);background:rgba(34,197,94,.1)}
        .niche.warning{border-left:4px solid var(--yellow)}
        .niche .roi{font-family:'JetBrains Mono',monospace;color:var(--green)}
        .niche .roi.neg{color:var(--red)}
        .niche .tag{font-size:.65rem;padding:.15rem .4rem;border-radius:3px;margin-left:.4rem}
        .niche .tag.confirmed{background:var(--green);color:#000}
        .niche .tag.watch{background:var(--yellow);color:#000}
        
        .chart-box{height:220px}
        
        .years{display:grid;grid-template-columns:repeat(auto-fill,minmax(85px,1fr));gap:.4rem}
        .year{background:var(--bg);border-radius:6px;padding:.5rem;text-align:center;font-size:.8rem}
        .year.pos{border-left:4px solid var(--green)}
        .year.neg{border-left:4px solid var(--red)}
        .year b{display:block}
        .year span{color:var(--muted)}
        
        .tabs{display:flex;gap:.4rem;margin-bottom:.75rem}
        .tab{padding:.5rem .85rem;background:var(--bg);border:1px solid var(--border);border-radius:6px;font-size:.85rem;cursor:pointer;color:var(--muted);font-family:inherit}
        .tab.active{background:var(--blue);color:#000;border-color:var(--blue)}
        
        .table-wrap{max-height:400px;overflow:auto}
        table{width:100%;border-collapse:collapse;font-size:.85rem}
        th{text-align:left;padding:.6rem;font-size:.75rem;color:var(--muted);text-transform:uppercase;border-bottom:1px solid var(--border);position:sticky;top:0;background:var(--card)}
        td{padding:.6rem;border-bottom:1px solid var(--border)}
        tr:hover{background:rgba(255,255,255,.02)}
        .mono{font-family:'JetBrains Mono',monospace}
        .pos{color:var(--green)}
        .neg{color:var(--red)}
        
        .bet-card{background:var(--bg);border:1px solid var(--border);border-radius:8px;padding:.85rem;margin-bottom:.6rem}
        .bet-card.pending{border-left:4px solid var(--yellow)}
        .bet-card.won{border-left:4px solid var(--green);background:rgba(34,197,94,.05)}
        .bet-card.lost{border-left:4px solid var(--red);background:rgba(239,68,68,.05)}
        .bet-card.atp{border-right:4px solid var(--atp)}
        .bet-card.wta{border-right:4px solid var(--wta)}
        .bet-header{display:flex;justify-content:space-between;align-items:center;gap:.75rem}
        .bet-player{font-weight:600;font-size:1rem;flex:1;min-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
        .bet-odds{font-family:'JetBrains Mono',monospace;font-size:1.1rem;flex-shrink:0}
        .bet-details{font-size:.85rem;color:var(--muted);margin-top:.3rem}
        .bet-niche{font-size:.75rem;color:var(--blue);margin-top:.25rem}
        .bet-actions{display:flex;gap:.5rem;margin-top:.6rem}
        .bet-pnl{font-family:'JetBrains Mono',monospace;font-weight:600;font-size:1.05rem}
        .bet-circuit{font-size:.7rem;padding:.2rem .5rem;border-radius:4px;font-weight:600}
        .bet-circuit.atp{background:var(--atp);color:#000}
        .bet-circuit.wta{background:var(--wta);color:#000}
        
        .match-check{padding:.75rem;margin-top:.75rem;border-radius:6px;font-size:.9rem;text-align:center}
        .match-check.valid{background:rgba(34,197,94,.1);border:1px solid var(--green);color:var(--green)}
        .match-check.invalid{background:rgba(239,68,68,.1);border:1px solid var(--red);color:var(--red)}
        
        .no-data{text-align:center;padding:2rem;color:var(--muted);font-size:.95rem}
        .debug{background:#1a1a2a;border:1px solid #333;border-radius:6px;padding:.75rem;font-family:'JetBrains Mono',monospace;font-size:.8rem;color:#888;max-height:100px;overflow:auto;margin-top:.75rem}
        
        .summary-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:1.25rem;margin-bottom:1.25rem;max-width:100%}
        .summary-card{background:var(--card);border:1px solid var(--border);border-radius:10px;padding:1.25rem;overflow:hidden;min-width:0}
        .summary-card h3{font-size:1rem;margin-bottom:.75rem;display:flex;align-items:center;gap:.5rem}
        .summary-card.atp h3{color:var(--atp)}
        .summary-card.wta h3{color:var(--wta)}
        .summary-card.total h3{color:var(--blue)}
        .summary-stats{display:grid;grid-template-columns:1fr 1fr;gap:.75rem}
        .summary-stat{text-align:center;padding:.75rem;background:var(--bg);border-radius:6px}
        .summary-stat .val{font-family:'JetBrains Mono',monospace;font-size:1.4rem;font-weight:600}
        .summary-stat .lbl{font-size:.75rem;color:var(--muted)}
        
        .presets{display:flex;gap:.4rem;flex-wrap:wrap;margin-top:.5rem}
        .preset{padding:.4rem .75rem;font-size:.8rem;background:var(--bg);border:1px solid var(--border);border-radius:5px;cursor:pointer;color:var(--muted);font-family:inherit}
        .preset:hover{border-color:var(--blue);color:var(--blue)}
        
        /* Toggle boxes for multi-select */
        .toggle-box{display:flex;gap:.4rem;flex-wrap:wrap}
        .toggle-btn{padding:.45rem .75rem;font-size:.85rem;background:var(--bg);border:1px solid var(--border);border-radius:5px;cursor:pointer;color:var(--muted);font-family:inherit;transition:all .15s}
        .toggle-btn:hover{border-color:var(--blue);color:var(--blue)}
        .toggle-btn.active{background:var(--blue);border-color:var(--blue);color:#000;font-weight:600}
        
        /* Drawdown Alert */
        .drawdown-alert{background:linear-gradient(135deg,rgba(239,68,68,.2),rgba(234,179,8,.2));border:1px solid var(--red);border-radius:8px;padding:1rem 1.25rem;margin-bottom:1.25rem;display:flex;align-items:center;gap:1rem;animation:pulse 2s infinite}
        .drawdown-alert .drawdown-icon{font-size:1.5rem}
        .drawdown-alert .drawdown-text{flex:1;font-size:1rem;font-weight:500;color:var(--red)}
        .drawdown-alert .drawdown-value{font-family:'JetBrains Mono',monospace;font-weight:700;color:var(--red);font-size:1.1rem}
        @keyframes pulse{0%,100%{opacity:1}50%{opacity:.7}}
        
        /* Drawdown chart */
        .dd-indicator{display:flex;align-items:center;gap:.75rem;margin-top:.75rem;padding:.75rem;background:var(--bg);border-radius:6px}
        .dd-bar{flex:1;height:10px;background:var(--border);border-radius:5px;overflow:hidden}
        .dd-bar-fill{height:100%;border-radius:5px;transition:width .3s}
        .dd-bar-fill.safe{background:var(--green)}
        .dd-bar-fill.warning{background:var(--yellow)}
        .dd-bar-fill.danger{background:var(--red)}
        
        /* ===== NICHE DETECTOR v2 STYLES ===== */
        .niche-card{background:var(--card);border:1px solid var(--border);border-radius:12px;overflow:hidden;margin-bottom:1rem;transition:all .2s}
        .niche-card:hover{border-color:var(--blue);box-shadow:0 4px 20px rgba(77,159,255,.1)}
        .niche-card.selected{border-color:var(--green);background:rgba(34,197,94,.05);box-shadow:0 4px 20px rgba(34,197,94,.15)}
        .niche-card.warning{border-color:var(--yellow)}
        .niche-card.danger{border-color:var(--red);background:rgba(239,68,68,.03)}
        
        .niche-header{display:flex;align-items:center;gap:1rem;padding:1rem;cursor:pointer}
        .niche-score{width:56px;height:56px;border-radius:50%;display:flex;align-items:center;justify-content:center;font-family:'JetBrains Mono',monospace;font-size:1.1rem;font-weight:700;flex-shrink:0}
        .niche-score.excellent{background:linear-gradient(135deg,#22c55e,#16a34a);color:#fff}
        .niche-score.good{background:linear-gradient(135deg,#4d9fff,#3b82f6);color:#fff}
        .niche-score.moderate{background:linear-gradient(135deg,#eab308,#ca8a04);color:#000}
        .niche-score.poor{background:var(--muted);color:#fff}
        
        .niche-info{flex:1;min-width:0}
        .niche-name{font-weight:600;font-size:1rem;margin-bottom:.25rem;display:flex;align-items:center;gap:.5rem;flex-wrap:wrap}
        .niche-meta{font-size:.8rem;color:var(--muted);display:flex;gap:1rem;flex-wrap:wrap}
        
        .niche-stats{display:flex;gap:.5rem;align-items:center}
        .niche-roi{font-family:'JetBrains Mono',monospace;font-size:1.5rem;font-weight:700;color:var(--green)}
        .niche-roi.neg{color:var(--red)}
        
        .niche-action{padding:.75rem 1rem;background:var(--green);color:#000;border:none;border-radius:8px;font-weight:600;cursor:pointer;font-size:.9rem;display:flex;align-items:center;gap:.5rem;transition:all .15s}
        .niche-action:hover{transform:scale(1.02);opacity:.9}
        .niche-action.remove{background:var(--red);color:#fff}
        .niche-action.swap{background:var(--yellow);color:#000}
        
        .niche-details{padding:0 1rem 1rem;display:none}
        .niche-card.expanded .niche-details{display:block}
        
        .niche-metrics{display:grid;grid-template-columns:repeat(auto-fit,minmax(100px,1fr));gap:.75rem;margin-bottom:1rem}
        .niche-metric{background:var(--bg);border-radius:8px;padding:.75rem;text-align:center}
        .niche-metric .val{font-family:'JetBrains Mono',monospace;font-size:1.1rem;font-weight:600}
        .niche-metric .lbl{font-size:.65rem;color:var(--muted);text-transform:uppercase;margin-top:.2rem}
        
        .niche-years{display:flex;gap:4px;flex-wrap:wrap;margin-bottom:1rem}
        .niche-year{width:28px;height:28px;border-radius:4px;display:flex;align-items:center;justify-content:center;font-size:.6rem;font-weight:600;font-family:'JetBrains Mono',monospace}
        .niche-year.pos{background:var(--green);color:#000}
        .niche-year.neg{background:var(--red);color:#fff}
        .niche-year.neutral{background:var(--border);color:var(--muted)}
        
        /* Affichage d√©taill√© des ann√©es */
        .niche-years-detailed{display:flex;gap:4px;flex-wrap:wrap;margin-bottom:1rem}
        .niche-year-detail{display:flex;flex-direction:column;align-items:center;padding:6px 8px;border-radius:6px;font-family:'JetBrains Mono',monospace;min-width:48px;border:1px solid transparent}
        .niche-year-detail .year-label{font-size:.65rem;color:var(--muted);margin-bottom:2px}
        .niche-year-detail .year-bets{font-size:.55rem;color:var(--muted)}
        .niche-year-detail .year-roi{font-size:.75rem;font-weight:700}
        .niche-year-detail.very-pos{background:rgba(34,197,94,.2);border-color:var(--green)}.niche-year-detail.very-pos .year-roi{color:var(--green)}
        .niche-year-detail.pos{background:rgba(34,197,94,.1)}.niche-year-detail.pos .year-roi{color:var(--green)}
        .niche-year-detail.neg{background:rgba(239,68,68,.1)}.niche-year-detail.neg .year-roi{color:var(--red)}
        .niche-year-detail.very-neg{background:rgba(239,68,68,.2);border-color:var(--red)}.niche-year-detail.very-neg .year-roi{color:var(--red)}
        
        /* Niche Manager Cards */
        .niche-manager-card{background:var(--card);border:1px solid var(--border);border-radius:10px;margin-bottom:.75rem;overflow:hidden;transition:all .2s}
        .niche-manager-card:hover{border-color:var(--blue)}
        .niche-manager-card.paused{opacity:.6}
        .niche-manager-card.expanded .niche-manager-details{display:block}
        .niche-manager-card.expanded .expand-indicator{transform:translateY(-50%) rotate(180deg)}
        .niche-manager-header{display:flex;align-items:center;gap:1rem;padding:1rem;cursor:pointer}
        .niche-manager-info{flex:1;min-width:0}
        .niche-manager-name{font-weight:600;font-size:.95rem;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
        .niche-manager-meta{display:flex;gap:1rem;font-size:.75rem;color:var(--muted);margin-top:.25rem}
        .niche-manager-roi{text-align:center;min-width:70px}
        .niche-manager-actions{display:flex;gap:.5rem;align-items:center}
        .niche-manager-details{display:none;padding:0 1rem 1rem 1rem;border-top:1px solid var(--border);margin-top:0}
        .toggle-switch{border:none;padding:.4rem .8rem;border-radius:20px;cursor:pointer;font-size:.75rem;font-weight:700;transition:all .2s}
        .toggle-switch.on{background:linear-gradient(135deg,#22c55e,#16a34a);color:#fff}
        .toggle-switch.off{background:linear-gradient(135deg,#6b7280,#4b5563);color:#fff}
        .delete-btn{background:transparent;border:1px solid var(--red);color:var(--red);padding:.3rem .5rem;border-radius:6px;cursor:pointer;font-size:.8rem;transition:all .2s}
        .delete-btn:hover{background:var(--red);color:#fff}
        
        .niche-verdict{padding:.75rem 1rem;border-radius:8px;font-size:.85rem;display:flex;align-items:center;gap:.75rem}
        .niche-verdict.fiable{background:rgba(34,197,94,.15);border:1px solid var(--green);color:var(--green)}
        .niche-verdict.surveiller{background:rgba(234,179,8,.15);border:1px solid var(--yellow);color:var(--yellow)}
        .niche-verdict.eviter{background:rgba(239,68,68,.15);border:1px solid var(--red);color:var(--red)}
        
        .niche-trend{display:flex;align-items:center;gap:.25rem;font-size:.75rem;padding:.25rem .5rem;border-radius:4px;background:var(--bg)}
        .niche-trend.up{color:var(--green)}
        .niche-trend.down{color:var(--red)}
        .niche-trend.stable{color:var(--muted)}
        
        .similar-toggle{width:100%;padding:.6rem;background:var(--bg);border:1px dashed var(--border);border-radius:8px;color:var(--muted);font-size:.8rem;cursor:pointer;margin-top:.5rem;display:flex;align-items:center;justify-content:center;gap:.5rem}
        .similar-toggle:hover{border-color:var(--blue);color:var(--blue)}
        .similar-niches{display:none;margin-top:.75rem;padding:.75rem;background:var(--bg);border-radius:8px}
        .similar-niches.show{display:block}
        .similar-niche{display:flex;align-items:center;justify-content:space-between;padding:.5rem;border-bottom:1px solid var(--border);font-size:.8rem}
        .similar-niche:last-child{border-bottom:none}
        .similar-niche:hover{background:rgba(255,255,255,.02)}
        
        .detector-summary{display:grid;grid-template-columns:repeat(3,1fr);gap:1rem;margin-bottom:1.5rem}
        .detector-stat{background:var(--card);border:1px solid var(--border);border-radius:10px;padding:1.25rem;text-align:center}
        .detector-stat .icon{font-size:2rem;margin-bottom:.5rem}
        .detector-stat .num{font-family:'JetBrains Mono',monospace;font-size:2rem;font-weight:700}
        .detector-stat .lbl{font-size:.8rem;color:var(--muted)}
        .detector-stat.fiable{border-color:var(--green)}
        .detector-stat.fiable .num{color:var(--green)}
        .detector-stat.surveiller{border-color:var(--yellow)}
        .detector-stat.surveiller .num{color:var(--yellow)}
        .detector-stat.eviter{border-color:var(--red)}
        .detector-stat.eviter .num{color:var(--red)}
        
        .filter-bar{display:flex;gap:.75rem;flex-wrap:wrap;margin-bottom:1.25rem;padding:1rem;background:var(--card);border-radius:10px;border:1px solid var(--border)}
        .filter-group{display:flex;align-items:center;gap:.5rem}
        .filter-group label{font-size:.8rem;color:var(--muted)}
        .filter-btn{padding:.4rem .75rem;background:var(--bg);border:1px solid var(--border);border-radius:6px;color:var(--muted);font-size:.8rem;cursor:pointer;font-family:inherit}
        .filter-btn:hover{border-color:var(--blue);color:var(--blue)}
        .filter-btn.active{background:var(--blue);border-color:var(--blue);color:#000}
        
        .badge{display:inline-flex;align-items:center;gap:.25rem;padding:.2rem .5rem;border-radius:4px;font-size:.7rem;font-weight:600}
        .badge.atp{background:var(--atp);color:#000}
        .badge.wta{background:var(--wta);color:#000}
        .badge.active{background:var(--blue);color:#000}
        .badge.best{background:gold;color:#000}
        .badge.decay{background:var(--red);color:#fff}
    </style>
</head>
<body>
    <div class="header">
        <h1>üéæ TENNIS BETTING LAB</h1>
        <div class="main-tabs">
            <button class="main-tab active" onclick="showMainTab('tracker')">üí∞ Tracker</button>
            <button class="main-tab" onclick="showMainTab('simulator')">üé∞ Simulateur</button>
            <button class="main-tab" onclick="showMainTab('lab')">üß™ Labo</button>
            <button class="main-tab" onclick="showMainTab('calendar')">üìÖ Calendrier</button>
            <button class="main-tab" onclick="showMainTab('config')">‚öôÔ∏è</button>
        </div>
        <button class="theme-toggle" onclick="toggleTheme()">üåô/‚òÄÔ∏è</button>
        <div class="header-bankroll">
            <div class="label">Bankroll</div>
            <div class="value" id="headerBankroll">5000‚Ç¨</div>
        </div>
    </div>

    <!-- Alerte tournois en cours -->
    <div class="week-alert" id="weekAlert" style="display:none">
        <span class="week-alert-title" id="weekAlertTitle">üî¥ EN COURS :</span>
        <span class="week-alert-tournaments" id="weekTournaments"></span>
        <span style="margin-left:auto">
            <button class="btn-sm" style="background:var(--blue);border:none;color:#fff;font-size:.7rem" onclick="window.open('https://www.ps3838.com/en/sports/tennis','_blank')">üéØ PS3838</button>
        </span>
    </div>
    
    <!-- Celebration Modal -->
    <div class="overlay" id="celebrationOverlay" style="display:none" onclick="closeCelebration()"></div>
    <div class="celebration" id="celebrationModal" style="display:none">
        <h2>üéâ F√©licitations !</h2>
        <p id="celebrationText"></p>
        <button class="btn" style="margin-top:1rem" onclick="closeCelebration()">Continuer</button>
    </div>

    <!-- ==================== TRACKER ==================== -->
    <div class="main-content active" id="main-tracker">
        <!-- Streaks -->
        <div class="streak-box">
            <div class="streak" id="currentStreak">
                <div class="num">0</div>
                <div class="lbl">S√©rie actuelle</div>
            </div>
            <div class="streak win">
                <div class="num" id="bestWinStreak">0</div>
                <div class="lbl">Meilleure W</div>
            </div>
            <div class="streak loss">
                <div class="num" id="worstLossStreak">0</div>
                <div class="lbl">Pire L</div>
            </div>
        </div>

        <!-- Summary Cards -->
        <div class="summary-grid">
            <div class="summary-card atp">
                <h3>üü¢ ATP</h3>
                <div class="summary-stats">
                    <div class="summary-stat"><div class="val" id="atpBets">0</div><div class="lbl">Paris</div></div>
                    <div class="summary-stat"><div class="val pos" id="atpProfit">+0‚Ç¨</div><div class="lbl">Profit</div></div>
                </div>
            </div>
            <div class="summary-card wta">
                <h3>ü©∑ WTA</h3>
                <div class="summary-stats">
                    <div class="summary-stat"><div class="val" id="wtaBets">0</div><div class="lbl">Paris</div></div>
                    <div class="summary-stat"><div class="val pos" id="wtaProfit">+0‚Ç¨</div><div class="lbl">Profit</div></div>
                </div>
            </div>
            <div class="summary-card total">
                <h3>üìä TOTAL</h3>
                <div class="summary-stats">
                    <div class="summary-stat"><div class="val" id="totalBets">0</div><div class="lbl">Paris</div></div>
                    <div class="summary-stat"><div class="val pos" id="totalProfit">+0‚Ç¨</div><div class="lbl">Profit</div></div>
                </div>
            </div>
        </div>

        <!-- Circuit Tabs -->
        <div style="display:flex;gap:.5rem;margin-bottom:1rem">
            <button class="circuit-tab atp active" onclick="setTrackerCircuit('atp')">üü¢ ATP</button>
            <button class="circuit-tab wta" onclick="setTrackerCircuit('wta')">ü©∑ WTA</button>
            <button class="circuit-tab global" onclick="setTrackerCircuit('all')">üìä Tous</button>
        </div>

        <!-- Stats -->
        <div class="stats">
            <div class="stat"><div class="val" id="tBankroll">5000‚Ç¨</div><div class="lbl">Bankroll</div></div>
            <div class="stat"><div class="val" id="tPnl">+0‚Ç¨</div><div class="lbl">P/L Total</div></div>
            <div class="stat"><div class="val" id="tWinrate">0%</div><div class="lbl">Winrate</div></div>
            <div class="stat"><div class="val" id="tRoi">0%</div><div class="lbl">ROI</div></div>
            <div class="stat"><div class="val neg" id="tDrawdown">0‚Ç¨</div><div class="lbl">Drawdown</div></div>
            <div class="stat"><div class="val" id="tPending">0</div><div class="lbl">En cours</div></div>
        </div>

        <!-- Alerte Drawdown -->
        <div id="drawdownAlert" class="drawdown-alert" style="display:none">
            <span class="drawdown-icon">‚ö†Ô∏è</span>
            <span class="drawdown-text">Attention ! Tu approches du max drawdown historique</span>
            <span class="drawdown-value" id="drawdownAlertValue"></span>
        </div>

        <!-- Formulaire d'ajout de match + Strat√©gie -->
        <div class="card" style="margin-bottom:1rem">
            <div class="card-title">‚ûï Ajouter un Match</div>
            
            <!-- S√©lection Circuit + Tournoi + Round en ligne -->
            <div style="display:grid;grid-template-columns:90px 1fr 90px;gap:.5rem;margin-bottom:.75rem">
                <div>
                    <label style="font-size:.65rem;color:var(--muted);display:block;margin-bottom:2px">Circuit</label>
                    <select id="addCircuit" onchange="onCircuitChange()" style="width:100%;padding:.4rem;font-size:.85rem;background:var(--bg);border:1px solid var(--border);border-radius:4px;color:var(--text)">
                        <option value="atp">üü¢ ATP</option>
                        <option value="wta">ü©∑ WTA</option>
                    </select>
                </div>
                <div>
                    <label style="font-size:.65rem;color:var(--muted);display:block;margin-bottom:2px">Tournoi</label>
                    <select id="addTournament" onchange="onTournamentChange()" style="width:100%;padding:.4rem;font-size:.85rem;background:var(--bg);border:1px solid var(--border);border-radius:4px;color:var(--text)">
                        <option value="">-- S√©lectionner --</option>
                    </select>
                </div>
                <div>
                    <label style="font-size:.65rem;color:var(--muted);display:block;margin-bottom:2px">Round</label>
                    <select id="addRound" onchange="updateBetPreview()" style="width:100%;padding:.4rem;font-size:.85rem;background:var(--bg);border:1px solid var(--border);border-radius:4px;color:var(--text)"></select>
                </div>
            </div>
            
            <!-- Joueurs et cotes - 2 colonnes -->
            <div style="display:grid;grid-template-columns:1fr 1fr;gap:1rem;margin-bottom:.75rem">
                <!-- Joueur 1 -->
                <div style="display:flex;gap:.5rem;align-items:flex-end">
                    <div style="flex:1">
                        <label style="font-size:.65rem;color:var(--muted);display:block;margin-bottom:2px">Joueur 1</label>
                        <input type="text" id="addPlayer1" placeholder="Sinner J." oninput="updateBetPreview()" style="width:100%;padding:.5rem;font-size:.9rem;background:var(--bg);border:1px solid var(--border);border-radius:4px;color:var(--text)">
                    </div>
                    <div style="width:70px">
                        <label style="font-size:.65rem;color:var(--muted);display:block;margin-bottom:2px">Cote</label>
                        <input type="number" id="addOdds1" step="0.01" placeholder="1.50" oninput="updateBetPreview()" style="width:100%;padding:.5rem;font-size:.9rem;background:var(--bg);border:1px solid var(--border);border-radius:4px;color:var(--text);text-align:center;font-weight:600">
                    </div>
                </div>
                <!-- Joueur 2 -->
                <div style="display:flex;gap:.5rem;align-items:flex-end">
                    <div style="flex:1">
                        <label style="font-size:.65rem;color:var(--muted);display:block;margin-bottom:2px">Joueur 2</label>
                        <input type="text" id="addPlayer2" placeholder="Alcaraz C." oninput="updateBetPreview()" style="width:100%;padding:.5rem;font-size:.9rem;background:var(--bg);border:1px solid var(--border);border-radius:4px;color:var(--text)">
                    </div>
                    <div style="width:70px">
                        <label style="font-size:.65rem;color:var(--muted);display:block;margin-bottom:2px">Cote</label>
                        <input type="number" id="addOdds2" step="0.01" placeholder="2.50" oninput="updateBetPreview()" style="width:100%;padding:.5rem;font-size:.9rem;background:var(--bg);border:1px solid var(--border);border-radius:4px;color:var(--text);text-align:center;font-weight:600">
                    </div>
                </div>
            </div>
            
            <!-- S√©lection pari + Bouton -->
            <div style="display:flex;gap:.75rem;align-items:stretch;margin-bottom:.75rem">
                <div style="flex:1;display:flex;gap:.5rem;align-items:center">
                    <label style="font-size:.75rem;color:var(--muted);white-space:nowrap">Parier sur :</label>
                    <select id="addBetOn" onchange="updateBetPreview()" style="flex:1;padding:.5rem;font-size:.85rem;background:var(--bg);border:1px solid var(--border);border-radius:4px;color:var(--text)">
                        <option value="">-- Choisir --</option>
                        <option value="p1">Joueur 1</option>
                        <option value="p2">Joueur 2</option>
                    </select>
                </div>
                <button class="btn" id="addMatchBtn" onclick="addMatch()" disabled style="white-space:nowrap;padding:.6rem 1.25rem">‚ûï Ajouter</button>
            </div>

            <!-- Pr√©visualisation du pari -->
            <div id="betPreview" style="display:none;background:var(--bg);border:1px solid var(--green);border-radius:6px;padding:.6rem .75rem;margin-bottom:.75rem">
                <span id="betPreviewText" style="font-size:.85rem"></span>
            </div>
            
            <!-- Affichage strat√©gie (configur√©e dans Config) -->
            <div id="trackerStratInfo" style="display:flex;justify-content:space-between;align-items:center;padding-top:.75rem;border-top:1px solid var(--border);font-size:.8rem">
                <span style="color:var(--muted)">Strat√©gie: <span id="trackerStratLabel">üíµ Flat</span></span>
                <span id="trackerStratMise" style="font-weight:600">Mise: 100‚Ç¨</span>
            </div>
            </div>
        </div>
    </div>

    <!-- ==================== BACKTEST ==================== -->
    <div class="main-content" id="main-backtest">
        <div style="display:flex;gap:.5rem;margin-bottom:1rem;flex-wrap:wrap">
            <button class="circuit-tab atp active" onclick="setBacktestCircuit('atp')">üü¢ ATP</button>
            <button class="circuit-tab wta" onclick="setBacktestCircuit('wta')">ü©∑ WTA</button>
            <button class="circuit-tab global" onclick="setBacktestCircuit('compare')">üìä Comparer</button>
        </div>

        <!-- Vue Single Circuit (ATP ou WTA) -->
        <div id="singleCircuitView" class="grid">
            <div class="sidebar">
                <div class="card">
                    <div class="card-title">üìÇ Donn√©es <span id="btCircuitLabel">ATP</span></div>
                    <div class="upload" id="upload" onclick="document.getElementById('file').click()">
                        üìÅ Charger CSV
                    </div>
                    <input type="file" id="file" accept=".csv" style="display:none">
                    <div class="debug" id="debug"></div>
                </div>

                <div class="card">
                    <div class="card-title">üìÖ P√©riode</div>
                    <div class="form-row">
                        <div class="form-group">
                            <label>De</label>
                            <input type="number" id="yearFrom" value="2007" min="2007" max="2025">
                        </div>
                        <div class="form-group">
                            <label>√Ä</label>
                            <input type="number" id="yearTo" value="2025" min="2007" max="2025">
                        </div>
                    </div>
                    <div class="presets">
                        <button class="preset" onclick="setYears(0)">Tout</button>
                        <button class="preset" onclick="setYears(5)">5 ans</button>
                        <button class="preset" onclick="setYears(3)">3 ans</button>
                    </div>
                </div>

                <div class="card">
                    <div class="card-title">üéØ Niches</div>
                    <div class="niches" id="niches"></div>
                    <div class="btn-row" style="margin-top:.5rem">
                        <button class="btn-sm btn-secondary" onclick="toggleAllNiches(true)">Tout</button>
                        <button class="btn-sm btn-secondary" onclick="toggleAllNiches(false)">Aucun</button>
                    </div>
                </div>

                <button class="btn" style="width:100%" onclick="runBacktest()">üöÄ Lancer Backtest</button>
            </div>

            <div class="results">
                <div class="stats" id="btStats">
                    <div class="stat"><div class="val">-</div><div class="lbl">Mise</div></div>
                    <div class="stat"><div class="val">-</div><div class="lbl">Paris</div></div>
                    <div class="stat"><div class="val">-</div><div class="lbl">Wins</div></div>
                    <div class="stat"><div class="val">-</div><div class="lbl">Winrate</div></div>
                    <div class="stat"><div class="val">-</div><div class="lbl">Profit</div></div>
                    <div class="stat"><div class="val">-</div><div class="lbl">ROI</div></div>
                    <div class="stat"><div class="val">-</div><div class="lbl">Max DD</div></div>
                </div>

                <div class="card">
                    <div class="card-title">üìà √âvolution</div>
                    <div class="chart-box"><canvas id="chart"></canvas></div>
                </div>

                <div class="card">
                    <div class="card-title">üìÖ Par Ann√©e (cliquer pour filtrer)</div>
                    <div class="years" id="years"></div>
                    <button class="btn-sm btn-secondary" style="margin-top:.5rem" onclick="resetYearFilter()">Toutes les ann√©es</button>
                </div>

                <div class="card">
                    <div class="card-title">üìã Historique complet <span id="matchCount" style="color:var(--muted)"></span></div>
                    <div class="table-wrap" style="max-height:500px">
                        <table>
                            <thead><tr><th>Date</th><th>Tournoi</th><th>Round</th><th>Pari</th><th>VS</th><th>Cote</th><th>W/L</th><th>P&L</th></tr></thead>
                            <tbody id="btMatches"></tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>

        <!-- Vue Comparaison ATP vs WTA -->
        <div id="compareView" style="display:none">
            <div class="card">
                <div class="card-title">üìÇ Donn√©es ATP et WTA</div>
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:1rem">
                    <div>
                        <div class="upload" id="uploadATP" onclick="document.getElementById('fileATP').click()" style="border-color:var(--atp)">
                            üü¢ Charger ATP CSV
                        </div>
                        <input type="file" id="fileATP" accept=".csv" style="display:none">
                        <div class="debug" id="debugATP" style="margin-top:.3rem"></div>
                    </div>
                    <div>
                        <div class="upload" id="uploadWTA" onclick="document.getElementById('fileWTA').click()" style="border-color:var(--wta)">
                            ü©∑ Charger WTA CSV
                        </div>
                        <input type="file" id="fileWTA" accept=".csv" style="display:none">
                        <div class="debug" id="debugWTA" style="margin-top:.3rem"></div>
                    </div>
                </div>
                <div id="dataStatusCompare" style="margin-top:.75rem;padding:.5rem;background:var(--bg);border-radius:4px;font-size:.7rem"></div>
                <div class="form-row" style="margin-top:1rem">
                    <div class="form-group">
                        <label>De</label>
                        <input type="number" id="cmpYearFrom" value="2007" min="2007" max="2025">
                    </div>
                    <div class="form-group">
                        <label>√Ä</label>
                        <input type="number" id="cmpYearTo" value="2025" min="2007" max="2025">
                    </div>
                </div>
                <button class="btn" style="width:100%;margin-top:.5rem" onclick="runCompareBacktest()">üöÄ Lancer Comparaison</button>
            </div>

            <!-- Stats R√©sum√© -->
            <div class="summary-grid" style="margin-top:1rem">
                <div class="summary-card atp">
                    <h3>üü¢ ATP</h3>
                    <div class="summary-stats">
                        <div class="summary-stat"><div class="val" id="cmpAtpBets">-</div><div class="lbl">Paris</div></div>
                        <div class="summary-stat"><div class="val" id="cmpAtpWinrate">-</div><div class="lbl">Winrate</div></div>
                        <div class="summary-stat"><div class="val pos" id="cmpAtpProfit">-</div><div class="lbl">Profit</div></div>
                        <div class="summary-stat"><div class="val" id="cmpAtpRoi">-</div><div class="lbl">ROI</div></div>
                        <div class="summary-stat"><div class="val neg" id="cmpAtpMaxDD">-</div><div class="lbl">Max DD</div></div>
                    </div>
                </div>
                <div class="summary-card wta">
                    <h3>ü©∑ WTA</h3>
                    <div class="summary-stats">
                        <div class="summary-stat"><div class="val" id="cmpWtaBets">-</div><div class="lbl">Paris</div></div>
                        <div class="summary-stat"><div class="val" id="cmpWtaWinrate">-</div><div class="lbl">Winrate</div></div>
                        <div class="summary-stat"><div class="val pos" id="cmpWtaProfit">-</div><div class="lbl">Profit</div></div>
                        <div class="summary-stat"><div class="val" id="cmpWtaRoi">-</div><div class="lbl">ROI</div></div>
                        <div class="summary-stat"><div class="val neg" id="cmpWtaMaxDD">-</div><div class="lbl">Max DD</div></div>
                    </div>
                </div>
                <div class="summary-card total">
                    <h3>üìä GLOBAL (ATP + WTA)</h3>
                    <div class="summary-stats">
                        <div class="summary-stat"><div class="val" id="cmpTotalBets">-</div><div class="lbl">Paris</div></div>
                        <div class="summary-stat"><div class="val" id="cmpTotalWinrate">-</div><div class="lbl">Winrate</div></div>
                        <div class="summary-stat"><div class="val pos" id="cmpTotalProfit">-</div><div class="lbl">Profit</div></div>
                        <div class="summary-stat"><div class="val" id="cmpTotalRoi">-</div><div class="lbl">ROI</div></div>
                        <div class="summary-stat"><div class="val neg" id="cmpTotalMaxDD">-</div><div class="lbl">Max DD</div></div>
                    </div>
                </div>
            </div>

            <!-- Graphique GLOBAL (strat√©gie combin√©e) -->
            <div class="card">
                <div class="card-title">üìà Strat√©gie Combin√©e ATP+WTA</div>
                <div class="chart-box" style="height:280px"><canvas id="globalCombinedChart"></canvas></div>
                <div style="display:flex;justify-content:center;gap:2rem;margin-top:.5rem;font-size:.75rem">
                    <span><span style="color:var(--blue)">‚îÅ‚îÅ</span> Profit cumul√©</span>
                    <span><span style="color:var(--red)">‚îÖ‚îÖ</span> Drawdown</span>
                    <span><span style="color:var(--yellow)">‚ñº</span> Max DD</span>
                </div>
            </div>

            <!-- Graphique comparaison ATP vs WTA -->
            <div class="card">
                <div class="card-title">üìä D√©tail par circuit</div>
                <div class="chart-box" style="height:220px"><canvas id="compareChart"></canvas></div>
                <div style="display:flex;justify-content:center;gap:2rem;margin-top:.5rem;font-size:.75rem">
                    <span><span style="color:var(--atp)">‚îÅ‚îÅ</span> ATP</span>
                    <span><span style="color:var(--wta)">‚îÅ‚îÅ</span> WTA</span>
                </div>
            </div>

            <!-- Stats d√©taill√©es -->
            <div class="card">
                <div class="card-title">üìä D√©tails par ann√©e</div>
                <div class="table-wrap">
                    <table>
                        <thead>
                            <tr>
                                <th>Ann√©e</th>
                                <th>üü¢ ATP Paris</th>
                                <th>üü¢ ATP P&L</th>
                                <th>ü©∑ WTA Paris</th>
                                <th>ü©∑ WTA P&L</th>
                                <th>üìä Total Paris</th>
                                <th>üìä Total P&L</th>
                            </tr>
                        </thead>
                        <tbody id="cmpYearTable"></tbody>
                    </table>
                </div>
            </div>

            <!-- Historique global -->
            <div class="card">
                <div class="card-title">üìã Historique global <span id="cmpMatchCount" style="color:var(--muted)"></span></div>
                <div class="tabs" style="margin-bottom:.5rem">
                    <button class="tab active" onclick="filterCmpHistory('all')">Tous</button>
                    <button class="tab" onclick="filterCmpHistory('atp')">üü¢ ATP</button>
                    <button class="tab" onclick="filterCmpHistory('wta')">ü©∑ WTA</button>
                </div>
                <div class="table-wrap" style="max-height:400px">
                    <table>
                        <thead><tr><th>Date</th><th>Circuit</th><th>Tournoi</th><th>Round</th><th>Pari</th><th>Cote</th><th>W/L</th><th>P&L</th></tr></thead>
                        <tbody id="cmpMatches"></tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <!-- ==================== LABO ==================== -->
    <div class="main-content" id="main-lab">
        <div style="display:flex;gap:.5rem;margin-bottom:1rem;flex-wrap:wrap">
            <button class="circuit-tab global active" id="labTabPlay" onclick="setLabMode('playground')">üéÆ Terrain de Jeux</button>
            <button class="circuit-tab atp" id="labTabDet" onclick="setLabMode('detector')">üîç D√©tecteur</button>
            <button class="circuit-tab wta" id="labTabNiches" onclick="setLabMode('niches')">üéØ Mes Niches</button>
            <button class="circuit-tab" id="labTabPortfolio" onclick="setLabMode('portfolio')" style="background:linear-gradient(135deg,var(--green),var(--blue));color:#fff">üìä Portfolio Builder</button>
            <button class="circuit-tab" id="labTabDatahub" onclick="setLabMode('datahub')" style="background:linear-gradient(135deg,#f59e0b,#ef4444);color:#fff">üì° DataHub TM</button>
        </div>
        <div id="labNoData" class="card" style="border-left:3px solid var(--yellow)">
            <div style="display:flex;align-items:center;gap:1rem">
                <span style="font-size:2rem">‚ö†Ô∏è</span>
                <div><div style="font-weight:700">Donn√©es non charg√©es</div><div style="font-size:.75rem;color:var(--muted)">Charge d'abord les CSV ci-dessous</div></div>
            </div>
        </div>
        
        <!-- Zone de chargement CSV toujours visible -->
        <div class="card" style="margin-bottom:1rem">
            <div class="card-title">üìÅ Donn√©es CSV</div>
            <div style="display:grid;grid-template-columns:1fr 1fr;gap:1rem">
                <div>
                    <label style="font-size:.75rem;color:var(--green);font-weight:600;display:block;margin-bottom:.3rem">üü¢ ATP</label>
                    <input type="file" id="csvATP" accept=".csv" onchange="loadCSV('atp')" style="width:100%;padding:.5rem;background:var(--bg);border:1px solid var(--border);border-radius:6px;color:var(--text);font-size:.8rem">
                    <div id="csvATPStatus" style="font-size:.7rem;color:var(--muted);margin-top:.25rem">Non charg√©</div>
                </div>
                <div>
                    <label style="font-size:.75rem;color:var(--pink);font-weight:600;display:block;margin-bottom:.3rem">ü©∑ WTA</label>
                    <input type="file" id="csvWTA" accept=".csv" onchange="loadCSV('wta')" style="width:100%;padding:.5rem;background:var(--bg);border:1px solid var(--border);border-radius:6px;color:var(--text);font-size:.8rem">
                    <div id="csvWTAStatus" style="font-size:.7rem;color:var(--muted);margin-top:.25rem">Non charg√©</div>
                </div>
            </div>
        </div>
        
        <div id="labPlayground" style="display:none">
            <div class="grid">
                <div class="sidebar">
                    <div class="card" style="border-left:3px solid var(--purple)">
                        <div class="card-title">üéÆ Param√®tres</div>
                        <div class="form-group" style="margin-bottom:.5rem"><label>Circuit</label><select id="labCircuit" onchange="updateLabCategories()"><option value="atp">ATP</option><option value="wta">WTA</option><option value="both">ATP + WTA</option></select></div>
                        <div class="form-group" style="margin-bottom:.75rem">
                            <label>Cat√©gories <span style="font-size:.6rem;color:var(--muted)">(clic = toggle)</span></label>
                            <div id="labCatsBox" class="toggle-box">
                                <button class="toggle-btn" onclick="toggleLabSel('cat','Grand Slam',this)">GS</button>
                                <button class="toggle-btn" onclick="toggleLabSel('cat','Masters 1000',this)">M1000</button>
                                <button class="toggle-btn" onclick="toggleLabSel('cat','ATP 500',this)">ATP 500</button>
                                <button class="toggle-btn" onclick="toggleLabSel('cat','ATP 250',this)">ATP 250</button>
                            </div>
                        </div>
                        <div class="form-group" style="margin-bottom:.75rem">
                            <label>Surfaces</label>
                            <div id="labSurfsBox" class="toggle-box">
                                <button class="toggle-btn" onclick="toggleLabSel('surf','Hard',this)">Hard</button>
                                <button class="toggle-btn" onclick="toggleLabSel('surf','Clay',this)">Clay</button>
                                <button class="toggle-btn" onclick="toggleLabSel('surf','Grass',this)">Grass</button>
                            </div>
                        </div>
                        <div class="form-group" style="margin-bottom:.75rem">
                            <label>Rounds</label>
                            <div id="labRoundsBox" class="toggle-box">
                                <button class="toggle-btn" onclick="toggleLabSel('round','F',this)">F</button>
                                <button class="toggle-btn" onclick="toggleLabSel('round','SF',this)">SF</button>
                                <button class="toggle-btn" onclick="toggleLabSel('round','QF',this)">QF</button>
                                <button class="toggle-btn" onclick="toggleLabSel('round','R16',this)">R16</button>
                                <button class="toggle-btn" onclick="toggleLabSel('round','R32',this)">R32</button>
                                <button class="toggle-btn" onclick="toggleLabSel('round','R64',this)">R64</button>
                                <button class="toggle-btn" onclick="toggleLabSel('round','R128',this)">R128</button>
                            </div>
                        </div>
                        <div class="form-group" style="margin-bottom:.5rem"><label>Strat√©gie</label><select id="labStrategy"><option value="underdog">Underdog (cote haute)</option><option value="favorite">Favori (cote basse)</option></select></div>
                        <div class="form-row" style="margin-bottom:.5rem"><div class="form-group"><label>Cote Min</label><input type="number" id="labOddsMin" value="1.5" step="0.1"></div><div class="form-group"><label>Cote Max</label><input type="number" id="labOddsMax" value="3.0" step="0.1"></div></div>
                        <div class="form-row" style="margin-bottom:.5rem"><div class="form-group"><label>De</label><input type="number" id="labYearFrom" value="2015"></div><div class="form-group"><label>√Ä</label><input type="number" id="labYearTo" value="2025"></div></div>
                        <div class="presets" style="margin-bottom:.75rem"><button class="preset" onclick="setLabYears(0)">Tout</button><button class="preset" onclick="setLabYears(10)">10 ans</button><button class="preset" onclick="setLabYears(5)">5 ans</button><button class="preset" onclick="setLabYears(3)">3 ans</button><button class="preset" onclick="setLabYears(2)">2 ans</button><button class="preset" onclick="setLabYears(1)">1 an</button></div>
                        <button class="btn" style="width:100%" onclick="runLabTest()">üöÄ Tester cette strat√©gie</button>
                    </div>
                </div>
                <div class="results">
                    <div class="stats"><div class="stat"><div class="val" id="labBets">-</div><div class="lbl">Paris</div></div><div class="stat"><div class="val" id="labWins">-</div><div class="lbl">Wins</div></div><div class="stat"><div class="val" id="labWR">-</div><div class="lbl">Winrate</div></div><div class="stat"><div class="val" id="labProfit">-</div><div class="lbl">Profit</div></div><div class="stat"><div class="val" id="labROI">-</div><div class="lbl">ROI</div></div><div class="stat"><div class="val" id="labDD">-</div><div class="lbl">Max DD</div></div></div>
                    <div class="card" id="labVerdict" style="display:none"><div id="labVerdictContent"></div></div>
                    <div id="labAddNicheBox" style="display:none;margin-bottom:1rem">
                        <div style="display:flex;gap:.5rem">
                            <button class="btn" style="flex:1;background:var(--green);border-color:var(--green)" onclick="addLabNicheToConfig()">‚ûï Ajouter √† mes niches</button>
                            <button class="btn" style="background:var(--purple);border-color:var(--purple)" onclick="addLabNicheToConfig();showMainTab('simulator')">üé∞ Ajouter & Simuler</button>
                        </div>
                    </div>
                    <div class="card">
                        <div class="card-title">üìà √âvolution du profit</div>
                        <div class="chart-box" style="height:200px"><canvas id="labChart"></canvas></div>
                        <!-- Navigation paris par paris -->
                        <div id="labChartNav" style="display:none;margin-top:1rem;padding-top:1rem;border-top:1px solid var(--border)">
                            <div style="display:flex;align-items:center;justify-content:center;gap:1rem;margin-bottom:.75rem">
                                <button onclick="labNavPrev()" id="labNavPrevBtn" style="padding:.4rem .8rem;background:var(--bg);border:1px solid var(--border);border-radius:6px;cursor:pointer;font-size:1rem;color:var(--text)">‚óÄ</button>
                                <div style="text-align:center;min-width:100px">
                                    <div style="font-size:.7rem;color:var(--muted)">Pari</div>
                                    <div style="font-family:'JetBrains Mono',monospace;font-size:1rem;font-weight:700" id="labNavIndex">- / -</div>
                                </div>
                                <button onclick="labNavNext()" id="labNavNextBtn" style="padding:.4rem .8rem;background:var(--bg);border:1px solid var(--border);border-radius:6px;cursor:pointer;font-size:1rem;color:var(--text)">‚ñ∂</button>
                            </div>
                            <div id="labNavDetail" style="background:var(--bg);border:1px solid var(--border);border-radius:8px;padding:.75rem;font-size:.8rem"></div>
                            <div style="text-align:center;margin-top:.4rem;font-size:.65rem;color:var(--muted)">üí° Fl√®ches ‚Üê ‚Üí pour naviguer</div>
                        </div>
                    </div>
                    
                    <!-- S√©ries Drawdown et Winning -->
                    <div style="display:grid;grid-template-columns:1fr 1fr;gap:1rem">
                        <div class="card" style="border-left:3px solid var(--red)">
                            <div class="card-title" style="font-size:.9rem">üìâ Pire S√©rie Perdante</div>
                            <div id="labWorstStreak" style="font-size:.8rem"></div>
                        </div>
                        <div class="card" style="border-left:3px solid var(--green)">
                            <div class="card-title" style="font-size:.9rem">üî• Meilleure S√©rie Gagnante</div>
                            <div id="labBestStreak" style="font-size:.8rem"></div>
                        </div>
                    </div>
                    
                    <div class="card"><div class="card-title">üìÖ Performance par ann√©e</div><div class="years" id="labYears"></div><div id="labWarn" style="display:none;margin-top:.5rem;padding:.5rem;background:rgba(234,179,8,.15);border:1px solid var(--yellow);border-radius:4px;font-size:.7rem"></div></div>
                    <div class="card"><div class="card-title">üìã Derniers matchs <span id="labCnt" style="color:var(--muted)"></span></div><div class="table-wrap" style="max-height:300px;overflow-y:auto"><table><thead><tr><th>Date</th><th>Tournoi</th><th>Rd</th><th>Match</th><th>Score</th><th>R√©s.</th><th>P&L</th></tr></thead><tbody id="labTbl"></tbody></table></div></div>
                </div>
            </div>
        </div>
        <div id="labDetector" style="display:none">
            <!-- Header avec description -->
            <div class="card" style="background:linear-gradient(135deg, var(--card) 0%, rgba(34,197,94,0.1) 100%);margin-bottom:1.5rem">
                <div class="card-title">üî¨ D√©tecteur de Niches v2</div>
                <p style="font-size:.85rem;color:var(--muted);margin-bottom:1rem">
                    Analyse intelligente avec <b>score de fiabilit√©</b> composite. Plus besoin de deviner ‚Äî chaque niche est √©valu√©e sur sa consistance historique, son ROI r√©cent, sa tendance et son volume.
                </p>
                <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:1rem;margin-bottom:1rem">
                    <div class="form-group"><label>Circuit</label><select id="detCircuit"><option value="atp">üü¢ ATP</option><option value="wta">ü©∑ WTA</option><option value="both">üìä ATP + WTA</option></select></div>
                    <div class="form-group"><label>ROI minimum</label><select id="detMinROI"><option value="5">+5%</option><option value="10" selected>+10%</option><option value="15">+15%</option><option value="20">+20%</option></select></div>
                    <div class="form-group"><label>Paris/an min</label><select id="detMinVol"><option value="3">3+</option><option value="5" selected>5+</option><option value="10">10+</option></select></div>
                    <div class="form-group"><label>P√©riode analyse</label><select id="detPeriod"><option value="all" selected>Maximum (2007+)</option><option value="10">10 derni√®res ann√©es</option><option value="7">7 derni√®res ann√©es</option></select></div>
                </div>
                <button class="btn" style="width:100%;padding:1rem;font-size:1rem" onclick="runDetectorV2()">üöÄ Scanner les niches rentables</button>
                <div id="detProgV2" style="margin-top:.75rem;font-size:.8rem;color:var(--muted)"></div>
            </div>
            
            <!-- R√©sum√© des r√©sultats -->
            <div id="detSummary" style="display:none">
                <div class="detector-summary">
                    <div class="detector-stat fiable">
                        <div class="icon">üü¢</div>
                        <div class="num" id="detCountFiable">0</div>
                        <div class="lbl">Fiables (75+)</div>
                    </div>
                    <div class="detector-stat surveiller">
                        <div class="icon">üü°</div>
                        <div class="num" id="detCountSurveiller">0</div>
                        <div class="lbl">√Ä surveiller (50-74)</div>
                    </div>
                    <div class="detector-stat eviter">
                        <div class="icon">üî¥</div>
                        <div class="num" id="detCountEviter">0</div>
                        <div class="lbl">√Ä √©viter (<50)</div>
                    </div>
                </div>
                
                <!-- Filtres et tri -->
                <div class="filter-bar">
                    <div class="filter-group">
                        <label>Afficher:</label>
                        <button class="filter-btn active" onclick="filterNiches('all',this)">Toutes</button>
                        <button class="filter-btn" onclick="filterNiches('fiable',this)">üü¢ Fiables</button>
                        <button class="filter-btn" onclick="filterNiches('surveiller',this)">üü° √Ä surveiller</button>
                        <button class="filter-btn" onclick="filterNiches('eviter',this)">üî¥ √Ä √©viter</button>
                    </div>
                    <div class="filter-group" style="margin-left:auto">
                        <label>Trier par:</label>
                        <select id="detSortBy" onchange="sortNiches(this.value)" style="padding:.4rem;background:var(--bg);border:1px solid var(--border);border-radius:6px;color:var(--text);font-size:.8rem">
                            <option value="score">Score ‚Üì</option>
                            <option value="roi">ROI ‚Üì</option>
                            <option value="consistency">Consistance ‚Üì</option>
                            <option value="volume">Volume ‚Üì</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label style="display:flex;align-items:center;gap:.5rem;cursor:pointer">
                            <input type="checkbox" id="detHideSimilar" checked onchange="toggleSimilarGrouping()">
                            <span>Grouper similaires</span>
                        </label>
                    </div>
                </div>
            </div>
            
            <!-- Liste des niches -->
            <div id="detNichesList"></div>
            
            <!-- Niches actives en danger -->
            <div id="detActiveWarnings" style="display:none;margin-top:1.5rem">
                <div class="card" style="border:2px solid var(--red);background:rgba(239,68,68,.05)">
                    <div class="card-title" style="color:var(--red)">‚ö†Ô∏è Alerte: Niches actives en difficult√©</div>
                    <p style="font-size:.8rem;color:var(--muted);margin-bottom:1rem">Ces niches sont dans votre configuration mais montrent des signes de faiblesse</p>
                    <div id="detActiveWarningsList"></div>
                </div>
            </div>
        </div>
        
        <!-- Section Mes Niches (int√©gr√©e du main-niches) -->
        <div id="labNichesSection" style="display:none">
            
            <!-- ==================== MONITEUR YTD 2026 ==================== -->
            <div id="ytdMonitorCard" class="card" style="background:linear-gradient(135deg, var(--card) 0%, rgba(77,159,255,0.1) 100%);border:2px solid var(--blue);margin-bottom:1.5rem;display:none">
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:1rem">
                    <div class="card-title" style="margin:0">üìä Moniteur <span id="ytdYear">2026</span></div>
                    <div id="ytdGlobalStats" style="display:flex;gap:1rem;font-size:.85rem"></div>
                </div>
                
                <!-- Alerte globale si d√©rive -->
                <div id="ytdAlertBox" style="display:none;background:rgba(239,68,68,.15);border:1px solid var(--red);border-radius:8px;padding:.75rem;margin-bottom:1rem">
                    <div style="display:flex;align-items:center;gap:.5rem;font-weight:600;color:var(--red);margin-bottom:.5rem">
                        <span style="font-size:1.2rem">‚ö†Ô∏è</span>
                        <span id="ytdAlertTitle">Alerte d√©tect√©e</span>
                    </div>
                    <div id="ytdAlertContent" style="font-size:.85rem;color:var(--text)"></div>
                </div>
                
                <!-- Liste des niches avec status YTD -->
                <div id="ytdNichesList" style="display:flex;flex-direction:column;gap:.5rem;max-height:400px;overflow-y:auto"></div>
                
                <!-- L√©gende -->
                <div style="display:flex;gap:1.5rem;justify-content:center;margin-top:1rem;padding-top:.75rem;border-top:1px solid var(--border);font-size:.75rem;color:var(--muted)">
                    <span>üü¢ ROI &gt; +5%</span>
                    <span>üü° ROI -5% √† +5%</span>
                    <span>üî¥ ROI &lt; -5%</span>
                    <span>‚ö™ Pas encore de paris</span>
                </div>
            </div>
            
            <div class="card">
                <div class="card-title">üéØ Mes Niches Configur√©es</div>
                <p style="font-size:.8rem;color:var(--muted);margin-bottom:1rem">
                    Les strat√©gies que tu utilises pour parier. Ajoute-en via le Terrain de Jeux ou le D√©tecteur.
                </p>
                <div id="nichesListContainer"></div>
            </div>
        </div>

        <!-- ==================== PORTFOLIO BUILDER ==================== -->
        <div id="labPortfolio" style="display:none">
            <div class="card" style="border-left:3px solid var(--blue)">
                <div class="card-title">üìä Portfolio Builder</div>
                <p style="font-size:.85rem;color:var(--muted);margin-bottom:1rem">
                    Construis le portfolio optimal pour Blogabet. D√©finis ton volume cible et compare les meilleures combinaisons.
                </p>

                <!-- S√©lection circuit -->
                <div style="display:flex;gap:.5rem;margin-bottom:1rem;flex-wrap:wrap;align-items:center">
                    <span style="font-size:.8rem;color:var(--muted)">Circuit:</span>
                    <button class="circuit-tab atp" id="pfCircuitATP" onclick="setPortfolioCircuit('atp')">üü¢ ATP</button>
                    <button class="circuit-tab wta" id="pfCircuitWTA" onclick="setPortfolioCircuit('wta')">ü©∑ WTA</button>
                    <button class="circuit-tab global active" id="pfCircuitBoth" onclick="setPortfolioCircuit('both')">üìä ATP + WTA</button>
                </div>

                <!-- Slider volume -->
                <div style="background:var(--bg);padding:1rem;border-radius:8px;margin-bottom:1rem">
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:.5rem">
                        <span style="font-size:.85rem;font-weight:600">üéØ Objectif picks/mois</span>
                        <span id="pfTargetValue" style="font-size:1.5rem;font-weight:700;color:var(--blue)">30</span>
                    </div>
                    <input type="range" id="pfTargetSlider" min="10" max="60" value="30"
                           oninput="document.getElementById('pfTargetValue').textContent=this.value"
                           style="width:100%;accent-color:var(--blue)">
                    <div style="display:flex;justify-content:space-between;font-size:.7rem;color:var(--muted);margin-top:.25rem">
                        <span>10 (conservateur)</span>
                        <span>35 (Blogabet id√©al)</span>
                        <span>60 (agressif)</span>
                    </div>
                </div>

                <!-- Bouton calcul -->
                <button onclick="buildPortfolios()" style="width:100%;padding:1rem;background:linear-gradient(135deg,var(--green),var(--blue));color:#fff;border:none;border-radius:8px;font-size:1rem;font-weight:600;cursor:pointer;margin-bottom:1rem">
                    üöÄ Calculer les meilleurs portfolios
                </button>

                <!-- Zone de chargement -->
                <div id="pfLoading" style="display:none;text-align:center;padding:2rem">
                    <div style="font-size:2rem;margin-bottom:.5rem">‚è≥</div>
                    <div>Analyse en cours...</div>
                    <div id="pfLoadingProgress" style="font-size:.8rem;color:var(--muted);margin-top:.5rem"></div>
                </div>

                <!-- R√©sultats -->
                <div id="pfResults" style="display:none">
                    <!-- R√©sum√© -->
                    <div id="pfSummary" style="background:var(--bg);padding:1rem;border-radius:8px;margin-bottom:1rem;font-size:.85rem"></div>

                    <!-- Comparaison des 3 portfolios -->
                    <div id="pfComparison" style="display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:1rem"></div>
                </div>
            </div>
        </div>

        <!-- ==================== DATAHUB TM ==================== -->
        <div id="labDatahub" style="display:none">
            <div class="card" style="border-left:3px solid #f59e0b">
                <div class="card-title">üì° DataHub Tennis Metrics</div>
                <p style="font-size:.85rem;color:var(--muted);margin-bottom:1rem">
                    Colle ici les r√©sultats du DataHub TM pour alimenter ta base de donn√©es de cotes.
                </p>

                <!-- Zone de texte -->
                <div style="margin-bottom:1rem">
                    <label style="font-size:.8rem;font-weight:600;display:block;margin-bottom:.5rem">üìã Coller les donn√©es TM</label>
                    <textarea id="datahubInput" placeholder="Colle ici le texte copi√© du DataHub Tennis Metrics...&#10;&#10;Exemple:&#10;10h23&#10;Result&#10;WTA Auckland, Svitolina E. / Jovic I. : 7/6 6/2. Cotes de d√©but de match : 1.382 / 3.33." style="width:100%;height:200px;padding:.75rem;background:var(--bg);border:1px solid var(--border);border-radius:8px;color:var(--text);font-family:'JetBrains Mono',monospace;font-size:.8rem;resize:vertical"></textarea>
                </div>

                <!-- Date picker + bouton -->
                <div style="display:flex;gap:1rem;align-items:end;margin-bottom:1rem;flex-wrap:wrap">
                    <div>
                        <label style="font-size:.75rem;color:var(--muted);display:block;margin-bottom:.3rem">üìÖ Date des matchs</label>
                        <input type="date" id="datahubDate" style="padding:.5rem;background:var(--bg);border:1px solid var(--border);border-radius:6px;color:var(--text)">
                    </div>
                    <button class="btn" onclick="parseDatahubInput()" style="background:linear-gradient(135deg,#f59e0b,#ef4444);border-color:#f59e0b">
                        üöÄ Importer les donn√©es
                    </button>
                    <button class="btn" onclick="clearDatahubInput()" style="background:var(--bg);border-color:var(--border)">
                        üóëÔ∏è Effacer
                    </button>
                </div>

                <!-- R√©sultat du parsing -->
                <div id="datahubParseResult" style="display:none;margin-bottom:1rem">
                    <div style="background:var(--bg);padding:1rem;border-radius:8px;border:1px solid var(--green)">
                        <div style="font-weight:600;margin-bottom:.5rem;color:var(--green)">‚úÖ Parsing r√©ussi</div>
                        <div id="datahubParseCount" style="font-size:.85rem"></div>
                    </div>
                </div>
            </div>

            <!-- Stats de la base -->
            <div class="card" style="margin-top:1rem">
                <div class="card-title">üìä Base de donn√©es DataHub</div>
                <div class="stats" style="margin-bottom:1rem">
                    <div class="stat"><div class="val" id="dhTotalMatches">0</div><div class="lbl">Matchs</div></div>
                    <div class="stat"><div class="val" id="dhTotalDays">0</div><div class="lbl">Jours</div></div>
                    <div class="stat"><div class="val" id="dhDateRange">-</div><div class="lbl">P√©riode</div></div>
                    <div class="stat"><div class="val" id="dhLastUpdate">-</div><div class="lbl">Derni√®re MAJ</div></div>
                </div>

                <!-- Jours manquants -->
                <div id="dhMissingDays" style="display:none;background:rgba(239,68,68,0.1);padding:.75rem;border-radius:8px;margin-bottom:1rem;border:1px solid rgba(239,68,68,0.3)">
                    <div style="font-weight:600;color:#ef4444;margin-bottom:.5rem">‚ö†Ô∏è Jours manquants</div>
                    <div id="dhMissingList" style="font-size:.8rem;color:var(--text)"></div>
                </div>

                <!-- Actions -->
                <div style="display:flex;gap:.5rem;flex-wrap:wrap">
                    <button class="btn" onclick="exportDatahub()" style="background:var(--blue);border-color:var(--blue)">üì• Exporter JSON</button>
                    <button class="btn" onclick="clearDatahub()" style="background:var(--bg);border-color:var(--border)">üóëÔ∏è Vider la base</button>
                </div>

                <!-- Stats par circuit -->
                <div style="margin-top:1rem;margin-bottom:1rem">
                    <div style="font-weight:600;font-size:.85rem;margin-bottom:.5rem">üìä R√©partition par circuit</div>
                    <div id="dhCircuitStats" style="display:flex;gap:.5rem;flex-wrap:wrap"></div>
                </div>

                <!-- Derniers matchs import√©s -->
                <div style="margin-top:1rem">
                    <div style="font-weight:600;font-size:.85rem;margin-bottom:.5rem">üìã Derniers matchs import√©s</div>
                    <div class="table-wrap" style="max-height:300px;overflow-y:auto">
                        <table>
                            <thead>
                                <tr><th>Date</th><th>Circuit</th><th>Tournoi</th><th>Surface</th><th>Match</th><th>Score</th><th>Cotes</th></tr>
                            </thead>
                            <tbody id="dhRecentMatches"></tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- ==================== SIMULATEUR AVANC√â ==================== -->
    <div class="main-content" id="main-simulator">
        <!-- Configuration compacte en haut -->
        <div class="card" style="background:linear-gradient(135deg, var(--card) 0%, rgba(168,85,247,0.1) 100%)">
            <div class="card-title">üé∞ Simulateur de Strat√©gies de Mise</div>
            
            <div class="sim-top-grid" style="display:grid;grid-template-columns:1fr 1fr 1fr auto;gap:1rem;align-items:end;margin-bottom:1rem">
                <!-- Niches actives -->
                <div>
                    <label style="font-size:.75rem;color:var(--muted);display:block;margin-bottom:.3rem">üìä Niches actives</label>
                    <div id="simNichesSummary" style="display:flex;flex-wrap:wrap;gap:.3rem;background:var(--bg);padding:.5rem;border-radius:6px;min-height:36px;align-items:center"></div>
                </div>
                
                <!-- P√©riode -->
                <div style="flex:1">
                    <label style="font-size:.75rem;color:var(--muted);display:block;margin-bottom:.3rem">üìÖ Ann√©es √† analyser</label>
                    <div id="simYearSelector" style="display:flex;gap:.25rem;flex-wrap:wrap">
                        <!-- Rempli dynamiquement -->
                    </div>
                </div>
                
                <!-- Bouton modifier niches -->
                <button onclick="setLabMode('niches');showMainTab('lab')" style="padding:.5rem .75rem;font-size:.75rem;background:var(--blue);color:#fff;border:none;border-radius:6px;cursor:pointer;white-space:nowrap">‚úèÔ∏è Niches</button>
            </div>
            
            <!-- Strat√©gies de mise - lecture seule depuis Config -->
            <div class="sim-stats-grid" style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:1rem;margin-bottom:1rem">
                <div style="background:var(--bg);border-radius:8px;padding:.75rem;border-left:3px solid var(--green)">
                    <div style="font-size:.75rem;color:var(--muted);margin-bottom:.25rem">üí∞ Bankroll</div>
                    <div id="simDisplayBankroll" style="font-size:1.1rem;font-weight:700;color:var(--green)">5000‚Ç¨</div>
                </div>
                <div style="background:var(--bg);border-radius:8px;padding:.75rem;border-left:3px solid var(--blue)">
                    <div style="font-size:.75rem;color:var(--muted);margin-bottom:.25rem">üíµ Mise Flat</div>
                    <div id="simDisplayFlat" style="font-size:1.1rem;font-weight:700;color:var(--blue)">150‚Ç¨</div>
                </div>
                <div style="background:var(--bg);border-radius:8px;padding:.75rem;border-left:3px solid var(--purple)">
                    <div style="font-size:.75rem;color:var(--muted);margin-bottom:.25rem">üìä % Bankroll</div>
                    <div id="simDisplayPct" style="font-size:1.1rem;font-weight:700;color:var(--purple)">3%</div>
                </div>
            </div>
            <div style="font-size:.7rem;color:var(--muted);text-align:center;margin-bottom:1rem">
                <a href="#" onclick="showMainTab('config');return false" style="color:var(--blue)">‚öôÔ∏è Modifier dans Config</a>
            </div>
            
            <!-- Mode de mise par niche -->
            <div style="background:var(--bg);border-radius:8px;padding:1rem;margin-bottom:1rem">
                <div style="font-size:.85rem;font-weight:600;margin-bottom:.75rem">üéöÔ∏è Strat√©gie de mise par niche</div>
                <div style="display:flex;flex-direction:column;gap:.5rem">
                    <label style="display:flex;align-items:center;gap:.5rem;cursor:pointer;padding:.5rem;border-radius:6px;background:var(--card);border:1px solid var(--border)" onclick="setStakeMode('uniform')">
                        <input type="radio" name="stakeMode" value="uniform" checked style="accent-color:var(--blue)">
                        <div>
                            <div style="font-weight:600;font-size:.85rem">üíµ Mise uniforme</div>
                            <div style="font-size:.75rem;color:var(--muted)">M√™me mise pour toutes les niches (coefficients ignor√©s)</div>
                        </div>
                    </label>
                    <label style="display:flex;align-items:center;gap:.5rem;cursor:pointer;padding:.5rem;border-radius:6px;background:var(--card);border:1px solid var(--border)" onclick="setStakeMode('custom')">
                        <input type="radio" name="stakeMode" value="custom" style="accent-color:var(--yellow)">
                        <div>
                            <div style="font-weight:600;font-size:.85rem">‚úèÔ∏è Mise personnalis√©e</div>
                            <div style="font-size:.75rem;color:var(--muted)">Utiliser les coefficients d√©finis dans "Mes Niches"</div>
                        </div>
                    </label>
                </div>
                <div id="stakeModeInfo" style="margin-top:.75rem;padding:.5rem;background:rgba(77,159,255,.1);border-radius:6px;font-size:.8rem;color:var(--blue);display:none"></div>
            </div>
            
            <!-- Bouton lancer -->
            <button onclick="runSimulation()" style="width:100%;background:linear-gradient(135deg,var(--green),#16a34a);color:#fff;border:none;padding:.75rem;border-radius:8px;font-weight:700;cursor:pointer;font-size:1rem">
                ‚ñ∂Ô∏è Lancer la Simulation
            </button>
        </div>
        
        <!-- R√©sultats (style Playground) -->
        <div id="simResults" style="display:none">
            <!-- Stats principales -->
            <div class="card">
                <div class="stats" style="grid-template-columns:repeat(6,1fr)">
                    <div class="stat"><div class="val" id="simResBets">-</div><div class="lbl">Paris</div></div>
                    <div class="stat"><div class="val" id="simResWins">-</div><div class="lbl">Wins</div></div>
                    <div class="stat"><div class="val" id="simResWR">-</div><div class="lbl">Winrate</div></div>
                    <div class="stat"><div class="val" id="simResProfit">-</div><div class="lbl">Profit</div></div>
                    <div class="stat"><div class="val" id="simResROI">-</div><div class="lbl">ROI</div></div>
                    <div class="stat"><div class="val" id="simResDD">-</div><div class="lbl">Max DD</div></div>
                </div>
            </div>
            
            <!-- Verdict + Comparaison c√¥te √† c√¥te -->
            <div id="simVerdict" class="card" style="display:none"></div>
            
            <!-- S√âLECTEUR DE STRAT√âGIE GLOBAL -->
            <div class="card" style="background:linear-gradient(135deg,var(--card),var(--bg));border:2px solid var(--blue)">
                <div style="font-size:.85rem;font-weight:600;margin-bottom:.75rem;color:var(--muted)">üéØ Visualiser les r√©sultats pour :</div>
                <div id="strategyTabs" style="display:flex;gap:.5rem">
                    <button class="strat-tab active" data-strat="flat" onclick="selectViewStrategy('flat')" style="flex:1;padding:.75rem;border:2px solid var(--blue);background:var(--blue);color:#fff;border-radius:8px;font-weight:700;cursor:pointer;transition:all .2s">
                        üíµ Flat<br><span style="font-size:.7rem;font-weight:400" id="tabFlatInfo">100‚Ç¨</span>
                    </button>
                    <button class="strat-tab" data-strat="pct" onclick="selectViewStrategy('pct')" style="flex:1;padding:.75rem;border:2px solid var(--green);background:transparent;color:var(--green);border-radius:8px;font-weight:700;cursor:pointer;transition:all .2s">
                        üìä % BR<br><span style="font-size:.7rem;font-weight:400" id="tabPctInfo">3%</span>
                    </button>
                    <button class="strat-tab" data-strat="kelly" onclick="selectViewStrategy('kelly')" style="flex:1;padding:.75rem;border:2px solid var(--purple);background:transparent;color:var(--purple);border-radius:8px;font-weight:700;cursor:pointer;transition:all .2s">
                        üßÆ Kelly<br><span style="font-size:.7rem;font-weight:400" id="tabKellyInfo">√∑4</span>
                    </button>
                </div>
            </div>
            
            <!-- Stats de la strat√©gie s√©lectionn√©e -->
            <div class="card" id="selectedStratStats">
                <div style="display:grid;grid-template-columns:repeat(5,1fr);gap:.75rem;text-align:center">
                    <div style="background:var(--bg);padding:.75rem;border-radius:8px">
                        <div style="font-size:1.4rem;font-weight:700;color:var(--green)" id="statProfit">+0‚Ç¨</div>
                        <div style="font-size:.7rem;color:var(--muted)">Profit</div>
                    </div>
                    <div style="background:var(--bg);padding:.75rem;border-radius:8px">
                        <div style="font-size:1.4rem;font-weight:700" id="statROI">0%</div>
                        <div style="font-size:.7rem;color:var(--muted)">ROI</div>
                    </div>
                    <div style="background:var(--bg);padding:.75rem;border-radius:8px">
                        <div style="font-size:1.4rem;font-weight:700;color:var(--red)" id="statDD">0%</div>
                        <div style="font-size:.7rem;color:var(--muted)">Max DD</div>
                    </div>
                    <div style="background:var(--bg);padding:.75rem;border-radius:8px">
                        <div style="font-size:1.4rem;font-weight:700" id="statFinal">0‚Ç¨</div>
                        <div style="font-size:.7rem;color:var(--muted)">Bankroll finale</div>
                    </div>
                    <div style="background:var(--bg);padding:.75rem;border-radius:8px">
                        <div style="font-size:1.4rem;font-weight:700" id="statSharpe">0</div>
                        <div style="font-size:.7rem;color:var(--muted)">Sharpe</div>
                    </div>
                </div>
            </div>
            
            <!-- Graphique √©volution -->
            <div class="card">
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:.75rem">
                    <div class="card-title" style="margin:0">üìà √âvolution du Profit</div>
                    <div style="font-size:.75rem;color:var(--muted)" id="chartStratLabel">Strat√©gie: Flat</div>
                </div>
                <div id="simProfitChartBox" style="height:300px;position:relative">
                    <canvas id="simProfitChart"></canvas>
                </div>
                <!-- Navigation paris par paris -->
                <div id="simChartNav" style="display:none;margin-top:1rem;padding-top:1rem;border-top:1px solid var(--border)">
                    <div style="display:flex;align-items:center;justify-content:center;gap:1rem;margin-bottom:.75rem">
                        <button onclick="simNavPrev()" id="simNavPrevBtn" style="padding:.5rem 1rem;background:var(--bg);border:1px solid var(--border);border-radius:6px;cursor:pointer;font-size:1.1rem;color:var(--text)">‚óÄ</button>
                        <div style="text-align:center;min-width:120px">
                            <div style="font-size:.75rem;color:var(--muted)">Pari</div>
                            <div style="font-family:'JetBrains Mono',monospace;font-size:1.1rem;font-weight:700" id="simNavIndex">- / -</div>
                        </div>
                        <button onclick="simNavNext()" id="simNavNextBtn" style="padding:.5rem 1rem;background:var(--bg);border:1px solid var(--border);border-radius:6px;cursor:pointer;font-size:1.1rem;color:var(--text)">‚ñ∂</button>
                    </div>
                    <div id="simNavDetail" style="background:var(--bg);border:1px solid var(--border);border-radius:8px;padding:1rem;font-size:.85rem"></div>
                    <div style="text-align:center;margin-top:.5rem;font-size:.7rem;color:var(--muted)">üí° Utilise les fl√®ches ‚Üê ‚Üí du clavier pour naviguer</div>
                </div>
            </div>
            
            <!-- S√©ries -->
            <div style="display:grid;grid-template-columns:1fr 1fr;gap:1rem">
                <div class="card" style="border-left:3px solid var(--red)">
                    <div class="card-title" style="font-size:.9rem">üìâ Pire S√©rie Perdante</div>
                    <div id="simWorstStreak" style="font-size:.8rem"></div>
                </div>
                <div class="card" style="border-left:3px solid var(--green)">
                    <div class="card-title" style="font-size:.9rem">üî• Meilleure S√©rie Gagnante</div>
                    <div id="simBestStreak" style="font-size:.8rem"></div>
                </div>
            </div>
            
            <!-- Performance par ann√©e -->
            <div class="card">
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:.5rem">
                    <div class="card-title" style="margin:0">üìÖ Performance par ann√©e <span style="font-size:.75rem;color:var(--muted)" id="yearStratLabel">(Flat)</span></div>
                    <div style="display:flex;gap:.25rem" id="yearlyUnitToggle">
                        <button onclick="setYearlyDisplayMode('euros')" id="btnYearlyEuros" style="padding:.2rem .5rem;font-size:.65rem;border:1px solid var(--blue);background:var(--blue);color:#fff;border-radius:4px 0 0 4px;cursor:pointer">‚Ç¨</button>
                        <button onclick="setYearlyDisplayMode('units')" id="btnYearlyUnits" style="padding:.2rem .5rem;font-size:.65rem;border:1px solid var(--border);background:transparent;color:var(--muted);border-radius:0 4px 4px 0;cursor:pointer">Unit√©s</button>
                    </div>
                </div>
                <div class="years" id="simYears"></div>
            </div>
            
            <!-- D√©tail mensuel -->
            <div class="card">
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:.75rem">
                    <div class="card-title" style="margin:0">üìÜ D√©tail Mensuel</div>
                    <div style="display:flex;align-items:center;gap:.75rem">
                        <div style="display:flex;gap:.25rem" id="monthlyUnitToggle">
                            <button onclick="setMonthlyDisplayMode('euros')" id="btnMonthlyEuros" style="padding:.2rem .5rem;font-size:.65rem;border:1px solid var(--blue);background:var(--blue);color:#fff;border-radius:4px 0 0 4px;cursor:pointer">‚Ç¨</button>
                            <button onclick="setMonthlyDisplayMode('units')" id="btnMonthlyUnits" style="padding:.2rem .5rem;font-size:.65rem;border:1px solid var(--border);background:transparent;color:var(--muted);border-radius:0 4px 4px 0;cursor:pointer">Unit√©s</button>
                        </div>
                        <div id="monthlyYearSelector" style="display:flex;gap:.25rem;overflow-x:auto;max-width:250px;padding:.25rem 0"></div>
                    </div>
                </div>
                <div id="monthlyDetailTable" style="overflow-x:auto"></div>
            </div>
            
            <!-- Tableau comparatif -->
            <div class="card">
                <div class="card-title">üìä Comparaison des strat√©gies</div>
                <div id="simCompareTable"></div>
            </div>
            
            <!-- R√©sum√© -->
            <div id="simSummary" class="card"></div>
            
            <!-- Analyse Drawdown -->
            <div class="card">
                <div class="card-title">üìâ Analyse du Drawdown</div>
                <div id="drawdownAnalysis"></div>
                <div style="height:150px;margin-top:1rem"><canvas id="drawdownChart"></canvas></div>
                <div id="drawdownZones" style="margin-top:1rem"></div>
            </div>
            
            <!-- Moments Difficiles - NOUVELLE SECTION -->
            <div class="card" style="border-left:4px solid var(--yellow)">
                <div class="card-title">üé¢ Moments Difficiles <span style="font-size:.7rem;color:var(--muted);font-weight:400">(ce que tu aurais v√©cu)</span></div>
                <div id="roughPeriodsAnalysis"></div>
            </div>
            
            <!-- Analyse des s√©ries -->
            <div class="card">
                <div class="card-title">üéØ Analyse des S√©ries</div>
                <div id="streaksAnalysis"></div>
            </div>
            
            <!-- Breakdown par ann√©e -->
            <div class="card">
                <div class="card-title">üìä D√©tail par Ann√©e</div>
                <div id="yearlyBreakdown"></div>
            </div>
            
            <!-- Table historique -->
            <div class="card">
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:.75rem">
                    <div class="card-title" style="margin:0">üìã Historique <span id="simHistoryCount" style="color:var(--muted)"></span></div>
                    <div style="display:flex;gap:.5rem;align-items:center">
                        <input type="text" id="simHistoryFilter" placeholder="Filtrer..." oninput="renderSimHistory()" style="padding:.4rem .6rem;font-size:.75rem;background:var(--bg);border:1px solid var(--border);border-radius:4px;color:var(--text);width:120px">
                        <select id="simHistorySort" onchange="renderSimHistory()" style="padding:.4rem;font-size:.75rem;background:var(--bg);border:1px solid var(--border);border-radius:4px;color:var(--text)">
                            <option value="date-desc">Date ‚Üì</option>
                            <option value="date-asc">Date ‚Üë</option>
                            <option value="profit-desc">P/L ‚Üì</option>
                            <option value="profit-asc">P/L ‚Üë</option>
                            <option value="odds-desc">Cote ‚Üì</option>
                        </select>
                    </div>
                </div>
                <div id="simHistoryList" style="max-height:400px;overflow-y:auto"></div>
            </div>
        </div>
        
        <!-- Outils avanc√©s (collaps√© par d√©faut) -->
        <div class="card" style="margin-top:1rem">
            <div style="display:flex;justify-content:space-between;align-items:center;cursor:pointer" onclick="document.getElementById('advancedTools').style.display = document.getElementById('advancedTools').style.display === 'none' ? 'block' : 'none'">
                <div class="card-title" style="margin:0">üîß Outils Avanc√©s</div>
                <span style="color:var(--muted)">‚ñº</span>
            </div>
            <div id="advancedTools" style="display:none;margin-top:1rem">
                <div style="display:flex;gap:.5rem;flex-wrap:wrap">
                    <button onclick="runMonteCarloDrawdown()" style="background:linear-gradient(135deg,#8b5cf6,#7c3aed);color:#fff;border:none;padding:.6rem 1rem;border-radius:6px;font-weight:600;cursor:pointer;font-size:.8rem">
                        üé≤ MC Drawdown
                    </button>
                    <button onclick="runMonteCarloVariance()" style="background:linear-gradient(135deg,#ec4899,#db2777);color:#fff;border:none;padding:.6rem 1rem;border-radius:6px;font-weight:600;cursor:pointer;font-size:.8rem">
                        üé∞ MC Variance
                    </button>
                    <button onclick="showRiskOfRuin()" style="background:linear-gradient(135deg,#f59e0b,#d97706);color:#fff;border:none;padding:.6rem 1rem;border-radius:6px;font-weight:600;cursor:pointer;font-size:.8rem">
                        üíÄ Risk of Ruin
                    </button>
                </div>
                
                <!-- R√©sultats MC Drawdown -->
                <div id="monteCarloDrawdownResults" style="display:none;margin-top:1rem">
                    <div style="background:rgba(139,92,246,0.1);border-radius:8px;padding:1rem">
                        <div style="font-weight:600;margin-bottom:.5rem">üé≤ Monte Carlo Drawdown</div>
                        <div id="mcDrawdownContent"></div>
                    </div>
                </div>
                
                <!-- R√©sultats MC Variance -->
                <div id="monteCarloVarianceResults" style="display:none;margin-top:1rem">
                    <div style="background:rgba(236,72,153,0.1);border-radius:8px;padding:1rem">
                        <div style="font-weight:600;margin-bottom:.5rem">üé∞ Monte Carlo Variance</div>
                        <div id="mcVarianceContent"></div>
                    </div>
                </div>
                
                <!-- R√©sultats Risk of Ruin -->
                <div id="riskOfRuinResults" style="display:none;margin-top:1rem">
                    <div style="background:rgba(245,158,11,0.1);border-radius:8px;padding:1rem">
                        <div style="font-weight:600;margin-bottom:.5rem">üíÄ Risk of Ruin</div>
                        <div id="rorContent"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
        </div>
        
        <!-- Monte Carlo Results -->
        
        <!-- Multi-Bankroll Results -->
        <div id="multiBankrollResults" style="display:none">
            <div class="card">
                <div class="card-title">üè¶ Simulation Multi-Bankroll</div>
                <p style="font-size:.8rem;color:var(--muted);margin-bottom:1rem">
                    Compare plusieurs tailles de bankroll pour trouver le sweet spot risque/rendement.
                </p>
                
                <!-- Tableau comparatif -->
                <div id="mbComparisonTable" style="margin-bottom:1.25rem"></div>
                
                <!-- Graphique risque de ruine -->
                <div style="background:var(--bg);padding:1rem;border-radius:8px;margin-bottom:1rem">
                    <div style="font-weight:600;margin-bottom:.5rem">üìä Risque de ruine par bankroll</div>
                    <canvas id="mbRuinChart" height="200"></canvas>
                </div>
                
                <!-- Graphique ROI attendu -->
                <div style="background:var(--bg);padding:1rem;border-radius:8px;margin-bottom:1rem">
                    <div style="font-weight:600;margin-bottom:.5rem">üí∞ Profit m√©dian par bankroll</div>
                    <canvas id="mbProfitChart" height="200"></canvas>
                </div>
                
                <!-- Trajectoires compar√©es -->
                <div style="background:var(--bg);padding:1rem;border-radius:8px;margin-bottom:1rem">
                    <div style="font-weight:600;margin-bottom:.5rem">üìà Trajectoires m√©dianes compar√©es</div>
                    <canvas id="mbTrajectoriesChart" height="250"></canvas>
                </div>
                
                <!-- Recommandation -->
                <div id="mbRecommendation" style="margin-top:1rem"></div>
            </div>
        </div>
        
        <!-- What If Results -->
        <div id="whatIfResults" style="display:none">
            <div class="card">
                <div class="card-title">üîÆ What If - Simulation Temporelle</div>
                <p style="font-size:.8rem;color:var(--muted);margin-bottom:1rem">
                    Et si tu avais commenc√© √† parier √† une date diff√©rente ? D√©place le slider pour voir l'impact.
                </p>
                
                <!-- Slider de date -->
                <div style="background:var(--bg);padding:1.25rem;border-radius:8px;margin-bottom:1.25rem">
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:.75rem">
                        <span style="font-size:.85rem;font-weight:600">üìÖ Date de d√©but</span>
                        <span id="wiSelectedDate" style="font-size:1.1rem;font-weight:700;color:var(--pink)">2015</span>
                    </div>
                    <input type="range" id="wiDateSlider" min="2007" max="2024" value="2015" 
                           style="width:100%;height:8px;cursor:pointer;accent-color:var(--pink)"
                           oninput="updateWhatIfFromSlider()">
                    <div style="display:flex;justify-content:space-between;font-size:.7rem;color:var(--muted);margin-top:.5rem">
                        <span>2007</span>
                        <span>2012</span>
                        <span>2017</span>
                        <span>2024</span>
                    </div>
                </div>
                
                <!-- Stats pour la date s√©lectionn√©e -->
                <div id="wiStats" style="margin-bottom:1.25rem">
                    <div style="text-align:center;padding:2rem;color:var(--muted)">
                        <div style="font-size:2rem;margin-bottom:.5rem">‚è≥</div>
                        <div>Calcul en cours...</div>
                    </div>
                </div>
                
                <!-- Comparaison avec p√©riode compl√®te -->
                <div id="wiComparison" style="margin-bottom:1.25rem"></div>
                
                <!-- Graphique √©volution selon date de d√©but -->
                <div style="background:var(--bg);padding:1rem;border-radius:8px;margin-bottom:1rem">
                    <div style="font-weight:600;margin-bottom:.5rem">üìä Profit final selon ann√©e de d√©but</div>
                    <canvas id="wiProfitByYearChart" height="220"></canvas>
                </div>
                
                <!-- Graphique trajectoire pour la date s√©lectionn√©e -->
                <div style="background:var(--bg);padding:1rem;border-radius:8px;margin-bottom:1rem">
                    <div style="font-weight:600;margin-bottom:.5rem">üìà Trajectoire depuis <span id="wiTrajectoryLabel">2015</span></div>
                    <canvas id="wiTrajectoryChart" height="250"></canvas>
                </div>
                
                <!-- Calendrier des drawdowns -->
                <div style="background:var(--bg);padding:1rem;border-radius:8px;margin-bottom:1rem">
                    <div style="font-weight:600;margin-bottom:.75rem">üìâ Calendrier des Drawdowns</div>
                    <div id="wiDrawdownCalendar"></div>
                </div>
                
                <!-- Meilleur moment pour commencer -->
                <div id="wiBestTiming" style="margin-top:1rem"></div>
            </div>
        </div>
    </div>

    <!-- ==================== STATS ==================== -->
    <div class="main-content" id="main-stats">
        <div class="card" id="statsEmpty">
            <div style="text-align:center;padding:2rem;color:var(--muted)">
                <div style="font-size:3rem;margin-bottom:1rem">üìà</div>
                <h3>Pas encore de donn√©es</h3>
                <p style="margin-top:.5rem">Les statistiques appara√Ætront quand tu auras des paris r√©solus dans le tracker.</p>
            </div>
        </div>

        <div id="statsContent" style="display:none">
            <!-- R√©sum√© global -->
            <div class="summary-grid">
                <div class="summary-card atp">
                    <h3>üü¢ ATP</h3>
                    <div class="summary-stats">
                        <div class="summary-stat"><div class="val" id="statAtpBets">0</div><div class="lbl">Paris</div></div>
                        <div class="summary-stat"><div class="val" id="statAtpWinrate">0%</div><div class="lbl">Winrate</div></div>
                        <div class="summary-stat"><div class="val pos" id="statAtpProfit">+0‚Ç¨</div><div class="lbl">Profit</div></div>
                    </div>
                </div>
                <div class="summary-card wta">
                    <h3>ü©∑ WTA</h3>
                    <div class="summary-stats">
                        <div class="summary-stat"><div class="val" id="statWtaBets">0</div><div class="lbl">Paris</div></div>
                        <div class="summary-stat"><div class="val" id="statWtaWinrate">0%</div><div class="lbl">Winrate</div></div>
                        <div class="summary-stat"><div class="val pos" id="statWtaProfit">+0‚Ç¨</div><div class="lbl">Profit</div></div>
                    </div>
                </div>
                <div class="summary-card total">
                    <h3>üìä TOTAL</h3>
                    <div class="summary-stats">
                        <div class="summary-stat"><div class="val" id="statTotalBets">0</div><div class="lbl">Paris</div></div>
                        <div class="summary-stat"><div class="val" id="statTotalWinrate">0%</div><div class="lbl">Winrate</div></div>
                        <div class="summary-stat"><div class="val pos" id="statTotalProfit">+0‚Ç¨</div><div class="lbl">Profit</div></div>
                    </div>
                </div>
            </div>

            <!-- Graphiques -->
            <div style="display:grid;grid-template-columns:2fr 1fr;gap:1rem;margin-top:1rem">
                <div class="card">
                    <div class="card-title">üìà √âvolution Bankroll</div>
                    <div class="chart-box" style="height:220px"><canvas id="bankrollChart"></canvas></div>
                </div>
                <div class="card">
                    <div class="card-title">ü•ß R√©partition ATP/WTA</div>
                    <div class="chart-box" style="height:220px"><canvas id="pieChart"></canvas></div>
                </div>
            </div>

            <!-- Best/Worst stats -->
            <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:1rem;margin-top:1rem">
                <div class="card">
                    <div class="card-title">üèÜ Meilleur Tournoi</div>
                    <div id="statBestTournament" style="font-size:1.1rem;font-weight:700;margin:.5rem 0">-</div>
                    <div id="statBestTournamentDetail" style="font-size:.75rem;color:var(--muted)">-</div>
                </div>
                <div class="card">
                    <div class="card-title">üéØ Meilleur Round</div>
                    <div id="statBestRound" style="font-size:1.1rem;font-weight:700;margin:.5rem 0">-</div>
                    <div id="statBestRoundDetail" style="font-size:.75rem;color:var(--muted)">-</div>
                </div>
                <div class="card">
                    <div class="card-title">üåç Meilleure Surface</div>
                    <div id="statBestSurface" style="font-size:1.1rem;font-weight:700;margin:.5rem 0">-</div>
                    <div id="statBestSurfaceDetail" style="font-size:.75rem;color:var(--muted)">-</div>
                </div>
            </div>

            <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:1rem;margin-top:1rem">
                <div class="card">
                    <div class="card-title">üìÖ Meilleur Jour</div>
                    <div id="statBestDay" style="font-size:1.1rem;font-weight:700;margin:.5rem 0">-</div>
                    <div id="statBestDayDetail" style="font-size:.75rem;color:var(--muted)">-</div>
                </div>
                <div class="card">
                    <div class="card-title">üí∞ Plus Gros Gain</div>
                    <div id="statBiggestWin" class="pos" style="font-size:1.1rem;font-weight:700;margin:.5rem 0">-</div>
                    <div id="statBiggestWinDetail" style="font-size:.75rem;color:var(--muted)">-</div>
                </div>
                <div class="card">
                    <div class="card-title">üí∏ Plus Grosse Perte</div>
                    <div id="statBiggestLoss" class="neg" style="font-size:1.1rem;font-weight:700;margin:.5rem 0">-</div>
                    <div id="statBiggestLossDetail" style="font-size:.75rem;color:var(--muted)">-</div>
                </div>
            </div>

            <!-- Odds stats -->
            <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:1rem;margin-top:1rem">
                <div class="card" style="text-align:center">
                    <div class="card-title">üìä Cote Moyenne Gagnante</div>
                    <div id="statAvgWinOdds" class="pos" style="font-size:1.5rem;font-weight:700;margin-top:.5rem">-</div>
                </div>
                <div class="card" style="text-align:center">
                    <div class="card-title">üìä Cote Moyenne Perdante</div>
                    <div id="statAvgLossOdds" class="neg" style="font-size:1.5rem;font-weight:700;margin-top:.5rem">-</div>
                </div>
                <div class="card" style="text-align:center">
                    <div class="card-title">üìä Cote Min Gagn√©e</div>
                    <div id="statMinWinOdds" style="font-size:1.5rem;font-weight:700;margin-top:.5rem">-</div>
                </div>
                <div class="card" style="text-align:center">
                    <div class="card-title">üìä Cote Max Gagn√©e</div>
                    <div id="statMaxWinOdds" style="font-size:1.5rem;font-weight:700;margin-top:.5rem">-</div>
                </div>
            </div>

            <!-- Performance par niche -->
            <div class="card" style="margin-top:1rem">
                <div class="card-title">üéØ Performance par Niche</div>
                <div class="table-wrap">
                    <table>
                        <thead><tr><th>Niche</th><th>Paris</th><th>Wins</th><th>Winrate</th><th>Profit</th><th>ROI</th></tr></thead>
                        <tbody id="statNicheTable"></tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <!-- ==================== CALENDAR ==================== -->
    <div class="main-content" id="main-calendar">
        <div style="display:flex;gap:.5rem;margin-bottom:1rem">
            <button class="circuit-tab atp" onclick="setCalendarCircuit('atp')">üü¢ ATP</button>
            <button class="circuit-tab wta" onclick="setCalendarCircuit('wta')">ü©∑ WTA</button>
            <button class="circuit-tab global active" onclick="setCalendarCircuit('all')">üìä Combin√©</button>
        </div>

        <div id="calendarContent"></div>
    </div>

    <!-- ==================== NICHES MANAGEMENT ==================== -->
    <div class="main-content" id="main-niches">
        <div class="card">
            <div class="card-title">üéØ Gestion des Niches</div>
            <p style="font-size:.85rem;color:var(--muted);margin-bottom:1rem">
                Vue d'ensemble de toutes vos niches. Activez/d√©sactivez en un clic.
            </p>
            <div style="display:flex;gap:.5rem;margin-bottom:1rem;flex-wrap:wrap;align-items:center">
                <button class="circuit-tab atp active" onclick="setNichesCircuit('atp')">üü¢ ATP</button>
                <button class="circuit-tab wta" onclick="setNichesCircuit('wta')">ü©∑ WTA</button>
                <button class="circuit-tab global" onclick="setNichesCircuit('all')">üìä Toutes</button>
                <div style="margin-left:auto;display:flex;align-items:center;gap:.5rem">
                    <label style="font-size:.8rem;color:var(--muted)">P√©riode:</label>
                    <select id="nichesPeriod" onchange="renderNichesList()" style="padding:.5rem;background:var(--bg);border:1px solid var(--border);border-radius:6px;color:var(--text);font-size:.85rem">
                        <option value="1m">1 mois</option>
                        <option value="3m">3 mois</option>
                        <option value="6m">6 mois</option>
                        <option value="1y" selected>1 an</option>
                        <option value="3y">3 ans</option>
                        <option value="5y">5 ans</option>
                        <option value="10y">10 ans</option>
                        <option value="all">Tout</option>
                    </select>
                </div>
            </div>
            <div id="nichesStatusBar" style="display:flex;gap:1rem;padding:.75rem;background:var(--bg);border-radius:6px;margin-bottom:1rem;font-size:.85rem">
                <span>üü¢ Actives: <b id="nichesActiveCount">0</b></span>
                <span>‚è∏Ô∏è En pause: <b id="nichesPausedCount">0</b></span>
                <span style="margin-left:auto">üìä Total: <b id="nichesTotalCount">0</b></span>
            </div>
            <!-- Boutons Export/Import/Reset -->
            <div style="display:flex;gap:.5rem;flex-wrap:wrap;padding-top:.5rem;border-top:1px solid var(--border)">
                <button onclick="exportNiches()" style="background:var(--blue);color:#fff;border:none;padding:.5rem 1rem;border-radius:6px;font-size:.75rem;cursor:pointer">üì§ Exporter niches</button>
                <label style="background:var(--green);color:#000;border:none;padding:.5rem 1rem;border-radius:6px;font-size:.75rem;cursor:pointer">
                    üì• Importer niches
                    <input type="file" accept=".json" onchange="importNiches(event)" style="display:none">
                </label>
                <button onclick="resetNichesToDefault()" style="background:transparent;color:var(--red);border:1px solid var(--red);padding:.5rem 1rem;border-radius:6px;font-size:.75rem;cursor:pointer">üîÑ Reset d√©faut</button>
                <span style="margin-left:auto;font-size:.7rem;color:var(--muted);align-self:center">üíæ Sauvegarde auto activ√©e</span>
            </div>
        </div>

        <!-- L√©gende -->
        <div class="card" style="padding:.5rem 1rem">
            <div style="display:flex;gap:1.5rem;flex-wrap:wrap;font-size:.75rem;color:var(--muted)">
                <span>üü¢ ROI positif</span>
                <span>üü° En baisse</span>
                <span>üî¥ ROI n√©gatif</span>
                <span>üìà Hausse</span>
                <span>üìâ Baisse</span>
                <span>‚è∏Ô∏è Pause</span>
            </div>
        </div>

        <!-- Liste des niches -->
        <div id="nichesListContainer"></div>
    </div>

    <!-- ==================== CONFIG ==================== -->
    <div class="main-content" id="main-config">
        <div style="max-width:700px;margin:0 auto">
            <div class="card">
                <div class="card-title">üí∞ Bankroll & Mise</div>
                <div class="form-row">
                    <div class="form-group">
                        <label>Bankroll initiale (‚Ç¨)</label>
                        <input type="number" id="cfgBankroll" value="5000" oninput="onConfigChange()" onchange="onConfigChange()">
                    </div>
                    <div class="form-group">
                        <label>Mise Flat (‚Ç¨)</label>
                        <input type="number" id="cfgStake" value="250" oninput="onConfigChange()" onchange="onConfigChange()">
                    </div>
                    <div class="form-group">
                        <label>Mise % Bankroll</label>
                        <input type="number" id="cfgPctStake" value="3" step="0.5" min="0.5" max="10" oninput="onConfigChange()" onchange="onConfigChange()">
                        <span style="font-size:.7rem;color:var(--muted)">%</span>
                    </div>
                </div>
                
                <div class="form-row" style="margin-top:.5rem">
                    <div class="form-group">
                        <label>Strat√©gie active</label>
                        <select id="cfgStakeStrategy" onchange="onConfigChange()">
                            <option value="flat">üíµ Mise Flat</option>
                            <option value="percent">üìä % Bankroll</option>
                        </select>
                    </div>
                </div>
                
                <!-- Recommandations de mise -->
                <div id="stakeRecommendations" style="background:var(--bg);border-radius:8px;padding:1rem;margin:1rem 0">
                    <div style="font-size:.85rem;font-weight:600;margin-bottom:.75rem">üí° Mises recommand√©es <span style="color:var(--muted);font-weight:400">(bas√©es sur DD max historique)</span></div>
                    <div id="stakeRecoContent" style="color:var(--muted);font-size:.8rem">Charge les donn√©es CSV et active des niches pour voir les recommandations</div>
                </div>
                
                <button class="btn" onclick="saveConfig()">üíæ Sauvegarder</button>
            </div>

            <div class="card">
                <div class="card-title">üéØ Projection Annuelle <span style="font-size:.7rem;color:var(--muted);font-weight:400">(calcul√©e automatiquement)</span></div>
                <div id="projectionContent" style="color:var(--muted);font-size:.85rem">Charge les CSV et active des niches pour voir les projections</div>
            </div>

            <div class="card">
                <div class="card-title">üíæ Sauvegarde des Donn√©es</div>
                <p style="font-size:.7rem;color:var(--muted);margin-bottom:.75rem">
                    Exporte tes donn√©es pour ne rien perdre. R√©importe-les si tu changes d'appareil ou de navigateur.
                </p>
                <div class="btn-row">
                    <button class="btn-sm btn-green" onclick="exportData()">üì• Exporter JSON</button>
                    <label class="btn-sm btn-secondary" style="cursor:pointer">
                        üì§ Importer JSON
                        <input type="file" id="importFile" accept=".json" style="display:none" onchange="importData(event)">
                    </label>
                </div>
                <div id="importStatus" style="margin-top:.5rem;font-size:.7rem"></div>
            </div>

            <div class="card">
                <div class="card-title">üóëÔ∏è R√©initialiser</div>
                <p style="font-size:.65rem;color:var(--muted);margin-bottom:.5rem">Efface TOUS les paris (ATP + WTA) et remet la bankroll √† z√©ro</p>
                <button class="btn-sm btn-red" onclick="resetAll()">R√©initialiser tout</button>
            </div>
        </div>
    </div>

    <script>
        // ==================== DOM HELPERS (√©vite les erreurs null) ====================
        function $id(id) { return document.getElementById(id); }
        function safeHTML(id, html) { var el = $id(id); if (el) el.innerHTML = html; }
        function safeText(id, text) { var el = $id(id); if (el) el.textContent = text; }
        function safeStyle(id, prop, val) { var el = $id(id); if (el) el.style[prop] = val; }
        function safeClass(id, cls) { var el = $id(id); if (el) el.className = cls; }
        function safeDisplay(id, show) { var el = $id(id); if (el) el.style.display = show ? '' : 'none'; }
        
        // Inverser un score (ex: "6-1 6-4" -> "1-6 4-6") pour affichage du point de vue du perdant
        function invertScore(score) {
            if (!score) return '';
            var sets = score.trim().split(/\s+/);
            var inverted = [];
            for (var i = 0; i < sets.length; i++) {
                var parts = sets[i].split('-');
                if (parts.length === 2 && !isNaN(parts[0]) && !isNaN(parts[1])) {
                    inverted.push(parts[1] + '-' + parts[0]);
                } else {
                    inverted.push(sets[i]);
                }
            }
            return inverted.join(' ');
        }
        
        // ==================== API CONFIG ====================
        const RAPIDAPI_KEY = '01de7bd523msh5fc9b5c25b73cc8p125f24jsn0fe9500c376f';
        const FLASHSCORE_HOST = 'flashlive-sports.p.rapidapi.com';
        const PINNACLE_HOST = 'pinnacle-odds.p.rapidapi.com';
        
        // Proxy CORS pour contourner les restrictions navigateur
        const CORS_PROXY = 'https://corsproxy.io/?';
        
        // Fonction helper pour les appels API avec proxy CORS
        async function fetchWithCORS(url, options = {}) {
            const proxyUrl = CORS_PROXY + encodeURIComponent(url);
            return fetch(proxyUrl, options);
        }

        // ==================== NICHES ====================
        let NICHES_ATP = [
            { id:'atp1', name:'UND ATP250 Clay SF+F @2.5-3.5', cat:'ATP 250', surf:'Clay', rounds:['SF','F'], strat:'underdog', min:2.5, max:3.5, on:true },
            { id:'atp2', name:'UND ATP250 Hard F @2.0-2.5', cat:'ATP 250', surf:'Hard', rounds:['F'], strat:'underdog', min:2.0, max:2.5, on:true },
            { id:'atp3', name:'UND GS Clay R32 @2.0-3.0', cat:'Grand Slam', surf:'Clay', rounds:['R32'], strat:'underdog', min:2.0, max:3.0, on:true },
            { id:'atp4', name:'FAV ATP500 Clay R32 @1.5-2.0', cat:'ATP 500', surf:'Clay', rounds:['R32'], strat:'favorite', min:1.5, max:2.0, on:true },
            { id:'atp5', name:'UND M1000 Hard SF @3.0-4.0', cat:'Masters 1000', surf:'Hard', rounds:['SF'], strat:'underdog', min:3.0, max:4.0, on:true },
            { id:'atp6', name:'UND GS Hard QF @2.0-3.0', cat:'Grand Slam', surf:'Hard', rounds:['QF'], strat:'underdog', min:2.0, max:3.0, on:true },
            { id:'atp7', name:'UND M1000 Hard F @2.0-3.0', cat:'Masters 1000', surf:'Hard', rounds:['F'], strat:'underdog', min:2.0, max:3.0, on:true },
            { id:'atp8', name:'UND ATP500 Grass SF+F @2.0-3.0', cat:'ATP 500', surf:'Grass', rounds:['SF','F'], strat:'underdog', min:2.0, max:3.0, on:true },
            { id:'atp9', name:'UND M1000 Clay R16 @2.5-3.5', cat:'Masters 1000', surf:'Clay', rounds:['R16'], strat:'underdog', min:2.5, max:3.5, on:true },
        ];

        let NICHES_WTA = [
            { id:'wta1', name:'GS Hard R16 @2.5-3.5', cat:'Grand Slam', surf:'Hard', rounds:['R16'], strat:'underdog', min:2.5, max:3.5, on:true, confirmed:true },
            { id:'wta2', name:'GS Clay R16+QF @1.5-2.5', cat:'Grand Slam', surf:'Clay', rounds:['R16','QF'], strat:'underdog', min:1.5, max:2.5, on:true, confirmed:true },
            { id:'wta3', name:'GS Hard QF+SF @1.5-2.5', cat:'Grand Slam', surf:'Hard', rounds:['QF','SF'], strat:'underdog', min:1.5, max:2.5, on:true, confirmed:true },
            { id:'wta4', name:'WTA500 Hard R16 @2.5-3.0', cat:'WTA 500', surf:'Hard', rounds:['R16'], strat:'underdog', min:2.5, max:3.0, on:true, confirmed:true },
            { id:'wta5', name:'WTA250 Grass QF+SF @2.5-3.5', cat:'WTA 250', surf:'Grass', rounds:['QF','SF'], strat:'underdog', min:2.5, max:3.5, on:true, confirmed:true },
            { id:'wta6', name:'WTA250 Clay SF @2.0-3.0', cat:'WTA 250', surf:'Clay', rounds:['SF'], strat:'underdog', min:2.0, max:3.0, on:true, confirmed:true },
            { id:'wta7', name:'‚ö° WTA1000 Clay R32 @3.0-4.0', cat:'WTA 1000', surf:'Clay', rounds:['R32'], strat:'underdog', min:3.0, max:4.0, on:true, confirmed:false },
            { id:'wta8', name:'‚ö° WTA1000 Hard QF @1.5-2.5', cat:'WTA 1000', surf:'Hard', rounds:['QF'], strat:'underdog', min:1.5, max:2.5, on:true, confirmed:false },
            { id:'wta9', name:'‚ö° WTA1000 Hard R16 @2.5-3.0', cat:'WTA 1000', surf:'Hard', rounds:['R16'], strat:'underdog', min:2.5, max:3.0, on:true, confirmed:false },
        ];
        
        // Sauvegarder les niches dans localStorage
        function saveNiches() {
            localStorage.setItem('tennisLabNichesATP', JSON.stringify(NICHES_ATP));
            localStorage.setItem('tennisLabNichesWTA', JSON.stringify(NICHES_WTA));
            console.log('Niches sauvegard√©es - ATP:', NICHES_ATP.length, 'WTA:', NICHES_WTA.length);
        }
        
        // Charger les niches depuis localStorage
        function loadNiches() {
            var savedATP = localStorage.getItem('tennisLabNichesATP');
            var savedWTA = localStorage.getItem('tennisLabNichesWTA');
            
            if (savedATP) {
                try {
                    NICHES_ATP = JSON.parse(savedATP);
                    console.log('Niches ATP charg√©es:', NICHES_ATP.length);
                } catch (e) {
                    console.error('Erreur chargement niches ATP:', e);
                }
            }
            
            if (savedWTA) {
                try {
                    NICHES_WTA = JSON.parse(savedWTA);
                    console.log('Niches WTA charg√©es:', NICHES_WTA.length);
                } catch (e) {
                    console.error('Erreur chargement niches WTA:', e);
                }
            }
        }
        
        // Charger les niches au d√©marrage
        loadNiches();
        
        // Exporter les niches en JSON
        function exportNiches() {
            var data = {
                version: 1,
                exportDate: new Date().toISOString(),
                atp: NICHES_ATP,
                wta: NICHES_WTA
            };
            var blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
            var url = URL.createObjectURL(blob);
            var a = document.createElement('a');
            a.href = url;
            a.download = 'tennis_niches_' + new Date().toISOString().split('T')[0] + '.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        // Importer des niches depuis un fichier JSON
        function importNiches(event) {
            var file = event.target.files[0];
            if (!file) return;
            
            var reader = new FileReader();
            reader.onload = function(e) {
                try {
                    var data = JSON.parse(e.target.result);
                    
                    if (data.atp && Array.isArray(data.atp)) {
                        NICHES_ATP = data.atp;
                    }
                    if (data.wta && Array.isArray(data.wta)) {
                        NICHES_WTA = data.wta;
                    }
                    
                    saveNiches();
                    syncAllNichesUI();
                    alert('‚úÖ Niches import√©es avec succ√®s !\n\nATP: ' + NICHES_ATP.length + ' niches\nWTA: ' + NICHES_WTA.length + ' niches');
                } catch (err) {
                    alert('‚ùå Erreur lors de l\'import: ' + err.message);
                }
            };
            reader.readAsText(file);
            event.target.value = ''; // Reset pour permettre de r√©importer le m√™me fichier
        }
        
        // R√©initialiser les niches par d√©faut
        function resetNichesToDefault() {
            if (!confirm('‚ö†Ô∏è R√©initialiser toutes les niches aux valeurs par d√©faut ?\n\nCette action effacera toutes vos modifications.')) return;
            
            // Niches par d√©faut
            NICHES_ATP = [
                { id:'atp1', name:'UND ATP250 Clay SF+F @2.5-3.5', cat:'ATP 250', surf:'Clay', rounds:['SF','F'], strat:'underdog', min:2.5, max:3.5, on:true },
                { id:'atp2', name:'UND ATP250 Hard F @2.0-2.5', cat:'ATP 250', surf:'Hard', rounds:['F'], strat:'underdog', min:2.0, max:2.5, on:true },
                { id:'atp3', name:'UND GS Clay R32 @2.0-3.0', cat:'Grand Slam', surf:'Clay', rounds:['R32'], strat:'underdog', min:2.0, max:3.0, on:true },
                { id:'atp4', name:'FAV ATP500 Clay R32 @1.5-2.0', cat:'ATP 500', surf:'Clay', rounds:['R32'], strat:'favorite', min:1.5, max:2.0, on:true },
                { id:'atp5', name:'UND M1000 Hard SF @3.0-4.0', cat:'Masters 1000', surf:'Hard', rounds:['SF'], strat:'underdog', min:3.0, max:4.0, on:true },
                { id:'atp6', name:'UND GS Hard QF @2.0-3.0', cat:'Grand Slam', surf:'Hard', rounds:['QF'], strat:'underdog', min:2.0, max:3.0, on:true },
                { id:'atp7', name:'UND M1000 Hard F @2.0-3.0', cat:'Masters 1000', surf:'Hard', rounds:['F'], strat:'underdog', min:2.0, max:3.0, on:true },
                { id:'atp8', name:'UND ATP500 Grass SF+F @2.0-3.0', cat:'ATP 500', surf:'Grass', rounds:['SF','F'], strat:'underdog', min:2.0, max:3.0, on:true },
                { id:'atp9', name:'UND M1000 Clay R16 @2.5-3.5', cat:'Masters 1000', surf:'Clay', rounds:['R16'], strat:'underdog', min:2.5, max:3.5, on:true },
            ];

            NICHES_WTA = [
                { id:'wta1', name:'GS Hard R16 @2.5-3.5', cat:'Grand Slam', surf:'Hard', rounds:['R16'], strat:'underdog', min:2.5, max:3.5, on:true, confirmed:true },
                { id:'wta2', name:'GS Clay R16+QF @1.5-2.5', cat:'Grand Slam', surf:'Clay', rounds:['R16','QF'], strat:'underdog', min:1.5, max:2.5, on:true, confirmed:true },
                { id:'wta3', name:'GS Hard QF+SF @1.5-2.5', cat:'Grand Slam', surf:'Hard', rounds:['QF','SF'], strat:'underdog', min:1.5, max:2.5, on:true, confirmed:true },
                { id:'wta4', name:'WTA500 Hard R16 @2.5-3.0', cat:'WTA 500', surf:'Hard', rounds:['R16'], strat:'underdog', min:2.5, max:3.0, on:true, confirmed:true },
                { id:'wta5', name:'WTA250 Grass QF+SF @2.5-3.5', cat:'WTA 250', surf:'Grass', rounds:['QF','SF'], strat:'underdog', min:2.5, max:3.5, on:true, confirmed:true },
                { id:'wta6', name:'WTA250 Clay SF @2.0-3.0', cat:'WTA 250', surf:'Clay', rounds:['SF'], strat:'underdog', min:2.0, max:3.0, on:true, confirmed:true },
                { id:'wta7', name:'‚ö° WTA1000 Clay R32 @3.0-4.0', cat:'WTA 1000', surf:'Clay', rounds:['R32'], strat:'underdog', min:3.0, max:4.0, on:true, confirmed:false },
                { id:'wta8', name:'‚ö° WTA1000 Hard QF @1.5-2.5', cat:'WTA 1000', surf:'Hard', rounds:['QF'], strat:'underdog', min:1.5, max:2.5, on:true, confirmed:false },
                { id:'wta9', name:'‚ö° WTA1000 Hard R16 @2.5-3.0', cat:'WTA 1000', surf:'Hard', rounds:['R16'], strat:'underdog', min:2.5, max:3.0, on:true, confirmed:false },
            ];
            
            saveNiches();
            syncAllNichesUI();
            alert('‚úÖ Niches r√©initialis√©es aux valeurs par d√©faut');
        }

        // ==================== ROUNDS ACTIFS PAR CATEGORIE (2024-2025) ====================
        // Utilis√© pour d√©tecter les niches bas√©es sur des tournois morts
        const ROUNDS_ACTIFS = {
            // ATP
            'Grand Slam': ['R128', 'R64', 'R32', 'R16', 'QF', 'SF', 'F'],
            'Masters 1000': ['R128', 'R64', 'R32', 'R16', 'QF', 'SF', 'F'],
            'ATP 500': ['R32', 'R16', 'QF', 'SF', 'F'],  // Certains ont R64 mais rare
            'ATP 250': ['R32', 'R16', 'QF', 'SF', 'F'],  // Seul Winston-Salem a R64
            // WTA
            'WTA 1000': ['R128', 'R64', 'R32', 'R16', 'QF', 'SF', 'F'],
            'WTA 500': ['R32', 'R16', 'QF', 'SF', 'F'],  // Brisbane a R64 mais c'est rare
            'WTA 250': ['R32', 'R16', 'QF', 'SF', 'F'],  // AUCUN tournoi actif n'a R64
        };

        // Exceptions: tournois sp√©cifiques qui ont des rounds inhabituels
        const ROUNDS_EXCEPTIONS = {
            'ATP 250|Hard|R64': ['Winston-Salem'],  // Seul ATP 250 avec R64
            'WTA 500|Hard|R64': ['Brisbane'],       // Seul WTA 500 avec R64 r√©gulier
        };

        // Fonction pour v√©rifier si une combinaison cat/round est active
        function isRoundActiveForCategory(cat, round) {
            var validRounds = ROUNDS_ACTIFS[cat];
            if (!validRounds) return true; // Cat√©gorie inconnue, on assume actif
            return validRounds.indexOf(round) >= 0;
        }

        // Fonction pour obtenir les tournois qui supportent une combinaison
        function getTournamentsForCombo(cat, surf, round) {
            var key = cat + '|' + surf + '|' + round;
            return ROUNDS_EXCEPTIONS[key] || [];
        }

        // ==================== TOURNAMENTS ====================
        const TOURNAMENTS_ATP = [
            // Grand Slams
            { name:'Australian Open', cat:'Grand Slam', surf:'Hard', rounds:['R128','R64','R32','R16','QF','SF','F'] },
            { name:'Roland Garros', cat:'Grand Slam', surf:'Clay', rounds:['R128','R64','R32','R16','QF','SF','F'] },
            { name:'Wimbledon', cat:'Grand Slam', surf:'Grass', rounds:['R128','R64','R32','R16','QF','SF','F'] },
            { name:'US Open', cat:'Grand Slam', surf:'Hard', rounds:['R128','R64','R32','R16','QF','SF','F'] },
            // Masters 1000
            { name:'Indian Wells', cat:'Masters 1000', surf:'Hard', rounds:['R64','R32','R16','QF','SF','F'] },
            { name:'Miami', cat:'Masters 1000', surf:'Hard', rounds:['R64','R32','R16','QF','SF','F'] },
            { name:'Monte-Carlo', cat:'Masters 1000', surf:'Clay', rounds:['R32','R16','QF','SF','F'] },
            { name:'Madrid', cat:'Masters 1000', surf:'Clay', rounds:['R64','R32','R16','QF','SF','F'] },
            { name:'Rome', cat:'Masters 1000', surf:'Clay', rounds:['R64','R32','R16','QF','SF','F'] },
            { name:'Toronto', cat:'Masters 1000', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            { name:'Montreal', cat:'Masters 1000', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            { name:'Cincinnati', cat:'Masters 1000', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            { name:'Shanghai', cat:'Masters 1000', surf:'Hard', rounds:['R64','R32','R16','QF','SF','F'] },
            { name:'Paris', cat:'Masters 1000', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            // ATP 500 - Clay
            { name:'Barcelona', cat:'ATP 500', surf:'Clay', rounds:['R32','R16','QF','SF','F'] },
            { name:'Rio', cat:'ATP 500', surf:'Clay', rounds:['R32','R16','QF','SF','F'] },
            { name:'Hamburg', cat:'ATP 500', surf:'Clay', rounds:['R32','R16','QF','SF','F'] },
            { name:'Acapulco', cat:'ATP 500', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            { name:'Dubai', cat:'ATP 500', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            { name:'Rotterdam', cat:'ATP 500', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            { name:'Basel', cat:'ATP 500', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            { name:'Vienna', cat:'ATP 500', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            { name:'Beijing', cat:'ATP 500', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            { name:'Tokyo', cat:'ATP 500', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            { name:'Washington', cat:'ATP 500', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            { name:'Doha', cat:'ATP 500', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            { name:'Dallas', cat:'ATP 500', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            { name:'Munich', cat:'ATP 500', surf:'Clay', rounds:['R32','R16','QF','SF','F'] },
            // ATP 500 - Grass
            { name:'Halle', cat:'ATP 500', surf:'Grass', rounds:['R32','R16','QF','SF','F'] },
            { name:"Queen's", cat:'ATP 500', surf:'Grass', rounds:['R32','R16','QF','SF','F'] },
            // ATP 250 - Hard
            { name:'Brisbane', cat:'ATP 250', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            { name:'Adelaide', cat:'ATP 250', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            { name:'Auckland', cat:'ATP 250', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            { name:'Hong Kong', cat:'ATP 250', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            { name:'Montpellier', cat:'ATP 250', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            { name:'Marseille', cat:'ATP 250', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            { name:'Delray Beach', cat:'ATP 250', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            { name:'Los Cabos', cat:'ATP 250', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            { name:'Atlanta', cat:'ATP 250', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            { name:'Winston-Salem', cat:'ATP 250', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            { name:'Chengdu', cat:'ATP 250', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            { name:'Zhuhai', cat:'ATP 250', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            { name:'Sofia', cat:'ATP 250', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            { name:'Antwerp', cat:'ATP 250', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            { name:'Stockholm', cat:'ATP 250', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            { name:'Metz', cat:'ATP 250', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            // ATP 250 - Clay
            { name:'Marrakech', cat:'ATP 250', surf:'Clay', rounds:['R32','R16','QF','SF','F'] },
            { name:'Houston', cat:'ATP 250', surf:'Clay', rounds:['R32','R16','QF','SF','F'] },
            { name:'Geneva', cat:'ATP 250', surf:'Clay', rounds:['R32','R16','QF','SF','F'] },
            { name:'Lyon', cat:'ATP 250', surf:'Clay', rounds:['R32','R16','QF','SF','F'] },
            { name:'Estoril', cat:'ATP 250', surf:'Clay', rounds:['R32','R16','QF','SF','F'] },
            { name:'Belgrade', cat:'ATP 250', surf:'Clay', rounds:['R32','R16','QF','SF','F'] },
            { name:'Bucharest', cat:'ATP 250', surf:'Clay', rounds:['R32','R16','QF','SF','F'] },
            { name:'Cordoba', cat:'ATP 250', surf:'Clay', rounds:['R32','R16','QF','SF','F'] },
            { name:'Buenos Aires', cat:'ATP 250', surf:'Clay', rounds:['R32','R16','QF','SF','F'] },
            { name:'Santiago', cat:'ATP 250', surf:'Clay', rounds:['R32','R16','QF','SF','F'] },
            { name:'Bastad', cat:'ATP 250', surf:'Clay', rounds:['R32','R16','QF','SF','F'] },
            { name:'Gstaad', cat:'ATP 250', surf:'Clay', rounds:['R32','R16','QF','SF','F'] },
            { name:'Kitzbuhel', cat:'ATP 250', surf:'Clay', rounds:['R32','R16','QF','SF','F'] },
            { name:'Umag', cat:'ATP 250', surf:'Clay', rounds:['R32','R16','QF','SF','F'] },
            // ATP 250 - Grass
            { name:'Stuttgart', cat:'ATP 250', surf:'Grass', rounds:['R32','R16','QF','SF','F'] },
            { name:'s-Hertogenbosch', cat:'ATP 250', surf:'Grass', rounds:['R32','R16','QF','SF','F'] },
            { name:'Eastbourne', cat:'ATP 250', surf:'Grass', rounds:['R32','R16','QF','SF','F'] },
            { name:'Mallorca', cat:'ATP 250', surf:'Grass', rounds:['R32','R16','QF','SF','F'] },
            { name:'Newport', cat:'ATP 250', surf:'Grass', rounds:['R32','R16','QF','SF','F'] },
            // ATP 250 - Indoor Hard (ajouts 2026)
            { name:'Almaty', cat:'ATP 250', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            { name:'Lyon', cat:'ATP 250', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            { name:'Brussels', cat:'ATP 250', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            // ATP 250 - Clay (ajouts)
            { name:'Estoril', cat:'ATP 250', surf:'Clay', rounds:['R32','R16','QF','SF','F'] },
        ];

        const TOURNAMENTS_WTA = [
            // Grand Slams
            { name:'Australian Open', cat:'Grand Slam', surf:'Hard', rounds:['R128','R64','R32','R16','QF','SF','F'] },
            { name:'Roland Garros', cat:'Grand Slam', surf:'Clay', rounds:['R128','R64','R32','R16','QF','SF','F'] },
            { name:'Wimbledon', cat:'Grand Slam', surf:'Grass', rounds:['R128','R64','R32','R16','QF','SF','F'] },
            { name:'US Open', cat:'Grand Slam', surf:'Hard', rounds:['R128','R64','R32','R16','QF','SF','F'] },
            // WTA 1000
            { name:'Indian Wells', cat:'WTA 1000', surf:'Hard', rounds:['R64','R32','R16','QF','SF','F'] },
            { name:'Miami', cat:'WTA 1000', surf:'Hard', rounds:['R64','R32','R16','QF','SF','F'] },
            { name:'Madrid', cat:'WTA 1000', surf:'Clay', rounds:['R64','R32','R16','QF','SF','F'] },
            { name:'Rome', cat:'WTA 1000', surf:'Clay', rounds:['R64','R32','R16','QF','SF','F'] },
            { name:'Toronto', cat:'WTA 1000', surf:'Hard', rounds:['R64','R32','R16','QF','SF','F'] },
            { name:'Cincinnati', cat:'WTA 1000', surf:'Hard', rounds:['R64','R32','R16','QF','SF','F'] },
            { name:'Doha', cat:'WTA 1000', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            { name:'Dubai', cat:'WTA 1000', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            { name:'Beijing', cat:'WTA 1000', surf:'Hard', rounds:['R64','R32','R16','QF','SF','F'] },
            { name:'Wuhan', cat:'WTA 1000', surf:'Hard', rounds:['R64','R32','R16','QF','SF','F'] },
            // WTA 500 - Hard
            { name:'Abu Dhabi', cat:'WTA 500', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            { name:'San Diego', cat:'WTA 500', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            { name:'Tokyo', cat:'WTA 500', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            { name:'Linz', cat:'WTA 500', surf:'Clay', rounds:['R32','R16','QF','SF','F'] },
            { name:'Ostrava', cat:'WTA 500', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            { name:'Seoul', cat:'WTA 500', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            { name:'Guadalajara', cat:'WTA 500', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            { name:'Adelaide', cat:'WTA 500', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            { name:'Brisbane', cat:'WTA 500', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            // WTA 500 - Clay
            { name:'Stuttgart', cat:'WTA 500', surf:'Clay', rounds:['R32','R16','QF','SF','F'] },
            { name:'Charleston', cat:'WTA 500', surf:'Clay', rounds:['R32','R16','QF','SF','F'] },
            { name:'Rabat', cat:'WTA 500', surf:'Clay', rounds:['R32','R16','QF','SF','F'] },
            // WTA 500 - Grass
            { name:'Berlin', cat:'WTA 500', surf:'Grass', rounds:['R32','R16','QF','SF','F'] },
            { name:'Eastbourne', cat:'WTA 500', surf:'Grass', rounds:['R32','R16','QF','SF','F'] },
            // WTA 250 - Grass
            { name:'Nottingham', cat:'WTA 250', surf:'Grass', rounds:['R32','R16','QF','SF','F'] },
            { name:'Birmingham', cat:'WTA 250', surf:'Grass', rounds:['R32','R16','QF','SF','F'] },
            { name:'Bad Homburg', cat:'WTA 250', surf:'Grass', rounds:['R32','R16','QF','SF','F'] },
            { name:'s-Hertogenbosch', cat:'WTA 250', surf:'Grass', rounds:['R32','R16','QF','SF','F'] },
            // WTA 250 - Clay
            { name:'Bogota', cat:'WTA 250', surf:'Clay', rounds:['R32','R16','QF','SF','F'] },
            { name:'Strasbourg', cat:'WTA 250', surf:'Clay', rounds:['R32','R16','QF','SF','F'] },
            { name:'Prague', cat:'WTA 250', surf:'Clay', rounds:['R32','R16','QF','SF','F'] },
            { name:'Palermo', cat:'WTA 250', surf:'Clay', rounds:['R32','R16','QF','SF','F'] },
            { name:'Budapest', cat:'WTA 250', surf:'Clay', rounds:['R32','R16','QF','SF','F'] },
            { name:'Lausanne', cat:'WTA 250', surf:'Clay', rounds:['R32','R16','QF','SF','F'] },
            { name:'Iasi', cat:'WTA 250', surf:'Clay', rounds:['R32','R16','QF','SF','F'] },
            // WTA 250 - Hard
            { name:'Hobart', cat:'WTA 250', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            { name:'Auckland', cat:'WTA 250', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            { name:'Hua Hin', cat:'WTA 250', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            { name:'Taipei', cat:'WTA 250', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            { name:'Lyon', cat:'WTA 250', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            { name:'Monterrey', cat:'WTA 250', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            { name:'Cleveland', cat:'WTA 250', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            { name:'Guangzhou', cat:'WTA 250', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            { name:'Ningbo', cat:'WTA 250', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            { name:'Hong Kong', cat:'WTA 250', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            { name:'Jiujiang', cat:'WTA 250', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            // WTA 250/500 - Nouveaux 2026
            { name:'Cluj-Napoca', cat:'WTA 500', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            { name:'Merida', cat:'WTA 250', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            { name:'Austin', cat:'WTA 250', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            { name:'S√£o Paulo', cat:'WTA 250', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            { name:'Singapore', cat:'WTA 250', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            { name:'Osaka', cat:'WTA 250', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            { name:'Chennai', cat:'WTA 250', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
            { name:'Rouen', cat:'WTA 250', surf:'Clay', rounds:['R32','R16','QF','SF','F'] },
            { name:'Hamburg', cat:'WTA 250', surf:'Clay', rounds:['R32','R16','QF','SF','F'] },
            { name:'Washington', cat:'WTA 500', surf:'Hard', rounds:['R32','R16','QF','SF','F'] },
        ];

        // ==================== STATE ====================
        let state = {
            bankroll: 5000,
            initialBankroll: 5000,
            stake: 250,
            pctStake: 3,      // % pour strat√©gie %BR
            kellyDiv: 4,      // Diviseur Kelly
            pending: [],
            history: []
        };

        let btCircuit = 'atp';
        let btData = [];
        let btDataATP = [];
        let btDataWTA = [];
        let btResults = [];
        let btChart = null;
        let trackerCircuit = 'all';
        let calendarCircuit = 'all';
        // Mettre √† jour l'affichage de la strat√©gie dans le Tracker (bas√© sur Config)
        function updateTrackerStratInfo() {
            var labelEl = document.getElementById('trackerStratLabel');
            var miseEl = document.getElementById('trackerStratMise');
            var infoEl = document.getElementById('trackerStratInfo');
            if (!labelEl || !miseEl) {
                console.log('[DEBUG] trackerStratLabel or trackerStratMise not found');
                return;
            }
            
            // Lire les valeurs depuis Config
            var cfgBankrollEl = document.getElementById('cfgBankroll');
            var cfgStakeEl = document.getElementById('cfgStake');
            var cfgPctStakeEl = document.getElementById('cfgPctStake');
            var cfgStrategyEl = document.getElementById('cfgStakeStrategy');
            
            var bankroll = cfgBankrollEl ? parseFloat(cfgBankrollEl.value) || 5000 : state.bankroll || 5000;
            var flatStake = cfgStakeEl ? parseFloat(cfgStakeEl.value) || 100 : state.stake || 100;
            var pctStake = cfgPctStakeEl ? parseFloat(cfgPctStakeEl.value) || 3 : 3;
            var strategy = cfgStrategyEl ? cfgStrategyEl.value : 'flat';
            
            var mise, stratLabel, stratColor;
            if (strategy === 'flat') {
                mise = flatStake;
                stratLabel = 'üíµ Flat ' + Math.round(flatStake) + '‚Ç¨';
                stratColor = 'var(--blue)';
            } else {
                mise = bankroll * (pctStake / 100);
                stratLabel = 'üìä ' + pctStake + '% BR';
                stratColor = 'var(--green)';
            }
            
            // Solution simple : on met √† jour directement le innerHTML
            labelEl.innerHTML = '<span style="color:' + stratColor + ';font-weight:600">' + stratLabel + '</span>';
            miseEl.innerHTML = 'Mise: <b style="color:' + stratColor + '">' + Math.round(mise) + '‚Ç¨</b>';
            
            // Forcer un reflow
            void labelEl.offsetHeight;
            void miseEl.offsetHeight;
            
            console.log('[DEBUG] Tracker info updated - strategy:', strategy, 'mise:', Math.round(mise));
        }
        
        // Calculer la mise selon la strat√©gie de Config
        function calcTrackerStake(nicheObj) {
            var stakeCoef = (nicheObj && nicheObj.stakeCoef) ? nicheObj.stakeCoef : 1.0;
            
            // Lire les valeurs depuis Config
            var cfgBankrollEl = document.getElementById('cfgBankroll');
            var cfgStakeEl = document.getElementById('cfgStake');
            var cfgPctStakeEl = document.getElementById('cfgPctStake');
            var cfgStrategyEl = document.getElementById('cfgStakeStrategy');
            
            var bankroll = cfgBankrollEl ? parseFloat(cfgBankrollEl.value) || 5000 : state.bankroll || 5000;
            var flatStake = cfgStakeEl ? parseFloat(cfgStakeEl.value) || 100 : state.stake || 100;
            var pctStake = cfgPctStakeEl ? parseFloat(cfgPctStakeEl.value) || 3 : 3;
            var strategy = cfgStrategyEl ? cfgStrategyEl.value : 'flat';
            
            var stake;
            if (strategy === 'flat') {
                stake = flatStake * stakeCoef;
            } else { // percent
                stake = bankroll * (pctStake / 100) * stakeCoef;
            }
            
            return Math.max(1, Math.min(stake, bankroll));
        }

        // Synchronise les param√®tres du simulateur avec le calendrier
        function updateCalendarProjections() {
            console.log('updateCalendarProjections called');
            var simBankroll = document.getElementById('cfgBankroll');
            var simFlatStake = document.getElementById('cfgStake');
            var simPctStake = document.getElementById('cfgPctStake');
            var simKellyDiv = document.getElementById('simKellyDiv');
            
            if (simBankroll && simFlatStake) {
                var newBankroll = parseFloat(simBankroll.value) || 5000;
                var newStake = parseFloat(simFlatStake.value) || 150;
                var newPctStake = simPctStake ? parseFloat(simPctStake.value) || 3 : 3;
                var newKellyDiv = simKellyDiv ? parseFloat(simKellyDiv.value) || 4 : 4;
                
                // Mettre √† jour state
                state.bankroll = newBankroll;
                state.initialBankroll = newBankroll;
                state.stake = newStake;
                state.pctStake = newPctStake;
                state.kellyDiv = newKellyDiv;
                
                // Sauvegarder
                if (typeof saveState === 'function') saveState();
                
                // Re-render le calendrier
                if (typeof renderCalendar === 'function') {
                    renderCalendar();
                }
                
                // Mettre √† jour l'info de strat√©gie du tracker
                if (typeof updateTrackerStratInfo === 'function') {
                    updateTrackerStratInfo();
                }
                
                console.log('Calendar updated: bankroll=' + newBankroll + ', stake=' + newStake + ', pctStake=' + newPctStake);
            } else {
                console.log('simBankroll or simFlatStake not found');
            }
        }

        // ==================== AUTO-LOAD DATA (PWA) ====================
        // Base URL pour les donnees - a changer apres deploy GitHub Pages
        var DATA_BASE_URL = './';  // Chemin relatif par defaut

        async function autoLoadData() {
            console.log('[PWA] === DEBUT autoLoadData ===');
            console.log('[PWA] DATA_BASE_URL:', DATA_BASE_URL);
            console.log('[PWA] btCircuit actuel:', btCircuit);
            console.log('[PWA] parseCSV existe:', typeof parseCSV);
            var atpLoaded = false, wtaLoaded = false;
            try {
                // Charger ATP
                const atpResponse = await fetch(DATA_BASE_URL + 'atp_normalized.csv');
                if (atpResponse.ok) {
                    const atpText = await atpResponse.text();
                    btCircuit = 'atp';  // Definir le circuit AVANT parseCSV
                    if (typeof parseCSV === 'function') {
                        parseCSV(atpText);
                        atpLoaded = true;
                        console.log('[PWA] ATP charge OK');
                    }
                }

                // Charger WTA
                const wtaResponse = await fetch(DATA_BASE_URL + 'wta_normalized.csv');
                if (wtaResponse.ok) {
                    const wtaText = await wtaResponse.text();
                    btCircuit = 'wta';  // Definir le circuit AVANT parseCSV
                    if (typeof parseCSV === 'function') {
                        parseCSV(wtaText);
                        wtaLoaded = true;
                        console.log('[PWA] WTA charge OK');
                    }
                }

                // Revenir sur ATP par defaut
                btCircuit = 'atp';

                if (atpLoaded && wtaLoaded) {
                    console.log('[PWA] Donnees chargees avec succes');
                    showToast('Donnees ATP & WTA chargees', 'success');
                } else if (atpLoaded || wtaLoaded) {
                    showToast('Donnees partiellement chargees', 'info');
                }

                // Initialiser le selecteur d'annees du simulateur
                if (typeof initYearSelector === 'function') initYearSelector();
                if (typeof updateSimNichesSummary === 'function') updateSimNichesSummary();
            } catch (err) {
                console.log('[PWA] Erreur chargement:', err.message);
                // Pas de toast d'erreur - l'utilisateur peut charger manuellement
            }
        }

        // Enregistrement Service Worker
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('./sw.js')
                .then(reg => console.log('[SW] Enregistre:', reg.scope))
                .catch(err => console.log('[SW] Erreur:', err));
        }

        // ==================== INIT ====================
        function init() {
            loadState();
            updateTournamentSelect();
            renderTrackerUI();
            renderNiches();
            renderCalendar();
            updateConfig();

            // Initialiser l'affichage de la strat√©gie du tracker
            updateTrackerStratInfo();

            // Mettre √† jour l'affichage du simulateur depuis Config
            updateSimDisplay();

            // Auto-charger les donnees CSV (PWA)
            autoLoadData();
        }

        function loadState() {
            const saved = localStorage.getItem('tennisBettingLab');
            if (saved) {
                const parsed = JSON.parse(saved);
                state = { ...state, ...parsed };
            }
        }

        // Calcule le drawdown actuel et max
        function calculateDrawdown(history, initialBankroll) {
            if (history.length === 0) {
                return { currentDD: 0, maxDD: 0, ddHistory: [] };
            }
            
            // Trier par date
            const sorted = [...history].sort((a, b) => 
                (a.resolvedDate || a.date).localeCompare(b.resolvedDate || b.date)
            );
            
            let bankroll = initialBankroll;
            let peak = initialBankroll;
            let maxDD = 0;
            let currentDD = 0;
            const ddHistory = [];
            
            sorted.forEach(bet => {
                bankroll += bet.pnl;
                
                if (bankroll > peak) {
                    peak = bankroll;
                }
                
                const dd = peak - bankroll;
                if (dd > maxDD) {
                    maxDD = dd;
                }
                
                currentDD = dd;
                ddHistory.push({ dd, bankroll, peak });
            });
            
            return { currentDD, maxDD, ddHistory };
        }

        function saveState() {
            localStorage.setItem('tennisBettingLab', JSON.stringify(state));
            renderTrackerUI();
            safeText('headerBankroll', state.bankroll.toFixed(0) + '‚Ç¨');
            // V2 updates
            if (typeof updateStreaks === 'function') updateStreaks();
            if (typeof updateGoal === 'function') updateGoal();
            if (typeof checkMilestones === 'function') checkMilestones();
            if (typeof renderStats === 'function') renderStats();
        }

        // ==================== EXPORT/IMPORT ====================
        function exportData() {
            const data = {
                version: '1.0',
                exportDate: new Date().toISOString(),
                state: state
            };
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'tennis_betting_lab_' + new Date().toISOString().split('T')[0] + '.json';
            a.click();
            URL.revokeObjectURL(url);
            safeHTML('importStatus', '<span style="color:var(--green)">‚úÖ Export r√©ussi !</span>');
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    if (data.state) {
                        state = { ...state, ...data.state };
                        saveState();
                        safeHTML('importStatus', '<span style="color:var(--green)">‚úÖ Import r√©ussi ! ' + (state.history.length) + ' paris charg√©s.</span>');
                    } else {
                        throw new Error('Format invalide');
                    }
                } catch (err) {
                    safeHTML('importStatus', '<span style="color:var(--red)">‚ùå Erreur: ' + err.message + '</span>');
                }
            };
            reader.readAsText(file);
        }

        // ==================== MAIN TABS ====================
        function showMainTab(id) {
            // Rediriger les anciens onglets
            if (id === 'backtest') id = 'simulator';
            if (id === 'niches') id = 'lab';
            
            document.querySelectorAll('.main-tab').forEach(t => t.classList.remove('active'));
            var tabBtn = document.querySelector(`.main-tab[onclick="showMainTab('${id}')"]`);
            if (tabBtn) tabBtn.classList.add('active');
            
            document.querySelectorAll('.main-content').forEach(c => c.classList.remove('active'));
            var content = document.getElementById('main-' + id);
            if (content) content.classList.add('active');
            
            // Update tracker strategy info when opening tracker tab
            if (id === 'tracker' && typeof updateTrackerStratInfo === 'function') {
                updateTrackerStratInfo();
            }
            
            // Render niches list when opening lab tab
            if (id === 'lab' && typeof renderNichesList === 'function') {
                renderNichesList();
            }
            
            // Update simulator summary when opening simulator tab
            if (id === 'simulator' && typeof updateSimNichesSummary === 'function') {
                updateSimNichesSummary();
            }
            
            // Update stake recommendations when opening config tab
            if (id === 'config' && typeof updateStakeRecommendations === 'function') {
                updateStakeRecommendations();
                updateProjectionDisplay();
            }
            
            // Update calendar when opening calendar tab
            if (id === 'calendar' && typeof renderCalendar === 'function') {
                renderCalendar();
            }
        }

        // ==================== TRACKER ====================
        function setTrackerCircuit(c) {
            trackerCircuit = c;
            document.querySelectorAll('#main-tracker .circuit-tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`.circuit-tab.${c === 'all' ? 'global' : c}`).classList.add('active');
            renderTrackerUI();
        }

        function updateTournamentSelect() {
            const circuit = document.getElementById('addCircuit').value;
            const tournaments = circuit === 'atp' ? TOURNAMENTS_ATP : TOURNAMENTS_WTA;
            const select = document.getElementById('addTournament');
            
            // Ordre des cat√©gories (noms exacts des donn√©es)
            const catOrder = circuit === 'atp' 
                ? ['Grand Slam', 'Masters 1000', 'ATP 500', 'ATP 250']
                : ['Grand Slam', 'WTA 1000', 'WTA 500', 'WTA 250'];
            
            // Grouper par cat√©gorie
            const groups = {};
            tournaments.forEach(t => {
                if (!groups[t.cat]) groups[t.cat] = [];
                groups[t.cat].push(t);
            });
            
            // Trier les tournois dans chaque groupe par nom
            for (const cat in groups) {
                groups[cat].sort((a, b) => a.name.localeCompare(b.name));
            }

            let html = '<option value="">-- S√©lectionner --</option>';
            
            // Afficher dans l'ordre des cat√©gories
            catOrder.forEach(cat => {
                if (groups[cat] && groups[cat].length > 0) {
                    const icon = cat.includes('Grand') ? 'üèÜ' : cat.includes('1000') ? '‚≠ê' : cat.includes('500') ? 'üéæ' : 'üìç';
                    html += `<optgroup label="${icon} ${cat}">`;
                    groups[cat].forEach(t => {
                        const surfIcon = t.surf === 'Hard' ? 'üîµ' : t.surf === 'Clay' ? 'üü†' : t.surf === 'Grass' ? 'üü¢' : '‚ö™';
                        html += `<option value="${t.name}|${t.cat}|${t.surf}|${t.rounds.join(',')}">${surfIcon} ${t.name}</option>`;
                    });
                    html += '</optgroup>';
                }
            });
            
            select.innerHTML = html;
        }

        function onCircuitChange() {
            updateTournamentSelect();
            safeHTML('addRound', '');
            updateMatchCheck();
        }

        function onTournamentChange() {
            const val = document.getElementById('addTournament').value;
            if (!val) return;
            const parts = val.split('|');
            const rounds = parts[3].split(',');
            
            const labels = { F:'Finale', SF:'Demi', QF:'Quart', R16:'8√®mes', R32:'16√®mes', R64:'32√®mes', R128:'64√®mes' };
            safeHTML('addRound', rounds.map(r => `<option value="${r}">${labels[r] || r}</option>`).join(''));
            updateMatchCheck();
        }

        function findMatchingNiche(circuit, cat, surf, round, o1, o2) {
            const niches = circuit === 'atp' ? NICHES_ATP : NICHES_WTA;
            const dogOdds = Math.max(o1, o2);
            const favOdds = Math.min(o1, o2);

            for (const n of niches.filter(x => x.on)) {
                if (n.cat !== cat || n.surf !== surf || !n.rounds.includes(round)) continue;
                const odds = n.strat === 'underdog' ? dogOdds : favOdds;
                if (odds >= n.min && odds <= n.max) {
                    return {
                        niche: n,
                        odds,
                        betOn: n.strat === 'underdog' ? (o1 > o2 ? 'p1' : 'p2') : (o1 < o2 ? 'p1' : 'p2')
                    };
                }
            }
            return null;
        }

        // Fonction pour calculer la mise selon la config (sans niches)
        function calcUniversalStake() {
            var cfgBankrollEl = document.getElementById('cfgBankroll');
            var cfgStakeEl = document.getElementById('cfgStake');
            var cfgPctStakeEl = document.getElementById('cfgPctStake');
            var cfgStrategyEl = document.getElementById('cfgStakeStrategy');

            var bankroll = cfgBankrollEl ? parseFloat(cfgBankrollEl.value) || 5000 : state.bankroll || 5000;
            var flatStake = cfgStakeEl ? parseFloat(cfgStakeEl.value) || 100 : state.stake || 100;
            var pctStake = cfgPctStakeEl ? parseFloat(cfgPctStakeEl.value) || 3 : 3;
            var strategy = cfgStrategyEl ? cfgStrategyEl.value : 'flat';

            if (strategy === 'flat') {
                return Math.round(flatStake);
            } else {
                return Math.round(bankroll * (pctStake / 100));
            }
        }

        // Pr√©visualisation du pari (version universelle - sans niches)
        function updateBetPreview() {
            var previewEl = document.getElementById('betPreview');
            var previewTextEl = document.getElementById('betPreviewText');
            var btnEl = document.getElementById('addMatchBtn');

            // V√©rifications null
            if (!btnEl) {
                console.log('[Tracker] btnEl not found');
                return;
            }

            var tournamentEl = document.getElementById('addTournament');
            var betOnEl = document.getElementById('addBetOn');
            var p1El = document.getElementById('addPlayer1');
            var p2El = document.getElementById('addPlayer2');
            var o1El = document.getElementById('addOdds1');
            var o2El = document.getElementById('addOdds2');

            var val = tournamentEl ? tournamentEl.value : '';
            var betOn = betOnEl ? betOnEl.value : '';
            var p1 = p1El ? p1El.value.trim() : '';
            var p2 = p2El ? p2El.value.trim() : '';
            var o1 = o1El ? (parseFloat(o1El.value) || 0) : 0;
            var o2 = o2El ? (parseFloat(o2El.value) || 0) : 0;

            // V√©rifier si tout est rempli
            var isComplete = val && betOn && p1 && p2 && o1 >= 1.01 && o2 >= 1.01;

            if (!isComplete) {
                if (previewEl) previewEl.style.display = 'none';
                btnEl.disabled = true;
                return;
            }

            // Calculer la mise
            var stake = calcUniversalStake();
            var odds = betOn === 'p1' ? o1 : o2;
            var playerName = betOn === 'p1' ? p1 : p2;
            var opponent = betOn === 'p1' ? p2 : p1;

            // R√©cup√©rer la strat√©gie pour l'affichage
            var cfgStrategyEl = document.getElementById('cfgStakeStrategy');
            var strategy = cfgStrategyEl ? cfgStrategyEl.value : 'flat';
            var stratIcon = strategy === 'flat' ? 'üíµ' : 'üìä';

            // Gain potentiel
            var potentialWin = Math.round((odds - 1) * stake);

            if (previewEl) {
                previewEl.style.display = 'block';
            }
            if (previewTextEl) {
                previewTextEl.innerHTML = '‚úÖ <b>' + playerName + '</b> vs ' + opponent + ' @ <b>' + odds.toFixed(2) + '</b> ‚Ä¢ ' + stratIcon + ' Mise: <b>' + stake + '‚Ç¨</b> ‚Üí Gain potentiel: <b style="color:var(--green)">+' + potentialWin + '‚Ç¨</b>';
            }
            btnEl.disabled = false;
            console.log('[Tracker] Preview updated, button enabled');
        }

        // Ancienne fonction gard√©e pour compatibilit√© (redirige vers la nouvelle)
        function updateMatchCheck() {
            updateBetPreview();
        }

        function addMatch() {
            console.log('[Tracker] addMatch called');

            var circuit = document.getElementById('addCircuit').value;
            var val = document.getElementById('addTournament').value;
            if (!val) {
                console.log('[Tracker] No tournament selected');
                return;
            }

            var parts = val.split('|');
            var tournament = parts[0], cat = parts[1], surf = parts[2];
            var round = document.getElementById('addRound').value;
            var p1 = document.getElementById('addPlayer1').value.trim();
            var p2 = document.getElementById('addPlayer2').value.trim();
            var o1 = parseFloat(document.getElementById('addOdds1').value);
            var o2 = parseFloat(document.getElementById('addOdds2').value);
            var betOn = document.getElementById('addBetOn').value;

            console.log('[Tracker] Values:', { circuit, tournament, round, p1, p2, o1, o2, betOn });

            if (!p1 || !p2 || !betOn) {
                console.log('[Tracker] Missing required fields');
                return;
            }

            // Calculer la mise avec la strat√©gie Config
            var stake = calcUniversalStake();
            var odds = betOn === 'p1' ? o1 : o2;
            var playerName = betOn === 'p1' ? p1 : p2;
            var opponent = betOn === 'p1' ? p2 : p1;

            console.log('[Tracker] Creating bet:', { playerName, opponent, odds, stake });

            state.pending.push({
                id: Date.now(),
                circuit,
                date: new Date().toISOString().split('T')[0],
                tournament, round, category: cat, surface: surf,
                betOn: playerName,
                vs: opponent,
                odds: odds,
                stake: stake,
                strategy: document.getElementById('cfgStakeStrategy')?.value || 'flat',
                bankrollAtBet: state.bankroll
            });

            console.log('[Tracker] Bet added, saving state...');
            saveState();

            // Reset le formulaire
            document.getElementById('addPlayer1').value = '';
            document.getElementById('addPlayer2').value = '';
            document.getElementById('addOdds1').value = '';
            document.getElementById('addOdds2').value = '';
            document.getElementById('addBetOn').value = '';
            updateBetPreview();

            // Mettre √† jour l'info de strat√©gie (la BR peut avoir chang√© pour les prochains paris)
            updateTrackerStratInfo();

            console.log('[Tracker] addMatch completed');
        }

        function resolveBet(id, won) {
            const bet = state.pending.find(b => b.id === id);
            if (!bet) return;

            const pnl = won ? (bet.odds - 1) * bet.stake : -bet.stake;
            state.bankroll += pnl;

            state.history.unshift({ ...bet, won, pnl, resolvedDate: new Date().toISOString().split('T')[0] });
            state.pending = state.pending.filter(b => b.id !== id);
            saveState();
            
            // Mettre √† jour l'info de strat√©gie (la BR a chang√©)
            updateTrackerStratInfo();
        }

        function deleteBet(id) {
            state.pending = state.pending.filter(b => b.id !== id);
            saveState();
        }
        
        function deleteHistoryBet(id) {
            const bet = state.history.find(b => b.id === id);
            if (!bet) return;
            
            // Annuler l'impact sur la bankroll
            state.bankroll -= bet.pnl;
            
            // Supprimer de l'historique
            state.history = state.history.filter(b => b.id !== id);
            saveState();
            renderTrackerUI();
        }
        
        function isNicheStillActive(nicheId, circuit) {
            if (!nicheId) return true; // Si pas d'ID, on consid√®re active par d√©faut
            var niches = circuit === 'atp' ? NICHES_ATP : NICHES_WTA;
            for (var i = 0; i < niches.length; i++) {
                if (niches[i].id === nicheId) {
                    return niches[i].on;
                }
            }
            return false; // Niche non trouv√©e = consid√©r√©e comme d√©sactiv√©e
        }

        function renderTrackerUI() {
            // Summary stats
            const atpHistory = state.history.filter(b => b.circuit === 'atp');
            const wtaHistory = state.history.filter(b => b.circuit === 'wta');
            const atpProfit = atpHistory.reduce((s, b) => s + b.pnl, 0);
            const wtaProfit = wtaHistory.reduce((s, b) => s + b.pnl, 0);
            const totalProfit = atpProfit + wtaProfit;

            safeText('atpBets', atpHistory.length);
            safeText('atpProfit', (atpProfit >= 0 ? '+' : '') + atpProfit.toFixed(0) + '‚Ç¨');
            document.getElementById('atpProfit').className = 'val ' + (atpProfit >= 0 ? 'pos' : 'neg');
            safeText('wtaBets', wtaHistory.length);
            safeText('wtaProfit', (wtaProfit >= 0 ? '+' : '') + wtaProfit.toFixed(0) + '‚Ç¨');
            document.getElementById('wtaProfit').className = 'val ' + (wtaProfit >= 0 ? 'pos' : 'neg');
            safeText('totalBets', state.history.length);
            safeText('totalProfit', (totalProfit >= 0 ? '+' : '') + totalProfit.toFixed(0) + '‚Ç¨');
            document.getElementById('totalProfit').className = 'val ' + (totalProfit >= 0 ? 'pos' : 'neg');

            // Calcul du Drawdown en temps r√©el
            const drawdownData = calculateDrawdown(state.history, state.initialBankroll);
            safeText('tDrawdown', drawdownData.currentDD.toFixed(0) + '‚Ç¨');
            document.getElementById('tDrawdown').className = 'val neg';
            
            // Alerte si drawdown > 70% du max historique backtest (environ 18 unit√©s)
            const maxDDThreshold = state.stake * 18; // Max DD historique ~18 unit√©s
            const warningThreshold = maxDDThreshold * 0.7;
            const dangerThreshold = maxDDThreshold * 0.9;
            
            const alertEl = document.getElementById('drawdownAlert');
            if (drawdownData.currentDD >= warningThreshold) {
                alertEl.style.display = 'flex';
                const pct = (drawdownData.currentDD / maxDDThreshold * 100).toFixed(0);
                safeText('drawdownAlertValue', `${drawdownData.currentDD.toFixed(0)}‚Ç¨ (${pct}% du max)`);
                if (drawdownData.currentDD >= dangerThreshold) {
                    alertEl.style.borderColor = 'var(--red)';
                    alertEl.style.background = 'rgba(239,68,68,.2)';
                } else {
                    alertEl.style.borderColor = 'var(--yellow)';
                    alertEl.style.background = 'rgba(234,179,8,.2)';
                }
            } else {
                alertEl.style.display = 'none';
            }

            // Filter by circuit
            let filteredPending = state.pending;
            let filteredHistory = state.history;
            if (trackerCircuit !== 'all') {
                filteredPending = state.pending.filter(b => b.circuit === trackerCircuit);
                filteredHistory = state.history.filter(b => b.circuit === trackerCircuit);
            }

            // Stats
            const wins = filteredHistory.filter(b => b.won).length;
            const profit = filteredHistory.reduce((s, b) => s + b.pnl, 0);
            const totalStaked = filteredHistory.reduce((s, b) => s + b.stake, 0);
            const roi = totalStaked > 0 ? (profit / totalStaked * 100) : 0;
            const wr = filteredHistory.length > 0 ? (wins / filteredHistory.length * 100) : 0;

            safeText('tBankroll', state.bankroll.toFixed(0) + '‚Ç¨');
            safeText('tPnl', (profit >= 0 ? '+' : '') + profit.toFixed(0) + '‚Ç¨');
            document.getElementById('tPnl').className = 'val ' + (profit >= 0 ? 'pos' : 'neg');
            safeText('tWinrate', wr.toFixed(0) + '%');
            safeText('tRoi', (roi >= 0 ? '+' : '') + roi.toFixed(0) + '%');
            document.getElementById('tRoi').className = 'val ' + (roi >= 0 ? 'pos' : 'neg');
            safeText('tPending', filteredPending.length);

            // Pending
            if (filteredPending.length === 0) {
                safeHTML('pendingBets', '<div class="no-data">Aucun pari en cours</div>');
            } else {
                document.getElementById('pendingBets').innerHTML = filteredPending.map(b => {
                    var stratIcon = b.strategy === 'pct' ? 'üìä' : 'üíµ';
                    var potentialWin = Math.round((b.odds - 1) * b.stake);
                    return `
                    <div class="bet-card pending ${b.circuit}">
                        <div class="bet-header">
                            <span class="bet-player"><span class="bet-circuit ${b.circuit}">${b.circuit.toUpperCase()}</span> ${b.betOn}</span>
                            <span class="bet-odds">@${b.odds.toFixed(2)}</span>
                        </div>
                        <div class="bet-details">vs ${b.vs} ‚Ä¢ ${b.tournament} ‚Ä¢ ${b.round}</div>
                        <div style="font-size:.75rem;color:var(--muted);margin:.25rem 0">${stratIcon} ${b.stake}‚Ç¨ ‚Üí <span style="color:var(--green)">+${potentialWin}‚Ç¨</span></div>
                        <div class="bet-actions">
                            <button class="btn-sm btn-green" onclick="resolveBet(${b.id}, true)">‚úÖ Gagn√©</button>
                            <button class="btn-sm btn-red" onclick="resolveBet(${b.id}, false)">‚ùå Perdu</button>
                            <button class="btn-sm btn-secondary" onclick="deleteBet(${b.id})">üóëÔ∏è</button>
                        </div>
                    </div>
                `}).join('');
            }

            // History
            if (filteredHistory.length === 0) {
                safeHTML('historyBets', '<div class="no-data">Aucun historique</div>');
            } else {
                document.getElementById('historyBets').innerHTML = filteredHistory.slice(0, 30).map(b => {
                    var stratIcon = b.strategy === 'pct' ? 'üìä' : 'üíµ';
                    return `
                    <div class="bet-card ${b.won ? 'won' : 'lost'} ${b.circuit}">
                        <div class="bet-header">
                            <span class="bet-player"><span class="bet-circuit ${b.circuit}">${b.circuit.toUpperCase()}</span> ${b.betOn} ${b.won ? '‚úì' : '‚úó'}</span>
                            <span class="bet-pnl ${b.pnl >= 0 ? 'pos' : 'neg'}">${b.pnl >= 0 ? '+' : ''}${b.pnl.toFixed(0)}‚Ç¨</span>
                        </div>
                        <div class="bet-details">vs ${b.vs} ‚Ä¢ ${b.tournament} ‚Ä¢ ${b.round} ‚Ä¢ @${b.odds.toFixed(2)} ‚Ä¢ ${stratIcon} ${b.stake}‚Ç¨</div>
                        <div style="display:flex;justify-content:flex-end;margin-top:.25rem">
                            <button class="btn-sm btn-secondary" onclick="deleteHistoryBet(${b.id})" style="padding:2px 6px;font-size:.65rem">üóëÔ∏è</button>
                        </div>
                    </div>
                `}).join('');
            }

            safeText('headerBankroll', state.bankroll.toFixed(0) + '‚Ç¨');
        }

        // ==================== BACKTEST ====================
        function setBacktestCircuit(c) {
            // Update tabs
            document.querySelectorAll('#main-backtest .circuit-tab').forEach(t => t.classList.remove('active'));
            event.target.classList.add('active');
            
            if (c === 'compare') {
                // Vue comparaison
                safeDisplay('singleCircuitView', false);
                safeDisplay('compareView', true);
                updateDataStatus();
            } else {
                // Vue single circuit
                btCircuit = c;
                safeDisplay('singleCircuitView', true);
                safeDisplay('compareView', false);
                safeText('btCircuitLabel', c.toUpperCase());
                
                // Charger les donn√©es du circuit si d√©j√† charg√©es
                if (c === 'atp' && btDataATP.length > 0) {
                    btData = btDataATP;
                    document.getElementById('upload').className = 'upload loaded';
                    safeHTML('upload', '‚úÖ ' + btDataATP.length.toLocaleString() + ' matchs ATP');
                    safeHTML('debug', 'Charg√©: ' + btDataATP.length + ' matchs (ATP)');
                } else if (c === 'wta' && btDataWTA.length > 0) {
                    btData = btDataWTA;
                    document.getElementById('upload').className = 'upload loaded';
                    safeHTML('upload', '‚úÖ ' + btDataWTA.length.toLocaleString() + ' matchs WTA');
                    safeHTML('debug', 'Charg√©: ' + btDataWTA.length + ' matchs (WTA)');
                } else {
                    btData = [];
                    document.getElementById('upload').className = 'upload';
                    safeHTML('upload', `üìÅ Charger ${c.toUpperCase()} CSV`);
                    safeHTML('debug', '');
                }
                
                btResults = [];
                renderNiches();
                
                if (btData.length > 0) {
                    runBacktest();
                }
            }
        }
        
        function updateDataStatus() {
            var statusEl = document.getElementById('dataStatusCompare');
            if (!statusEl) return;
            
            var atpOk = btDataATP.length > 0;
            var wtaOk = btDataWTA.length > 0;
            
            var html = '<div style="display:flex;gap:1rem;justify-content:center">';
            html += '<span style="color:' + (atpOk ? 'var(--green)' : 'var(--muted)') + '">' + (atpOk ? '‚úÖ' : '‚è≥') + ' ATP: ' + (atpOk ? btDataATP.length.toLocaleString() + ' matchs' : 'Non charg√©') + '</span>';
            html += '<span style="color:' + (wtaOk ? 'var(--green)' : 'var(--muted)') + '">' + (wtaOk ? '‚úÖ' : '‚è≥') + ' WTA: ' + (wtaOk ? btDataWTA.length.toLocaleString() + ' matchs' : 'Non charg√©') + '</span>';
            html += '</div>';
            
            if (atpOk && wtaOk) {
                html += '<div style="text-align:center;margin-top:.5rem;color:var(--green);font-weight:600">‚úÖ Donn√©es pr√™tes ! Cliquez sur Lancer Comparaison</div>';
            } else if (atpOk || wtaOk) {
                html += '<div style="text-align:center;margin-top:.5rem;color:var(--yellow)">‚ö†Ô∏è Chargez ' + (!atpOk ? 'ATP' : 'WTA') + ' pour comparer</div>';
            }
            
            statusEl.innerHTML = html;
            
            // Update upload buttons if already loaded
            if (atpOk) {
                safeHTML('uploadATP', '‚úÖ ' + btDataATP.length.toLocaleString() + ' matchs ATP');
                document.getElementById('uploadATP').className = 'upload loaded';
            }
            if (wtaOk) {
                safeHTML('uploadWTA', '‚úÖ ' + btDataWTA.length.toLocaleString() + ' matchs WTA');
                document.getElementById('uploadWTA').className = 'upload loaded';
            }
            
            // Mettre √† jour le Moniteur YTD
            if (typeof updateYTDMonitor === 'function') {
                updateYTDMonitor();
            }
        }

        function renderNiches() {
            const niches = btCircuit === 'atp' ? NICHES_ATP : NICHES_WTA;
            document.getElementById('niches').innerHTML = niches.map(n => {
                const tag = n.confirmed === false ? '<span class="tag watch">‚ö°</span>' : (n.confirmed ? '<span class="tag confirmed">‚úì</span>' : '');
                return `<div class="niche ${n.on ? 'active' : ''} ${n.confirmed === false ? 'warning' : ''}" onclick="toggleNiche('${n.id}')">
                    <span>${n.on ? '‚úì ' : ''}${n.name}${tag}</span>
                    <span class="roi" id="roi-${n.id}">-</span>
                </div>`;
            }).join('');
        }

        function toggleNiche(id) {
            const niches = btCircuit === 'atp' ? NICHES_ATP : NICHES_WTA;
            const n = niches.find(x => x.id === id);
            if (n) { 
                n.on = !n.on; 
                renderNiches(); 
                saveNiches();
                if (typeof updateProjectionDisplay === 'function') updateProjectionDisplay();
            }
        }

        function toggleAllNiches(on) {
            const niches = btCircuit === 'atp' ? NICHES_ATP : NICHES_WTA;
            niches.forEach(n => n.on = on);
            renderNiches();
            saveNiches();
            if (typeof updateProjectionDisplay === 'function') updateProjectionDisplay();
        }

        function setYears(n) {
            const now = new Date().getFullYear();
            document.getElementById('yearFrom').value = n === 0 ? 2007 : now - n;
            document.getElementById('yearTo').value = now;
        }

        document.getElementById('file').onchange = function(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = ev => parseCSV(ev.target.result);
            reader.readAsText(file);
            // Reset input pour permettre de recharger le m√™me fichier
            e.target.value = '';
        };

        // Liste des tournois qui sont des WTA 1000 (ou √©quivalent historique)
        // Ces tournois √©taient incorrectement class√©s en WTA 500 entre 2009-2019
        var WTA_1000_TOURNAMENTS = [
            'BNP Paribas Open', 'Pacific Life Open', 'Indian Wells',  // Indian Wells
            'Miami Open', 'Sony Ericsson Open',  // Miami
            'Mutua Madrid Open', 'Madrid', 'Qatar Telecom German Open',  // Madrid
            'Internazionali BNL d\'Italia', 'Rome', 'Italian Open',  // Rome
            'Canadian Open', 'Rogers Cup', 'Toronto', 'Montreal',  // Canada
            'Western & Southern', 'Cincinnati',  // Cincinnati
            'China Open', 'Beijing',  // Beijing
            'Wuhan Open', 'Wuhan',  // Wuhan
            'Qatar Open', 'Qatar Total Open', 'Doha',  // Qatar
            'Dubai Duty Free', 'Dubai',  // Dubai
            'Guadalajara Open',  // Guadalajara
            'Acura Classic', 'Family Circle Cup', 'Kremlin Cup', 
            'Toray Pan Pacific', 'Zurich Open'  // Anciens Tier 1
        ];
        
        // Fonction pour normaliser les cat√©gories WTA
        function normalizeWTACategory(category, tournament, year) {
            // D√©j√† bien class√©
            if (category === 'WTA 1000') return 'WTA 1000';
            if (category === 'Grand Slam') return 'Grand Slam';
            if (category === 'Tour Championships') return 'Tour Championships';
            
            // Tier 1 = WTA 1000
            if (category === 'Tier 1') return 'WTA 1000';
            
            // Tier 2 = WTA 500 (certains sont devenus WTA 1000, v√©rifier le nom)
            if (category === 'Tier 2') {
                for (var i = 0; i < WTA_1000_TOURNAMENTS.length; i++) {
                    if (tournament.indexOf(WTA_1000_TOURNAMENTS[i]) >= 0) {
                        return 'WTA 1000';
                    }
                }
                return 'WTA 500';
            }
            
            // WTA 500 mal class√©s entre 2009-2019
            if (category === 'WTA 500' && year >= 2009 && year <= 2020) {
                for (var i = 0; i < WTA_1000_TOURNAMENTS.length; i++) {
                    if (tournament.indexOf(WTA_1000_TOURNAMENTS[i]) >= 0) {
                        return 'WTA 1000';
                    }
                }
            }
            
            // Tier 3, Tier 4 = WTA 250
            if (category === 'Tier 3' || category === 'Tier 4') return 'WTA 250';
            
            // Par d√©faut, garder tel quel
            return category;
        }

        function parseCSV(text) {
            const debug = document.getElementById('debug');
            debug.innerHTML = 'Parsing...';
            try {
                const lines = text.replace(/\r\n/g, '\n').trim().split('\n');
                const headers = lines[0].split(',').map(h => h.trim().toLowerCase());

                const data = [];
                for (let i = 1; i < lines.length; i++) {
                    const vals = lines[i].split(',');
                    const row = {};
                    headers.forEach((h, j) => row[h] = (vals[j] || '').trim());

                    const o1 = parseFloat(row.odds_player1) || 0;
                    const o2 = parseFloat(row.odds_player2) || 0;
                    if (o1 < 1.01 || o2 < 1.01) continue;

                    let cat = row.category || '';
                    let tournament = row.tournament || '';
                    let year = parseInt(row.year) || 0;
                    
                    // Normalisation des cat√©gories WTA
                    if (btCircuit === 'wta') {
                        cat = normalizeWTACategory(cat, tournament, year);
                    }

                    data.push({
                        date: row.date, year: year,
                        tournament: tournament, category: cat,
                        surface: row.surface, round: row.round,
                        p1: row.player1, p2: row.player2, o1, o2,
                        score: row.score || ''
                    });
                }

                // Stocker dans la bonne variable selon le circuit actuel
                if (btCircuit === 'atp') {
                    btDataATP = data;
                } else {
                    btDataWTA = data;
                }
                btData = data;

                debug.innerHTML = 'Charg√©: ' + data.length + ' matchs (' + btCircuit.toUpperCase() + ')';
                document.getElementById('upload').className = 'upload loaded';
                safeHTML('upload', '‚úÖ ' + data.length.toLocaleString() + ' matchs ' + btCircuit.toUpperCase());
                runBacktest();
                
                // Update status for compare view, lab, projections and calendar
                updateDataStatus();
                checkLabData();
                if (typeof updateProjections === 'function') updateProjections();
                if (typeof renderCalendar === 'function') renderCalendar();
                if (typeof checkWeekTournaments === 'function') checkWeekTournaments();
                if (typeof updateStakeRecommendations === 'function') updateStakeRecommendations();
                if (typeof updateProjectionDisplay === 'function') updateProjectionDisplay();
            } catch (err) {
                debug.innerHTML = 'Erreur: ' + err.message;
            }
        }

        function runBacktest() {
            if (btData.length === 0) return;

            const y1 = parseInt(document.getElementById('yearFrom').value) || 2007;
            const y2 = parseInt(document.getElementById('yearTo').value) || 2025;
            const niches = (btCircuit === 'atp' ? NICHES_ATP : NICHES_WTA).filter(n => n.on);

            if (niches.length === 0) { alert('Active au moins une niche'); return; }

            const filtered = btData.filter(m => m.year >= y1 && m.year <= y2);
            btResults = [];
            const seen = new Set();
            const nicheStats = {};
            niches.forEach(n => nicheStats[n.id] = { bets: 0, wins: 0, profit: 0 });

            for (const m of filtered) {
                const key = m.date + m.p1 + m.p2;
                if (seen.has(key)) continue;

                for (const n of niches) {
                    if (m.category !== n.cat || m.surface !== n.surf || !n.rounds.includes(m.round)) continue;

                    const dogOdds = Math.max(m.o1, m.o2);
                    const favOdds = Math.min(m.o1, m.o2);
                    const dogIsP1 = m.o1 > m.o2;

                    let odds, won, betOn, vs;
                    if (n.strat === 'underdog') {
                        odds = dogOdds; won = dogIsP1;
                        betOn = dogIsP1 ? m.p1 : m.p2;
                        vs = dogIsP1 ? m.p2 : m.p1;
                    } else {
                        odds = favOdds; won = !dogIsP1;
                        betOn = dogIsP1 ? m.p2 : m.p1;
                        vs = dogIsP1 ? m.p1 : m.p2;
                    }

                    if (odds >= n.min && odds <= n.max) {
                        const pnl = won ? odds - 1 : -1;
                        btResults.push({ date: m.date, year: m.year, tournament: m.tournament, round: m.round, betOn, vs, odds, won, pnl, niche: n.name });
                        nicheStats[n.id].bets++; if (won) nicheStats[n.id].wins++; nicheStats[n.id].profit += pnl;
                        seen.add(key); break;
                    }
                }
            }

            niches.forEach(n => {
                const s = nicheStats[n.id];
                const roi = s.bets > 0 ? (s.profit / s.bets * 100) : 0;
                const el = document.getElementById('roi-' + n.id);
                if (el) { el.textContent = s.bets > 0 ? (roi >= 0 ? '+' : '') + roi.toFixed(0) + '%' : '-'; el.className = 'roi ' + (roi < 0 ? 'neg' : ''); }
            });

            renderBacktest();
        }

        function renderBacktest() {
            btResults.sort((a, b) => a.date.localeCompare(b.date));
            const wins = btResults.filter(r => r.won).length;
            const profit = btResults.reduce((s, r) => s + r.pnl, 0);
            const roi = btResults.length > 0 ? profit / btResults.length * 100 : 0;
            const wr = btResults.length > 0 ? wins / btResults.length * 100 : 0;

            // Calcul profit cumul√© ET drawdown dynamique
            let peak = 0, maxDD = 0, cum = 0;
            let maxDDIndex = 0;
            const hist = [0];
            const ddHist = [0]; // Drawdown history
            btResults.forEach((r, i) => { 
                cum += r.pnl; 
                hist.push(cum); 
                if (cum > peak) peak = cum; 
                const dd = peak - cum;
                ddHist.push(-dd); // N√©gatif pour afficher en dessous de 0
                if (dd > maxDD) {
                    maxDD = dd;
                    maxDDIndex = i + 1; // +1 car hist commence √† 0
                }
            });

            const stake = state.stake;
            const maxDDEuros = maxDD * stake;

            document.getElementById('btStats').innerHTML = `
                <div class="stat"><div class="val">${state.stake}‚Ç¨</div><div class="lbl">Mise</div></div>
                <div class="stat"><div class="val">${btResults.length}</div><div class="lbl">Paris</div></div>
                <div class="stat"><div class="val">${wins}</div><div class="lbl">Wins</div></div>
                <div class="stat"><div class="val">${wr.toFixed(0)}%</div><div class="lbl">Winrate</div></div>
                <div class="stat"><div class="val ${profit >= 0 ? 'pos' : 'neg'}">${profit >= 0 ? '+' : ''}${(profit * stake).toFixed(0)}‚Ç¨</div><div class="lbl">Profit</div></div>
                <div class="stat"><div class="val ${roi >= 0 ? 'pos' : 'neg'}">${roi >= 0 ? '+' : ''}${roi.toFixed(1)}%</div><div class="lbl">ROI</div></div>
                <div class="stat"><div class="val neg">-${maxDDEuros.toFixed(0)}‚Ç¨</div><div class="lbl">Max DD</div></div>`;

            const ctx = document.getElementById('chart').getContext('2d');
            if (btChart) btChart.destroy();
            const color = btCircuit === 'atp' ? '#22c55e' : '#ec4899';
            
            // Donn√©es pour le point de max DD
            const maxDDPoint = new Array(hist.length).fill(null);
            maxDDPoint[maxDDIndex] = ddHist[maxDDIndex] * stake;
            
            // Graphique avec 2 courbes : Profit + Drawdown + Point Max DD
            btChart = new Chart(ctx, { 
                type: 'line', 
                data: { 
                    labels: hist.map((_, i) => i), 
                    datasets: [
                        { 
                            label: 'Profit',
                            data: hist.map(v => v * stake), 
                            borderColor: color, 
                            backgroundColor: color + '20', 
                            fill: true, 
                            tension: 0.3, 
                            pointRadius: 0,
                            order: 2
                        },
                        { 
                            label: 'Drawdown',
                            data: ddHist.map(v => v * stake), 
                            borderColor: '#ef4444', 
                            backgroundColor: 'rgba(239,68,68,.15)', 
                            fill: true, 
                            tension: 0.3, 
                            pointRadius: 0,
                            borderDash: [5, 5],
                            order: 3
                        },
                        { 
                            label: 'Max DD: -' + maxDDEuros.toFixed(0) + '‚Ç¨',
                            data: maxDDPoint, 
                            borderColor: '#fbbf24', 
                            backgroundColor: '#fbbf24', 
                            pointRadius: 8,
                            pointStyle: 'triangle',
                            rotation: 180,
                            showLine: false,
                            order: 1
                        }
                    ] 
                }, 
                options: { 
                    responsive: true, 
                    maintainAspectRatio: false, 
                    plugins: { 
                        legend: { 
                            display: true, 
                            position: 'top',
                            labels: { color: '#999', font: { size: 10 }, boxWidth: 12 }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    if (context.dataset.label.startsWith('Max DD')) {
                                        return 'Max Drawdown: -' + maxDDEuros.toFixed(0) + '‚Ç¨';
                                    }
                                    return context.dataset.label + ': ' + context.parsed.y.toFixed(0) + '‚Ç¨';
                                }
                            }
                        }
                    }, 
                    scales: { 
                        x: { display: false }, 
                        y: { 
                            grid: { color: 'rgba(255,255,255,.05)' }, 
                            ticks: { color: '#666', font: { size: 9 }, callback: v => v + '‚Ç¨' } 
                        } 
                    } 
                } 
            });

            const ys = {};
            btResults.forEach(r => { if (!ys[r.year]) ys[r.year] = { b: 0, w: 0, p: 0 }; ys[r.year].b++; if (r.won) ys[r.year].w++; ys[r.year].p += r.pnl; });
            document.getElementById('years').innerHTML = Object.keys(ys).sort().map(y => { 
                const s = ys[y]; 
                const r = s.p / s.b * 100; 
                const pEuros = s.p * state.stake;
                const isSelected = selectedYear === parseInt(y);
                return `<div class="year ${s.p >= 0 ? 'pos' : 'neg'}" style="cursor:pointer;${isSelected ? 'outline:2px solid var(--blue)' : ''}" onclick="filterByYear(${y})"><b>${y}</b><span>${s.b}p</span><div style="font-family:monospace" class="${pEuros >= 0 ? 'pos' : 'neg'}">${pEuros >= 0 ? '+' : ''}${pEuros.toFixed(0)}‚Ç¨</div></div>`; 
            }).join('');

            // Filtrer par ann√©e si s√©lectionn√©e
            const displayResults = selectedYear ? btResults.filter(r => r.year === selectedYear) : btResults;
            
            // Afficher TOUT l'historique (pas de limite)
            safeText('matchCount', `(${displayResults.length} matchs${selectedYear ? ' en ' + selectedYear : ''})`);
            document.getElementById('btMatches').innerHTML = displayResults.slice().reverse().map(r => {
                const pnlEuros = r.pnl * stake;
                return `<tr><td class="mono">${r.date}</td><td>${r.tournament}</td><td>${r.round}</td><td class="${r.won ? 'pos' : 'neg'}">${r.betOn}</td><td>${r.vs}</td><td class="mono">${r.odds.toFixed(2)}</td><td>${r.won ? '‚úÖ' : '‚ùå'}</td><td class="mono ${pnlEuros >= 0 ? 'pos' : 'neg'}">${pnlEuros >= 0 ? '+' : ''}${pnlEuros.toFixed(0)}‚Ç¨</td></tr>`;
            }).join('');
        }

        let selectedYear = null;
        function filterByYear(year) {
            selectedYear = selectedYear === year ? null : year;
            renderBacktest();
        }
        function resetYearFilter() {
            selectedYear = null;
            renderBacktest();
        }

        // ==================== COMPARE BACKTEST ====================
        let compareChart = null;
        let cmpResultsATP = [];
        let cmpResultsWTA = [];
        let cmpHistoryFilter = 'all';

        // Handlers pour les fichiers ATP et WTA dans la vue compare
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('fileATP').onchange = function(e) {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = ev => parseCSVForCompare(ev.target.result, 'atp');
                reader.readAsText(file);
                e.target.value = '';
            };
            
            document.getElementById('fileWTA').onchange = function(e) {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = ev => parseCSVForCompare(ev.target.result, 'wta');
                reader.readAsText(file);
                e.target.value = '';
            };
        });

        function parseCSVForCompare(text, circuit) {
            const debug = document.getElementById('debug' + circuit.toUpperCase());
            const upload = document.getElementById('upload' + circuit.toUpperCase());
            debug.innerHTML = 'Parsing...';
            
            try {
                const lines = text.replace(/\r\n/g, '\n').trim().split('\n');
                const headers = lines[0].split(',').map(h => h.trim().toLowerCase());

                const data = [];
                for (let i = 1; i < lines.length; i++) {
                    const vals = lines[i].split(',');
                    const row = {};
                    headers.forEach((h, j) => row[h] = (vals[j] || '').trim());

                    const o1 = parseFloat(row.odds_player1) || 0;
                    const o2 = parseFloat(row.odds_player2) || 0;
                    if (o1 < 1.01 || o2 < 1.01) continue;

                    let cat = row.category || '';
                    let tournament = row.tournament || '';
                    let year = parseInt(row.year) || 0;
                    
                    // Utiliser la fonction de normalisation pour WTA
                    if (circuit === 'wta') {
                        cat = normalizeWTACategory(cat, tournament, year);
                    }

                    data.push({
                        date: row.date, year: year,
                        tournament: tournament, category: cat,
                        surface: row.surface, round: row.round,
                        p1: row.player1, p2: row.player2, o1, o2,
                        score: row.score || ''
                    });
                }

                if (circuit === 'atp') {
                    btDataATP = data;
                } else {
                    btDataWTA = data;
                }

                debug.innerHTML = '‚úÖ ' + data.length + ' matchs';
                upload.className = 'upload loaded';
                upload.innerHTML = (circuit === 'atp' ? 'üü¢' : 'ü©∑') + ' ' + data.length.toLocaleString() + ' matchs';
                
                // Update status everywhere
                updateDataStatus();
                checkLabData();
                if (typeof updateProjections === 'function') updateProjections();
                if (typeof renderCalendar === 'function') renderCalendar();
                if (typeof checkWeekTournaments === 'function') checkWeekTournaments();
                if (typeof updateStakeRecommendations === 'function') updateStakeRecommendations();
                if (typeof updateProjectionDisplay === 'function') updateProjectionDisplay();
            } catch (err) {
                debug.innerHTML = '‚ùå Erreur: ' + err.message;
            }
        }
        
        // Fonction loadCSV pour le nouveau chargement dans le Labo
        function loadCSV(circuit) {
            var inputId = circuit === 'atp' ? 'csvATP' : 'csvWTA';
            var statusId = circuit === 'atp' ? 'csvATPStatus' : 'csvWTAStatus';
            var input = document.getElementById(inputId);
            var statusEl = document.getElementById(statusId);
            
            if (!input || !input.files || !input.files[0]) {
                if (statusEl) statusEl.innerHTML = '<span style="color:var(--red)">‚ùå Aucun fichier</span>';
                return;
            }
            
            var file = input.files[0];
            if (statusEl) statusEl.innerHTML = '<span style="color:var(--yellow)">‚è≥ Chargement...</span>';
            
            var reader = new FileReader();
            reader.onload = function(ev) {
                try {
                    var text = ev.target.result;
                    var lines = text.replace(/\r\n/g, '\n').trim().split('\n');
                    var headers = lines[0].split(',').map(function(h) { return h.trim().toLowerCase(); });
                    
                    var data = [];
                    for (var i = 1; i < lines.length; i++) {
                        var vals = lines[i].split(',');
                        var row = {};
                        headers.forEach(function(h, j) { row[h] = (vals[j] || '').trim(); });
                        
                        var o1 = parseFloat(row.odds_player1) || parseFloat(row.b365w) || parseFloat(row.psw) || 0;
                        var o2 = parseFloat(row.odds_player2) || parseFloat(row.b365l) || parseFloat(row.psl) || 0;
                        if (o1 < 1.01 || o2 < 1.01) continue;
                        
                        var dateStr = row.date || '';
                        var year = parseInt(row.year) || (dateStr ? parseInt(dateStr.substring(0, 4)) : 0);
                        
                        var cat = row.category || row.series || '';
                        var tournament = row.tournament || row.name || '';
                        
                        // Utiliser la fonction de normalisation pour WTA
                        if (circuit === 'wta') {
                            cat = normalizeWTACategory(cat, tournament, year);
                        } else {
                            if (cat.includes('Masters 1000') || cat === 'Masters') cat = 'Masters 1000';
                            else if (cat.includes('500') || cat === 'ATP500') cat = 'ATP 500';
                            else if (cat.includes('250') || cat === 'ATP250') cat = 'ATP 250';
                            else if (cat.includes('Grand Slam')) cat = 'Grand Slam';
                        }
                        
                        data.push({
                            date: dateStr,
                            year: year,
                            tournament: row.tournament || row.location || '',
                            category: cat || row.category || row.series || '',
                            surface: row.surface || '',
                            round: row.round || '',
                            p1: row.player1 || row.winner || '',
                            p2: row.player2 || row.loser || '',
                            o1: o1,
                            o2: o2,
                            score: row.score || ''
                        });
                    }
                    
                    if (circuit === 'atp') {
                        btDataATP = data;
                    } else {
                        btDataWTA = data;
                    }
                    
                    var icon = circuit === 'atp' ? 'üü¢' : 'ü©∑';
                    if (statusEl) statusEl.innerHTML = '<span style="color:var(--green)">' + icon + ' ' + data.length.toLocaleString() + ' matchs charg√©s</span>';
                    
                    // Update all relevant components
                    updateDataStatus();
                    checkLabData();
                    if (typeof updateSimNicheCheckboxes === 'function') updateSimNicheCheckboxes();
                    if (typeof updateSimStats === 'function') updateSimStats();
                    if (typeof checkWeekTournaments === 'function') checkWeekTournaments();
                    if (typeof renderCalendar === 'function') renderCalendar();
                    if (typeof updateStakeRecommendations === 'function') updateStakeRecommendations();
                    if (typeof updateProjectionDisplay === 'function') updateProjectionDisplay();
                    if (typeof initYearSelector === 'function') initYearSelector();
                    
                    console.log(circuit.toUpperCase() + ' charg√©:', data.length, 'matchs');
                    
                } catch (err) {
                    if (statusEl) statusEl.innerHTML = '<span style="color:var(--red)">‚ùå Erreur: ' + err.message + '</span>';
                    console.error('Erreur CSV:', err);
                }
            };
            reader.onerror = function() {
                if (statusEl) statusEl.innerHTML = '<span style="color:var(--red)">‚ùå Erreur lecture fichier</span>';
            };
            reader.readAsText(file);
        }

        function runCompareBacktest() {
            if (btDataATP.length === 0 && btDataWTA.length === 0) {
                alert('Charge au moins un fichier (ATP ou WTA)');
                return;
            }

            const y1 = parseInt(document.getElementById('cmpYearFrom').value) || 2007;
            const y2 = parseInt(document.getElementById('cmpYearTo').value) || 2025;
            const stake = state.stake;

            // Process ATP
            cmpResultsATP = processBacktestForCircuit(btDataATP, NICHES_ATP, y1, y2, 'atp');
            
            // Process WTA
            cmpResultsWTA = processBacktestForCircuit(btDataWTA, NICHES_WTA, y1, y2, 'wta');

            // Calculate stats
            const atpWins = cmpResultsATP.filter(r => r.won).length;
            const atpProfit = cmpResultsATP.reduce((s, r) => s + r.pnl, 0);
            const atpRoi = cmpResultsATP.length > 0 ? (atpProfit / cmpResultsATP.length * 100) : 0;
            const atpWinrate = cmpResultsATP.length > 0 ? (atpWins / cmpResultsATP.length * 100) : 0;

            const wtaWins = cmpResultsWTA.filter(r => r.won).length;
            const wtaProfit = cmpResultsWTA.reduce((s, r) => s + r.pnl, 0);
            const wtaRoi = cmpResultsWTA.length > 0 ? (wtaProfit / cmpResultsWTA.length * 100) : 0;
            const wtaWinrate = cmpResultsWTA.length > 0 ? (wtaWins / cmpResultsWTA.length * 100) : 0;

            const totalBets = cmpResultsATP.length + cmpResultsWTA.length;
            const totalWins = atpWins + wtaWins;
            const totalProfit = atpProfit + wtaProfit;
            const totalRoi = totalBets > 0 ? (totalProfit / totalBets * 100) : 0;
            const totalWinrate = totalBets > 0 ? (totalWins / totalBets * 100) : 0;

            // Update stats display
            safeText('cmpAtpBets', cmpResultsATP.length);
            safeText('cmpAtpWinrate', atpWinrate.toFixed(0) + '%');
            safeText('cmpAtpProfit', (atpProfit * stake >= 0 ? '+' : '') + (atpProfit * stake).toFixed(0) + '‚Ç¨');
            document.getElementById('cmpAtpProfit').className = 'val ' + (atpProfit >= 0 ? 'pos' : 'neg');
            safeText('cmpAtpRoi', (atpRoi >= 0 ? '+' : '') + atpRoi.toFixed(1) + '%');
            
            // Max DD ATP
            const sortedATP = [...cmpResultsATP].sort((a, b) => a.date.localeCompare(b.date));
            let atpCum = 0, atpPeak = 0, atpMaxDD = 0;
            sortedATP.forEach(r => {
                atpCum += r.pnl * stake;
                if (atpCum > atpPeak) atpPeak = atpCum;
                if (atpPeak - atpCum > atpMaxDD) atpMaxDD = atpPeak - atpCum;
            });
            safeText('cmpAtpMaxDD', '-' + atpMaxDD.toFixed(0) + '‚Ç¨');

            safeText('cmpWtaBets', cmpResultsWTA.length);
            safeText('cmpWtaWinrate', wtaWinrate.toFixed(0) + '%');
            safeText('cmpWtaProfit', (wtaProfit * stake >= 0 ? '+' : '') + (wtaProfit * stake).toFixed(0) + '‚Ç¨');
            document.getElementById('cmpWtaProfit').className = 'val ' + (wtaProfit >= 0 ? 'pos' : 'neg');
            safeText('cmpWtaRoi', (wtaRoi >= 0 ? '+' : '') + wtaRoi.toFixed(1) + '%');
            
            // Max DD WTA
            const sortedWTA = [...cmpResultsWTA].sort((a, b) => a.date.localeCompare(b.date));
            let wtaCum = 0, wtaPeak = 0, wtaMaxDD = 0;
            sortedWTA.forEach(r => {
                wtaCum += r.pnl * stake;
                if (wtaCum > wtaPeak) wtaPeak = wtaCum;
                if (wtaPeak - wtaCum > wtaMaxDD) wtaMaxDD = wtaPeak - wtaCum;
            });
            safeText('cmpWtaMaxDD', '-' + wtaMaxDD.toFixed(0) + '‚Ç¨');

            safeText('cmpTotalBets', totalBets);
            safeText('cmpTotalWinrate', totalWinrate.toFixed(0) + '%');
            safeText('cmpTotalProfit', (totalProfit * stake >= 0 ? '+' : '') + (totalProfit * stake).toFixed(0) + '‚Ç¨');
            document.getElementById('cmpTotalProfit').className = 'val ' + (totalProfit >= 0 ? 'pos' : 'neg');
            safeText('cmpTotalRoi', (totalRoi >= 0 ? '+' : '') + totalRoi.toFixed(1) + '%');
            
            // Calcul Max DD Global
            const allResults = [...cmpResultsATP, ...cmpResultsWTA].sort((a, b) => a.date.localeCompare(b.date));
            let cum = 0, peak = 0, maxDD = 0;
            allResults.forEach(r => {
                cum += r.pnl * stake;
                if (cum > peak) peak = cum;
                if (peak - cum > maxDD) maxDD = peak - cum;
            });
            safeText('cmpTotalMaxDD', '-' + maxDD.toFixed(0) + '‚Ç¨');

            // Build chart data
            renderCompareChart();
            renderCompareYearTable();
            renderCompareHistory();
        }

        function processBacktestForCircuit(data, niches, y1, y2, circuit) {
            const results = [];
            const activeNiches = niches.filter(n => n.on !== false);
            const filtered = data.filter(m => m.year >= y1 && m.year <= y2);
            const seen = new Set();

            for (const m of filtered) {
                const key = m.date + m.p1 + m.p2;
                if (seen.has(key)) continue;

                for (const n of activeNiches) {
                    if (m.category !== n.cat || m.surface !== n.surf || !n.rounds.includes(m.round)) continue;

                    const dogOdds = Math.max(m.o1, m.o2);
                    const favOdds = Math.min(m.o1, m.o2);
                    const dogIsP1 = m.o1 > m.o2;

                    let odds, won, betOn, vs;
                    if (n.strat === 'underdog') {
                        odds = dogOdds; won = dogIsP1;
                        betOn = dogIsP1 ? m.p1 : m.p2;
                        vs = dogIsP1 ? m.p2 : m.p1;
                    } else {
                        odds = favOdds; won = !dogIsP1;
                        betOn = dogIsP1 ? m.p2 : m.p1;
                        vs = dogIsP1 ? m.p1 : m.p2;
                    }

                    if (odds >= n.min && odds <= n.max) {
                        const pnl = won ? odds - 1 : -1;
                        results.push({ 
                            date: m.date, year: m.year, tournament: m.tournament, 
                            round: m.round, betOn, vs, odds, won, pnl, 
                            niche: n.name, circuit 
                        });
                        seen.add(key); 
                        break;
                    }
                }
            }
            return results;
        }

        let globalCombinedChart = null;
        
        function renderCompareChart() {
            const stake = state.stake;
            
            // Merge and sort all results by date
            const allResults = [...cmpResultsATP, ...cmpResultsWTA].sort((a, b) => a.date.localeCompare(b.date));
            
            if (allResults.length === 0) return;
            
            // ========== GRAPHIQUE 1: GLOBAL COMBIN√â avec Drawdown ==========
            let totalCum = 0, peak = 0, maxDD = 0, maxDDIndex = 0;
            const totalHist = [0];
            const ddHist = [0];
            
            allResults.forEach((r, i) => { 
                totalCum += r.pnl * stake; 
                totalHist.push(totalCum);
                if (totalCum > peak) peak = totalCum;
                const dd = peak - totalCum;
                ddHist.push(-dd);
                if (dd > maxDD) {
                    maxDD = dd;
                    maxDDIndex = i + 1;
                }
            });
            
            // Point max DD
            const maxDDPoint = new Array(totalHist.length).fill(null);
            maxDDPoint[maxDDIndex] = ddHist[maxDDIndex];
            
            const ctx1 = document.getElementById('globalCombinedChart').getContext('2d');
            if (globalCombinedChart) globalCombinedChart.destroy();
            
            globalCombinedChart = new Chart(ctx1, {
                type: 'line',
                data: {
                    labels: Array.from({ length: totalHist.length }, (_, i) => i),
                    datasets: [
                        { 
                            label: 'Profit Global', 
                            data: totalHist, 
                            borderColor: '#4d9fff', 
                            backgroundColor: 'rgba(77,159,255,.15)', 
                            fill: true, 
                            tension: 0.3, 
                            pointRadius: 0, 
                            borderWidth: 2.5,
                            order: 2
                        },
                        { 
                            label: 'Drawdown', 
                            data: ddHist, 
                            borderColor: '#ef4444', 
                            backgroundColor: 'rgba(239,68,68,.1)', 
                            fill: true, 
                            tension: 0.3, 
                            pointRadius: 0, 
                            borderDash: [5, 5],
                            borderWidth: 1.5,
                            order: 3
                        },
                        { 
                            label: 'Max DD: -' + maxDD.toFixed(0) + '‚Ç¨',
                            data: maxDDPoint, 
                            borderColor: '#fbbf24', 
                            backgroundColor: '#fbbf24', 
                            pointRadius: 8,
                            pointStyle: 'triangle',
                            rotation: 180,
                            showLine: false,
                            order: 1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { 
                        legend: { 
                            display: true, 
                            position: 'top',
                            labels: { color: '#999', font: { size: 10 }, boxWidth: 12 }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    if (context.dataset.label.startsWith('Max DD')) {
                                        return 'Max Drawdown: -' + maxDD.toFixed(0) + '‚Ç¨';
                                    }
                                    return context.dataset.label + ': ' + context.parsed.y.toFixed(0) + '‚Ç¨';
                                }
                            }
                        }
                    },
                    scales: { 
                        x: { display: false }, 
                        y: { grid: { color: 'rgba(255,255,255,.05)' }, ticks: { color: '#666', callback: v => v + '‚Ç¨' } } 
                    }
                }
            });
            
            // ========== GRAPHIQUE 2: D√âTAIL ATP vs WTA ==========
            let atpCum = 0, wtaCum = 0;
            const atpHist = [0], wtaHist = [0];
            
            const sortedATP = [...cmpResultsATP].sort((a, b) => a.date.localeCompare(b.date));
            const sortedWTA = [...cmpResultsWTA].sort((a, b) => a.date.localeCompare(b.date));
            
            sortedATP.forEach(r => { atpCum += r.pnl * stake; atpHist.push(atpCum); });
            sortedWTA.forEach(r => { wtaCum += r.pnl * stake; wtaHist.push(wtaCum); });

            const ctx2 = document.getElementById('compareChart').getContext('2d');
            if (compareChart) compareChart.destroy();
            
            const maxLen = Math.max(atpHist.length, wtaHist.length);
            
            compareChart = new Chart(ctx2, {
                type: 'line',
                data: {
                    labels: Array.from({ length: maxLen }, (_, i) => i),
                    datasets: [
                        { label: 'ATP', data: atpHist, borderColor: '#22c55e', backgroundColor: 'rgba(34,197,94,.1)', fill: true, tension: 0.3, pointRadius: 0, borderWidth: 2 },
                        { label: 'WTA', data: wtaHist, borderColor: '#ec4899', backgroundColor: 'rgba(236,72,153,.1)', fill: true, tension: 0.3, pointRadius: 0, borderWidth: 2 }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { 
                        legend: { 
                            display: true,
                            position: 'top',
                            labels: { color: '#999', font: { size: 10 }, boxWidth: 12 }
                        } 
                    },
                    scales: { 
                        x: { display: false }, 
                        y: { grid: { color: 'rgba(255,255,255,.05)' }, ticks: { color: '#666', callback: v => v + '‚Ç¨' } } 
                    }
                }
            });
        }

        function renderCompareYearTable() {
            const stake = state.stake;
            const years = {};
            
            cmpResultsATP.forEach(r => {
                if (!years[r.year]) years[r.year] = { atpB: 0, atpP: 0, wtaB: 0, wtaP: 0 };
                years[r.year].atpB++;
                years[r.year].atpP += r.pnl;
            });
            
            cmpResultsWTA.forEach(r => {
                if (!years[r.year]) years[r.year] = { atpB: 0, atpP: 0, wtaB: 0, wtaP: 0 };
                years[r.year].wtaB++;
                years[r.year].wtaP += r.pnl;
            });

            document.getElementById('cmpYearTable').innerHTML = Object.keys(years).sort().map(y => {
                const s = years[y];
                const totalB = s.atpB + s.wtaB;
                const totalP = s.atpP + s.wtaP;
                return `<tr>
                    <td><b>${y}</b></td>
                    <td>${s.atpB}</td>
                    <td class="${s.atpP >= 0 ? 'pos' : 'neg'}">${s.atpP >= 0 ? '+' : ''}${(s.atpP * stake).toFixed(0)}‚Ç¨</td>
                    <td>${s.wtaB}</td>
                    <td class="${s.wtaP >= 0 ? 'pos' : 'neg'}">${s.wtaP >= 0 ? '+' : ''}${(s.wtaP * stake).toFixed(0)}‚Ç¨</td>
                    <td><b>${totalB}</b></td>
                    <td class="${totalP >= 0 ? 'pos' : 'neg'}"><b>${totalP >= 0 ? '+' : ''}${(totalP * stake).toFixed(0)}‚Ç¨</b></td>
                </tr>`;
            }).join('');
        }

        function renderCompareHistory() {
            const stake = state.stake;
            let results = [...cmpResultsATP, ...cmpResultsWTA];
            
            if (cmpHistoryFilter === 'atp') results = cmpResultsATP;
            else if (cmpHistoryFilter === 'wta') results = cmpResultsWTA;
            
            results.sort((a, b) => b.date.localeCompare(a.date));
            
            safeText('cmpMatchCount', `(${results.length} matchs)`);
            document.getElementById('cmpMatches').innerHTML = results.map(r => {
                const pnlEuros = r.pnl * stake;
                const circuitIcon = r.circuit === 'atp' ? 'üü¢' : 'ü©∑';
                return `<tr>
                    <td class="mono">${r.date}</td>
                    <td>${circuitIcon}</td>
                    <td>${r.tournament}</td>
                    <td>${r.round}</td>
                    <td class="${r.won ? 'pos' : 'neg'}">${r.betOn}</td>
                    <td class="mono">${r.odds.toFixed(2)}</td>
                    <td>${r.won ? '‚úÖ' : '‚ùå'}</td>
                    <td class="mono ${pnlEuros >= 0 ? 'pos' : 'neg'}">${pnlEuros >= 0 ? '+' : ''}${pnlEuros.toFixed(0)}‚Ç¨</td>
                </tr>`;
            }).join('');
        }

        function filterCmpHistory(filter) {
            cmpHistoryFilter = filter;
            document.querySelectorAll('#compareView .tabs .tab').forEach(t => t.classList.remove('active'));
            event.target.classList.add('active');
            renderCompareHistory();
        }

        // ==================== CALENDAR ====================
        function setCalendarCircuit(c) {
            calendarCircuit = c;
            document.querySelectorAll('#main-calendar .circuit-tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`#main-calendar .circuit-tab.${c === 'all' ? 'global' : c}`).classList.add('active');
            renderCalendar();
        }

        // ==================== CALENDAR DATA ====================
        const CALENDAR_ATP = [
            { month: 'Janvier', betsMin: 3, betsMax: 6, tournaments: [
                { name: 'Brisbane', niche: 'F @2.0-2.5', dates: '5-11 jan', bets: '0-1' },
                { name: 'Hong Kong', niche: 'F @2.0-2.5', dates: '5-11 jan', bets: '0-1' },
                { name: 'Adelaide', niche: 'F @2.0-2.5', dates: '12-18 jan', bets: '0-1' },
                { name: 'Auckland', niche: 'F @2.0-2.5', dates: '12-18 jan', bets: '0-1' },
                { name: 'AUSTRALIAN OPEN', niche: 'QF @2.0-3.0', dates: '18 jan - 1 f√©v', bets: '1-2', hot: true },
            ]},
            { month: 'F√©vrier', betsMin: 5, betsMax: 11, tournaments: [
                { name: 'Montpellier', niche: 'F @2.0-2.5', dates: '2-8 f√©v', bets: '0-1' },
                { name: 'Dallas', niche: 'F @2.0-2.5', dates: '9-15 f√©v', bets: '0-1' },
                { name: 'Rotterdam', niche: 'SF+F @2.0-3.0', dates: '9-15 f√©v', bets: '1-2' },
                { name: 'Buenos Aires', niche: 'SF+F @2.5-3.5', dates: '9-15 f√©v', bets: '1-2' },
                { name: 'Doha', niche: 'F @2.0-2.5', dates: '16-22 f√©v', bets: '0-1' },
                { name: 'Rio de Janeiro', niche: '‚≠ê R32 FAVORI @1.5-2.0', dates: '16-22 f√©v', bets: '2-4', hot: true, fav: true },
                { name: 'Delray Beach', niche: 'F @2.0-2.5', dates: '16-22 f√©v', bets: '0-1' },
                { name: 'Acapulco', niche: 'SF+F @2.0-3.0', dates: '23 f√©v - 1 mars', bets: '1-2' },
                { name: 'Dubai', niche: 'SF+F @2.0-3.0', dates: '23 f√©v - 1 mars', bets: '1-2' },
                { name: 'Santiago', niche: 'SF+F @2.5-3.5', dates: '23 f√©v - 1 mars', bets: '1-2' },
            ]},
            { month: 'Mars', betsMin: 4, betsMax: 8, tournaments: [
                { name: 'INDIAN WELLS', niche: 'SF+F @2.0-4.0', dates: '4-16 mars', bets: '1-2', hot: true },
                { name: 'MIAMI', niche: 'SF+F @2.0-4.0', dates: '18-30 mars', bets: '1-2', hot: true },
                { name: 'Marrakech', niche: 'SF+F @2.5-3.5', dates: '30 mars - 5 avril', bets: '1-2' },
                { name: 'Houston', niche: 'SF+F @2.5-3.5', dates: '30 mars - 5 avril', bets: '1-2' },
                { name: 'Bucharest', niche: 'SF+F @2.5-3.5', dates: '30 mars - 5 avril', bets: '1-2' },
            ]},
            { month: 'Avril ‚≠ê', betsMin: 9, betsMax: 18, hotMonth: true, tournaments: [
                { name: 'MONTE-CARLO', niche: 'R16 @2.5-3.5', dates: '5-13 avril', bets: '1-2', hot: true },
                { name: 'Barcelona', niche: '‚≠ê R32 FAVORI @1.5-2.0', dates: '13-19 avril', bets: '2-4', hot: true, fav: true },
                { name: 'Munich', niche: 'SF+F @2.5-3.5', dates: '13-19 avril', bets: '1-2' },
                { name: 'MADRID', niche: 'R16 @2.5-3.5', dates: '22 avr - 3 mai', bets: '1-2', hot: true },
            ]},
            { month: 'Mai', betsMin: 6, betsMax: 12, tournaments: [
                { name: 'ROME', niche: 'R16 @2.5-3.5', dates: '6-18 mai', bets: '1-2', hot: true },
                { name: 'Geneva', niche: 'SF+F @2.5-3.5', dates: '17-24 mai', bets: '1-2' },
                { name: 'Hamburg', niche: '‚≠ê R32 FAVORI @1.5-2.0', dates: '17-24 mai', bets: '2-4', hot: true, fav: true },
                { name: 'ROLAND GARROS', niche: 'R32 @2.0-3.0', dates: '24 mai - 7 juin', bets: '3-6', hot: true },
            ]},
            { month: 'Juin üåø', betsMin: 2, betsMax: 4, hotMonth: true, tournaments: [
                { name: "'s-Hertogenbosch", niche: 'SF+F @2.0-3.0', dates: '8-14 juin', bets: '1-2' },
                { name: 'Stuttgart', niche: 'SF+F @2.0-3.0', dates: '8-14 juin', bets: '1-2' },
                { name: 'Halle', niche: 'SF+F @2.0-3.0 üî•+45%', dates: '15-21 juin', bets: '1-2', hot: true },
                { name: "Queen's", niche: 'SF+F @2.0-3.0 üî•+45%', dates: '15-21 juin', bets: '1-2', hot: true },
                { name: 'Mallorca', niche: 'SF+F @2.0-3.0', dates: '21-27 juin', bets: '1-2' },
                { name: 'Eastbourne', niche: 'SF+F @2.0-3.0', dates: '22-28 juin', bets: '1-2' },
            ]},
            { month: 'Juillet', betsMin: 5, betsMax: 10, tournaments: [
                { name: 'WIMBLEDON', niche: '-', dates: '29 juin - 12 juil', bets: '0' },
                { name: 'Bastad', niche: 'SF+F @2.5-3.5', dates: '13-19 juil', bets: '1-2' },
                { name: 'Gstaad', niche: 'SF+F @2.5-3.5', dates: '13-19 juil', bets: '1-2' },
                { name: 'Umag', niche: 'SF+F @2.5-3.5', dates: '13-19 juil', bets: '1-2' },
                { name: 'Kitzbuhel', niche: 'SF+F @2.5-3.5', dates: '20-26 juil', bets: '1-2' },
                { name: 'Estoril', niche: 'SF+F @2.5-3.5', dates: '20-26 juil', bets: '1-2' },
                { name: 'Washington', niche: 'SF+F @2.0-3.0', dates: '27 juil - 2 ao√ªt', bets: '1-2' },
                { name: 'Los Cabos', niche: 'F @2.0-2.5', dates: '27 juil - 2 ao√ªt', bets: '0-1' },
            ]},
            { month: 'Ao√ªt', betsMin: 3, betsMax: 7, tournaments: [
                { name: 'MONTREAL', niche: 'SF+F @2.0-4.0', dates: '2-10 ao√ªt', bets: '1-2', hot: true },
                { name: 'CINCINNATI', niche: 'SF+F @2.0-4.0', dates: '13-24 ao√ªt', bets: '1-2', hot: true },
                { name: 'Winston-Salem', niche: 'F @2.0-2.5', dates: '23-30 ao√ªt', bets: '0-1' },
                { name: 'US OPEN', niche: 'QF @2.0-3.0', dates: '31 ao√ªt - 13 sept', bets: '1-2', hot: true },
            ]},
            { month: 'Sept-Oct', betsMin: 2, betsMax: 8, tournaments: [
                { name: 'Chengdu/Hangzhou', niche: 'F @2.0-2.5', dates: '23-28 sept', bets: '0-2' },
                { name: 'Tokyo/Beijing', niche: 'SF @2.0-3.0', dates: '30 sept - 4 oct', bets: '1-2' },
                { name: 'SHANGHAI', niche: 'SF+F @2.0-4.0', dates: '7-19 oct', bets: '1-2', hot: true },
                { name: 'Almaty/Brussels/Lyon', niche: 'F @2.0-2.5', dates: '19-25 oct', bets: '0-3' },
                { name: 'Basel/Vienna', niche: 'SF+F @2.0-3.0', dates: '26 oct - 1 nov', bets: '1-2' },
            ]},
            { month: 'Novembre', betsMin: 0, betsMax: 2, tournaments: [
                { name: 'PARIS MASTERS', niche: 'SF+F @2.0-4.0', dates: '2-8 nov', bets: '1-2', hot: true },
                { name: 'Stockholm', niche: 'F @2.0-2.5', dates: '8-15 nov', bets: '0-1' },
                { name: 'ATP FINALS', niche: '-', dates: '15-22 nov', bets: '0', hot: true },
            ]},
        ];

        const CALENDAR_WTA = [
            { month: 'Janvier üèÜ', betsMin: 8, betsMax: 12, hotMonth: true, tournaments: [
                { name: 'Brisbane', niche: '-', dates: '5-11 jan', bets: '0' },
                { name: 'Auckland', niche: '-', dates: '5-11 jan', bets: '0' },
                { name: 'Adelaide', niche: '-', dates: '12-17 jan', bets: '0' },
                { name: 'Hobart', niche: '-', dates: '12-17 jan', bets: '0' },
                { name: 'AUSTRALIAN OPEN', niche: 'R16 @2.5-3.5 + QF+SF @1.5-2.5', dates: '19 jan - 1 f√©v', bets: '4-6', hot: true },
            ]},
            { month: 'F√©vrier', betsMin: 4, betsMax: 8, tournaments: [
                { name: 'Abu Dhabi', niche: 'R16 @2.5-3.0', dates: '2-8 f√©v', bets: '1-2' },
                { name: 'Cluj-Napoca', niche: 'R16 @2.5-3.0', dates: '2-8 f√©v', bets: '1-2' },
                { name: 'Ostrava', niche: 'R16 @2.5-3.0', dates: '2-8 f√©v', bets: '1-2' },
                { name: 'Doha', niche: '‚ö° QF @1.5-2.5 + R16 @2.5-3.0', dates: '9-15 f√©v', bets: '1-3', hot: true },
                { name: 'Dubai', niche: '‚ö° QF @1.5-2.5 + R16 @2.5-3.0', dates: '16-22 f√©v', bets: '1-3', hot: true },
                { name: 'Merida', niche: 'SF @2.0-3.0', dates: '23 f√©v - 1 mars', bets: '1-2' },
                { name: 'Austin', niche: 'SF @2.0-3.0', dates: '23 f√©v - 1 mars', bets: '1-2' },
            ]},
            { month: 'Mars', betsMin: 4, betsMax: 8, tournaments: [
                { name: 'INDIAN WELLS', niche: '‚ö° QF @1.5-2.5 + R16 @2.5-3.0', dates: '2-15 mars', bets: '1-3', hot: true },
                { name: 'MIAMI', niche: '‚ö° QF @1.5-2.5 + R16 @2.5-3.0', dates: '16-29 mars', bets: '1-3', hot: true },
                { name: 'Charleston', niche: '-', dates: '30 mars - 6 avril', bets: '0' },
                { name: 'Bogota', niche: 'SF @2.0-3.0', dates: '30 mars - 6 avril', bets: '1-2' },
            ]},
            { month: 'Avril üß±', betsMin: 6, betsMax: 10, hotMonth: true, tournaments: [
                { name: 'Linz (Indoor Clay)', niche: '-', dates: '6-12 avril', bets: '0' },
                { name: 'Stuttgart (Indoor Clay)', niche: '-', dates: '13-19 avril', bets: '0' },
                { name: 'Rouen (Indoor Clay)', niche: '-', dates: '13-19 avril', bets: '0' },
                { name: 'MADRID', niche: '‚ö° R32 @3.0-4.0', dates: '20 avr - 3 mai', bets: '2-4', hot: true },
            ]},
            { month: 'Mai', betsMin: 6, betsMax: 12, tournaments: [
                { name: 'ROME', niche: '‚ö° R32 @3.0-4.0', dates: '4-17 mai', bets: '2-4', hot: true },
                { name: 'Rabat', niche: 'SF @2.0-3.0', dates: '18-24 mai', bets: '1-2' },
                { name: 'Strasbourg', niche: 'SF @2.0-3.0', dates: '18-24 mai', bets: '1-2' },
                { name: 'ROLAND GARROS', niche: 'R16+QF @1.5-2.5', dates: '25 mai - 7 juin', bets: '2-4', hot: true },
            ]},
            { month: 'Juin üåø', betsMin: 6, betsMax: 10, hotMonth: true, tournaments: [
                { name: 'London', niche: 'QF+SF @2.5-3.5', dates: '8-14 juin', bets: '1-2', hot: true },
                { name: "'s-Hertogenbosch", niche: 'QF+SF @2.5-3.5', dates: '8-14 juin', bets: '1-2', hot: true },
                { name: 'Berlin', niche: '-', dates: '15-21 juin', bets: '0' },
                { name: 'Nottingham', niche: 'QF+SF @2.5-3.5', dates: '15-21 juin', bets: '1-2', hot: true },
                { name: 'Bad Homburg', niche: 'QF+SF @2.5-3.5', dates: '22-28 juin', bets: '1-2', hot: true },
                { name: 'Eastbourne', niche: 'QF+SF @2.5-3.5', dates: '22-28 juin', bets: '1-2', hot: true },
            ]},
            { month: 'Juillet', betsMin: 4, betsMax: 8, tournaments: [
                { name: 'WIMBLEDON', niche: '-', dates: '29 juin - 12 juil', bets: '0' },
                { name: 'Iasi', niche: 'SF @2.0-3.0', dates: '13-19 juil', bets: '1-2' },
                { name: 'Hamburg (Clay)', niche: 'SF @2.0-3.0', dates: '20-26 juil', bets: '1-2' },
                { name: 'Prague (Hard)', niche: 'SF @2.0-3.0', dates: '20-26 juil', bets: '1-2' },
                { name: 'Washington', niche: 'SF @2.0-3.0', dates: '27 juil - 2 ao√ªt', bets: '1-2' },
            ]},
            { month: 'Ao√ªt', betsMin: 6, betsMax: 10, tournaments: [
                { name: 'TORONTO', niche: '‚ö° QF @1.5-2.5 + R16 @2.5-3.0', dates: '3-10 ao√ªt', bets: '1-3', hot: true },
                { name: 'CINCINNATI', niche: '‚ö° QF @1.5-2.5 + R16 @2.5-3.0', dates: '10-17 ao√ªt', bets: '1-3', hot: true },
                { name: 'Monterrey', niche: 'SF @2.0-3.0', dates: '24-30 ao√ªt', bets: '1-2' },
                { name: 'Cleveland', niche: 'SF @2.0-3.0', dates: '24-30 ao√ªt', bets: '1-2' },
                { name: 'US OPEN', niche: 'R16 @2.5-3.5 + QF+SF @1.5-2.5', dates: '31 ao√ªt - 13 sept', bets: '4-6', hot: true },
            ]},
            { month: 'Sept-Oct', betsMin: 4, betsMax: 10, tournaments: [
                { name: 'Guadalajara', niche: 'R16 @2.5-3.0', dates: '14-20 sept', bets: '1-2' },
                { name: 'S√£o Paulo', niche: 'SF @2.0-3.0', dates: '14-20 sept', bets: '1-2' },
                { name: 'Singapore', niche: 'R16 @2.5-3.0', dates: '21-27 sept', bets: '1-2' },
                { name: 'Seoul', niche: 'R16 @2.5-3.0', dates: '21-27 sept', bets: '1-2' },
                { name: 'BEIJING', niche: '‚ö° QF @1.5-2.5 + R16 @2.5-3.0', dates: '28 sept - 5 oct', bets: '1-3', hot: true },
                { name: 'WUHAN', niche: '‚ö° QF @1.5-2.5 + R16 @2.5-3.0', dates: '12-18 oct', bets: '1-3', hot: true },
                { name: 'Ningbo', niche: 'R16 @2.5-3.0', dates: '19-25 oct', bets: '1-2' },
                { name: 'Osaka', niche: 'R16 @2.5-3.0', dates: '19-25 oct', bets: '1-2' },
                { name: 'Tokyo', niche: 'R16 @2.5-3.0', dates: '26 oct - 1 nov', bets: '1-2' },
                { name: 'Guangzhou', niche: 'SF @2.0-3.0', dates: '26 oct - 1 nov', bets: '1-2' },
            ]},
            { month: 'Nov-D√©c', betsMin: 0, betsMax: 2, tournaments: [
                { name: 'Hong Kong', niche: 'SF @2.0-3.0', dates: '2-8 nov', bets: '1-2' },
                { name: 'Jiujiang', niche: 'SF @2.0-3.0', dates: '2-8 nov', bets: '1-2' },
                { name: 'WTA FINALS', niche: '-', dates: '9-16 nov', bets: '0', hot: true },
            ]},
        ];

        function renderCalendarGrid(data, color) {
            return data.map(m => `
                <div style="background:var(--bg);border-radius:6px;padding:.75rem;${m.hotMonth ? 'border:2px solid ' + color : 'border:1px solid var(--border)'}">
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:.75rem">
                        <span style="font-weight:700;font-size:1rem;${m.hotMonth ? 'color:' + color : ''}">${m.month}</span>
                        <span style="font-size:.75rem;color:var(--muted)">${m.betsMin}-${m.betsMax} paris</span>
                    </div>
                    ${m.tournaments.map(t => `
                        <div style="padding:.4rem 0;border-bottom:1px solid var(--border);font-size:.7rem;${t.hot ? 'background:rgba(34,197,94,.1);margin:0 -.5rem;padding:.4rem .5rem;border-radius:4px' : ''}">
                            <div style="display:flex;justify-content:space-between">
                                <span style="font-weight:600;${t.hot ? 'color:var(--green)' : ''}">${t.name}</span>
                                <span style="color:var(--muted)">${t.dates}</span>
                            </div>
                            <div style="color:var(--muted);font-size:.6rem">${t.niche} ‚Ä¢ ${t.bets} paris</div>
                        </div>
                    `).join('')}
                </div>
            `).join('');
        }
        
        function calcDynamicCalendarStats(circuit) {
            var niches = circuit === 'atp' ? NICHES_ATP.filter(n => n.on) : NICHES_WTA.filter(n => n.on);
            var tournaments = circuit === 'atp' ? TOURNAMENTS_ATP : TOURNAMENTS_WTA;
            
            var totalBetsMin = 0;
            var totalBetsMax = 0;
            var opportunities = [];
            
            // Pour chaque tournoi, compter les ROUNDS UNIQUES couverts (pas les niches)
            for (var t = 0; t < tournaments.length; t++) {
                var tour = tournaments[t];
                var matchingNiches = [];
                var coveredRounds = {}; // Cl√©: round, pour √©viter les doublons
                
                for (var n = 0; n < niches.length; n++) {
                    var niche = niches[n];
                    
                    // V√©rifier si la niche matche ce tournoi
                    if (niche.cat !== tour.cat) continue;
                    if (niche.surf !== tour.surf) continue;
                    
                    // V√©rifier si au moins un round correspond
                    var hasMatchingRound = false;
                    for (var r = 0; r < niche.rounds.length; r++) {
                        var round = niche.rounds[r];
                        if (tour.rounds.indexOf(round) >= 0) {
                            hasMatchingRound = true;
                            // Marquer ce round comme couvert (√©vite les doublons)
                            coveredRounds[round] = true;
                        }
                    }
                    
                    if (hasMatchingRound) {
                        matchingNiches.push(niche.name);
                    }
                }
                
                // Compter les rounds uniques couverts (pas les niches !)
                var uniqueRoundsCount = Object.keys(coveredRounds).length;
                
                if (uniqueRoundsCount > 0) {
                    opportunities.push({
                        tournament: tour.name,
                        cat: tour.cat,
                        surf: tour.surf,
                        bets: uniqueRoundsCount, // Maintenant c'est le nb de rounds uniques
                        niches: matchingNiches
                    });
                    totalBetsMin += Math.max(1, Math.floor(uniqueRoundsCount * 0.5));
                    totalBetsMax += uniqueRoundsCount;
                }
            }
            
            return {
                niches: niches,
                opportunities: opportunities,
                totalBetsMin: totalBetsMin,
                totalBetsMax: totalBetsMax,
                avgBets: Math.round((totalBetsMin + totalBetsMax) / 2)
            };
        }
        
        function calcDynamicROI(circuit) {
            // Si on a des donn√©es de backtest, calculer le vrai ROI
            // IMPORTANT: On d√©doublonne les matchs qui correspondent √† plusieurs niches
            var data = circuit === 'atp' ? btDataATP : btDataWTA;
            var niches = circuit === 'atp' ? NICHES_ATP.filter(n => n.on) : NICHES_WTA.filter(n => n.on);
            
            if (data.length === 0 || niches.length === 0) {
                return { roi: 0, profit: 0, bets: 0, hasData: false };
            }
            
            var curYear = new Date().getFullYear();
            var seenMatches = {}; // Cl√© unique pour chaque match
            var results = [];
            
            // Pour chaque match dans les donn√©es, v√©rifier s'il correspond √† au moins une niche
            for (var i = 0; i < data.length; i++) {
                var m = data[i];
                if (m.year < curYear - 3 || m.year > curYear) continue;
                
                // Cl√© unique du match
                var matchKey = m.date + '|' + m.p1 + '|' + m.p2;
                if (seenMatches[matchKey]) continue;
                
                // V√©rifier si ce match correspond √† au moins une niche active
                var matchedNiche = null;
                for (var n = 0; n < niches.length; n++) {
                    var niche = niches[n];
                    
                    // V√©rifier cat√©gorie
                    var catKey = niche.cat.replace('Masters ', '').replace('WTA ', '').replace('Grand Slam', 'Grand');
                    if (!m.category || m.category.indexOf(catKey) < 0) continue;
                    
                    // V√©rifier surface
                    if (m.surface !== niche.surf) continue;
                    
                    // V√©rifier round
                    var roundMatch = false;
                    for (var r = 0; r < niche.rounds.length; r++) {
                        if (m.round === niche.rounds[r]) {
                            roundMatch = true;
                            break;
                        }
                    }
                    if (!roundMatch) continue;
                    
                    // V√©rifier cotes
                    var dO = Math.max(m.o1, m.o2);
                    var fO = Math.min(m.o1, m.o2);
                    var odds = niche.strat === 'underdog' ? dO : fO;
                    
                    if (odds >= niche.min && odds <= niche.max) {
                        matchedNiche = niche;
                        break; // On a trouv√© une niche, pas besoin de chercher les autres
                    }
                }
                
                if (matchedNiche) {
                    seenMatches[matchKey] = true;
                    
                    var dO = Math.max(m.o1, m.o2);
                    var fO = Math.min(m.o1, m.o2);
                    var dP1 = m.o1 > m.o2;
                    var odds = matchedNiche.strat === 'underdog' ? dO : fO;
                    var won = matchedNiche.strat === 'underdog' ? dP1 : !dP1;
                    
                    results.push({
                        year: m.year,
                        won: won,
                        pnl: won ? odds - 1 : -1
                    });
                }
            }
            
            if (results.length < 5) {
                return { roi: 0, profit: 0, bets: 0, hasData: false };
            }
            
            var totalBets = results.length;
            var totalProfit = 0;
            for (var i = 0; i < results.length; i++) {
                totalProfit += results[i].pnl;
            }
            
            var roi = totalBets > 0 ? (totalProfit / totalBets * 100) : 0;
            var avgBetsPerYear = totalBets / 3;
            
            return { 
                roi: roi, 
                profit: totalProfit, 
                bets: totalBets, 
                avgBetsPerYear: avgBetsPerYear,
                hasData: true 
            };
        }

        function renderCalendar() {
            const stake = state.stake;
            let html = '';
            
            // Utiliser la projection dynamique (avec coefficients) filtr√©e par circuit
            var proj = calcProjectedProfit(calendarCircuit);
            
            var totalNiches = proj.projections.length;
            var totalAvgBets = proj.totalBetsPerYear;
            var combinedROI = proj.avgROI;
            var combinedProfit = proj.totalProfitPerYear;
            
            // Stats header
            html += '<div class="card">';
            html += '<div class="card-title">üìä Projection ' + (calendarCircuit === 'all' ? 'ATP + WTA' : calendarCircuit.toUpperCase()) + ' (mise base ' + stake + '‚Ç¨)</div>';
            html += '<div style="font-size:.8rem;color:var(--muted);margin-bottom:1rem">Bas√©e sur ' + totalNiches + ' niches actives ‚Ä¢ Coefficients appliqu√©s</div>';
            html += '<div class="stats" style="grid-template-columns:repeat(4,1fr)">';
            html += '<div class="stat"><div class="val">~' + Math.round(totalAvgBets) + '</div><div class="lbl">Paris/an</div></div>';
            html += '<div class="stat"><div class="val">' + Math.round(proj.totalStakedPerYear).toLocaleString() + '‚Ç¨</div><div class="lbl">Mis√©/an</div></div>';
            html += '<div class="stat"><div class="val pos">' + (totalNiches > 0 ? '+' + combinedProfit.toFixed(0) + '‚Ç¨' : '?') + '</div><div class="lbl">Profit esp.</div></div>';
            html += '<div class="stat"><div class="val">' + (totalNiches > 0 ? '+' + combinedROI.toFixed(1) + '%' : '?') + '</div><div class="lbl">ROI pond√©r√©</div></div>';
            html += '</div></div>';
            
            // L√©gende
            html += '<div class="card" style="padding:.6rem 1rem">';
            html += '<div style="display:flex;gap:1.5rem;flex-wrap:wrap;font-size:.8rem">';
            html += '<span>üü¢ Niche ATP active</span>';
            html += '<span>ü©∑ Niche WTA active</span>';
            html += '<span style="opacity:.5">Pas de niche</span>';
            html += '<span>üîµ Hard | üß± Clay | üåø Grass</span>';
            html += '</div></div>';
            
            // Calendrier par mois
            html += renderFullCalendar();
            
            var calendarEl = document.getElementById('calendarContent');
            if (calendarEl) calendarEl.innerHTML = html;
        }
        
        // Calculer les vraies stats depuis le backtest des niches
        function calcRealNicheStats() {
            var curYear = new Date().getFullYear();
            var totalBetsPerYear = 0;
            var activeCount = 0;
            var fromBacktest = false;
            
            // ATP
            NICHES_ATP.filter(function(n) { return n.on; }).forEach(function(n) {
                activeCount++;
                if (btDataATP.length > 0) {
                    var r = testComboV2(btDataATP, n.cat, n.surf, n.rounds, n.strat, n.min, n.max, 2007, curYear);
                    if (r && r.yrs > 0) {
                        totalBetsPerYear += r.bets / r.yrs;
                        fromBacktest = true;
                    }
                }
            });
            
            // WTA
            NICHES_WTA.filter(function(n) { return n.on; }).forEach(function(n) {
                activeCount++;
                if (btDataWTA.length > 0) {
                    var r = testComboV2(btDataWTA, n.cat, n.surf, n.rounds, n.strat, n.min, n.max, 2007, curYear);
                    if (r && r.yrs > 0) {
                        totalBetsPerYear += r.bets / r.yrs;
                        fromBacktest = true;
                    }
                }
            });
            
            return {
                activeCount: activeCount,
                totalBetsPerYear: totalBetsPerYear,
                fromBacktest: fromBacktest
            };
        }
        
        function renderFullCalendar() {
            // Organiser TOURNAMENT_CALENDAR par mois
            var months = {
                'Janvier': [],
                'F√©vrier': [],
                'Mars': [],
                'Avril': [],
                'Mai': [],
                'Juin': [],
                'Juillet': [],
                'Ao√ªt': [],
                'Septembre': [],
                'Octobre': [],
                'Novembre': [],
                'D√©cembre': []
            };
            
            var monthNames = ['Janvier', 'F√©vrier', 'Mars', 'Avril', 'Mai', 'Juin', 'Juillet', 'Ao√ªt', 'Septembre', 'Octobre', 'Novembre', 'D√©cembre'];
            // Ordre d'affichage: D√©cembre en premier (saison tennis)
            var displayOrder = ['D√©cembre', 'Janvier', 'F√©vrier', 'Mars', 'Avril', 'Mai', 'Juin', 'Juillet', 'Ao√ªt', 'Septembre', 'Octobre', 'Novembre'];
            
            TOURNAMENT_CALENDAR.forEach(function(period) {
                var startParts = period.start.split('-');
                var monthIdx = parseInt(startParts[0]) - 1;
                var monthName = monthNames[monthIdx];
                
                // Format dates
                var startDay = parseInt(startParts[1]);
                var endParts = period.end.split('-');
                var endDay = parseInt(endParts[1]);
                var endMonthIdx = parseInt(endParts[0]) - 1;
                
                var dateStr = startDay + '-' + endDay + ' ' + monthNames[endMonthIdx].substring(0, 3);
                if (monthIdx !== endMonthIdx) {
                    dateStr = startDay + ' ' + monthNames[monthIdx].substring(0, 3) + ' - ' + endDay + ' ' + monthNames[endMonthIdx].substring(0, 3);
                }
                
                period.tournaments.forEach(function(t) {
                    // Filtrer par circuit s√©lectionn√©
                    if (calendarCircuit !== 'all') {
                        if (t.circuit !== calendarCircuit && t.circuit !== 'both') return;
                    }
                    
                    months[monthName].push({
                        name: t.name,
                        dates: dateStr,
                        circuit: t.circuit,
                        cat: t.cat,
                        surf: t.surf,
                        matchingNiches: getMatchingNichesForTournament(t)
                    });
                });
            });
            
            var html = '<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(320px,1fr));gap:1rem">';
            
            displayOrder.forEach(function(monthName) {
                var tournaments = months[monthName];
                if (tournaments.length === 0 && calendarCircuit !== 'all') return;
                
                var monthHasOpportunity = tournaments.some(function(t) { return t.matchingNiches.length > 0; });
                
                html += '<div class="card" style="' + (monthHasOpportunity ? 'border:1px solid var(--green)' : '') + '">';
                html += '<div class="card-title" style="' + (monthHasOpportunity ? 'color:var(--green)' : '') + '">' + monthName + (monthHasOpportunity ? ' üéØ' : '') + '</div>';
                
                if (tournaments.length === 0) {
                    html += '<div style="color:var(--muted);font-size:.8rem;padding:.5rem 0">Aucun tournoi ' + calendarCircuit.toUpperCase() + '</div>';
                } else {
                    html += '<div style="display:flex;flex-direction:column;gap:.5rem">';
                    
                    tournaments.forEach(function(t) {
                        var hasNiche = t.matchingNiches.length > 0;
                        var surfIcon = t.surf === 'Hard' ? 'üîµ' : t.surf === 'Clay' ? 'üß±' : 'üåø';
                        var circuitIcon = t.circuit === 'atp' ? 'üü¢' : t.circuit === 'wta' ? 'ü©∑' : 'üü¢ü©∑';
                        
                        // Cat√©gorie style
                        var catStyle = '';
                        if (t.cat === 'Grand Slam') catStyle = 'font-weight:700;';
                        else if (t.cat.includes('1000') || t.cat.includes('Masters')) catStyle = 'font-weight:600;';
                        
                        // Highlight si niche active
                        var bgColor = hasNiche ? 'rgba(34,197,94,.15)' : 'var(--bg)';
                        var borderColor = hasNiche ? 'var(--green)' : 'var(--border)';
                        
                        html += '<div style="background:' + bgColor + ';border:1px solid ' + borderColor + ';border-radius:6px;padding:.6rem">';
                        
                        // Ligne 1: Nom + dates
                        html += '<div style="display:flex;justify-content:space-between;align-items:center">';
                        html += '<span style="' + catStyle + 'font-size:.9rem">' + surfIcon + ' ' + circuitIcon + ' ' + t.name + '</span>';
                        html += '<span style="font-size:.75rem;color:var(--muted)">' + t.dates + '</span>';
                        html += '</div>';
                        
                        // Ligne 2: Cat√©gorie + Surface
                        html += '<div style="font-size:.7rem;color:var(--muted);margin-top:.25rem">' + t.cat + ' ‚Ä¢ ' + t.surf + '</div>';
                        
                        // Ligne 3: Niches actives (si pr√©sentes)
                        if (hasNiche) {
                            var nicheDisplay = formatNichesForDisplay(t.matchingNiches);
                            html += '<div style="font-size:.75rem;color:var(--green);margin-top:.4rem;font-weight:600">‚Üí ' + nicheDisplay + '</div>';
                        }
                        
                        html += '</div>';
                    });
                    
                    html += '</div>';
                }
                
                html += '</div>';
            });
            
            html += '</div>';
            return html;
        }
        // ==================== NICHES MANAGEMENT ====================
        var nichesCircuit = 'all';
        
        function setNichesCircuit(c) {
            nichesCircuit = c;
            document.querySelectorAll('#main-niches .circuit-tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`#main-niches .circuit-tab.${c === 'all' ? 'global' : c}`).classList.add('active');
            renderNichesList();
        }
        
        function renderNichesList() {
            // Chercher le conteneur dans labNichesSection
            var container = document.querySelector('#labNichesSection #nichesListContainer') ||
                           document.querySelector('#main-niches #nichesListContainer') || 
                           document.querySelector('#main-lab #nichesListContainer') ||
                           document.getElementById('nichesListContainer');
            
            console.log('renderNichesList - container found:', container);
            
            if (!container) {
                console.warn('nichesListContainer not found');
                return;
            }
            
            var curYear = new Date().getFullYear();
            var curMonth = new Date().getMonth();
            
            // R√©cup√©rer la p√©riode s√©lectionn√©e
            var periodSelect = document.getElementById('nichesPeriod');
            var period = periodSelect ? periodSelect.value : 'all';
            
            // Calculer les ann√©es de d√©but selon la p√©riode
            var periodConfig = {
                '1m': { years: 0, months: 1, label: '1 mois' },
                '3m': { years: 0, months: 3, label: '3 mois' },
                '6m': { years: 0, months: 6, label: '6 mois' },
                '1y': { years: 1, months: 0, label: '1 an' },
                '3y': { years: 3, months: 0, label: '3 ans' },
                '5y': { years: 5, months: 0, label: '5 ans' },
                '10y': { years: 10, months: 0, label: '10 ans' },
                'all': { years: 50, months: 0, label: 'Tout' }
            };
            var cfg = periodConfig[period];
            var yearFrom = cfg.years > 0 ? curYear - cfg.years : curYear;
            var monthFrom = cfg.months > 0 ? curMonth - cfg.months : 0;
            if (monthFrom < 0) {
                yearFrom--;
                monthFrom += 12;
            }
            
            // Collecter les niches selon le filtre
            var niches = [];
            if (nichesCircuit === 'atp' || nichesCircuit === 'all') {
                NICHES_ATP.forEach(function(n) { niches.push({ niche: n, circuit: 'atp', data: btDataATP }); });
            }
            if (nichesCircuit === 'wta' || nichesCircuit === 'all') {
                NICHES_WTA.forEach(function(n) { niches.push({ niche: n, circuit: 'wta', data: btDataWTA }); });
            }
            
            // Mettre √† jour les compteurs (s'ils existent)
            var activeCount = niches.filter(function(item) { return item.niche.on; }).length;
            var pausedCount = niches.filter(function(item) { return !item.niche.on; }).length;
            var activeEl = document.getElementById('nichesActiveCount');
            var pausedEl = document.getElementById('nichesPausedCount');
            var totalEl = document.getElementById('nichesTotalCount');
            if (activeEl) activeEl.textContent = activeCount;
            if (pausedEl) pausedEl.textContent = pausedCount;
            if (totalEl) totalEl.textContent = niches.length;
            
            if (niches.length === 0) {
                container.innerHTML = '<div class="card"><div class="no-data">Aucune niche configur√©e. Va dans le D√©tecteur pour en trouver !</div></div>';
                return;
            }
            
            var hasData = btDataATP.length > 0 || btDataWTA.length > 0;
            
            // Calculer les stats pour chaque niche
            var nichesWithStats = [];
            niches.forEach(function(item, idx) {
                var n = item.niche;
                var d = item.data;
                
                var rAll = null, rPeriod = null, r3 = null, yearlyData = [];
                
                if (d.length > 0) {
                    rAll = testComboV2(d, n.cat, n.surf, n.rounds, n.strat, n.min, n.max, 2007, curYear);
                    rPeriod = testComboV2(d, n.cat, n.surf, n.rounds, n.strat, n.min, n.max, yearFrom, curYear);
                    r3 = testComboV2(d, n.cat, n.surf, n.rounds, n.strat, n.min, n.max, curYear - 3, curYear);
                    if (rAll) yearlyData = rAll.yearlyData || [];
                }
                
                // Calculer le score acad√©mique
                var scoreData = null;
                if (rAll && rAll.bets >= 10) {
                    scoreData = calcCompositeScore(rAll, r3, null, yearlyData, 500);
                }
                
                // D√©terminer la tendance
                var trend = 'stable';
                var roiAll = rAll ? rAll.roi : null;
                var roi3 = r3 ? r3.roi : null;
                if (roiAll !== null && roi3 !== null) {
                    if (roi3 > roiAll + 5) trend = 'up';
                    else if (roi3 < roiAll - 5) trend = 'down';
                }
                
                // D√©terminer le statut sant√©
                var health = 'unknown';
                if (roiAll !== null) {
                    if (roiAll < 0) health = 'danger';
                    else if (roi3 !== null && roi3 < 0) health = 'warning';
                    else health = 'good';
                }
                
                nichesWithStats.push({
                    idx: idx,
                    niche: n,
                    circuit: item.circuit,
                    rAll: rAll,
                    rPeriod: rPeriod,
                    r3: r3,
                    yearlyData: yearlyData,
                    scoreData: scoreData,
                    roiAll: roiAll,
                    roi3: roi3,
                    roiPeriod: rPeriod ? rPeriod.roi : null,
                    betsAll: rAll ? rAll.bets : 0,
                    trend: trend,
                    health: health
                });
            });
            
            // Trier: actives d'abord, puis par ROI all-time
            nichesWithStats.sort(function(a, b) {
                if (a.niche.on !== b.niche.on) return b.niche.on ? 1 : -1;
                return (b.roiAll || -999) - (a.roiAll || -999);
            });
            
            // G√©n√©rer le HTML - Format cartes cliquables
            var html = '';
            
            if (!hasData) {
                html += '<div style="background:rgba(234,179,8,.1);border:1px solid var(--yellow);border-radius:8px;padding:1rem;margin-bottom:1rem;text-align:center">';
                html += '‚ö†Ô∏è Charge les CSV (ATP/WTA) pour voir les performances d√©taill√©es';
                html += '</div>';
            }
            
            nichesWithStats.forEach(function(item, displayIdx) {
                var n = item.niche;
                var circuitIcon = item.circuit === 'atp' ? 'üü¢' : 'ü©∑';
                var circuitClass = item.circuit;
                
                // Couleurs selon sant√©
                var borderColor = !n.on ? 'var(--muted)' : 
                                  item.health === 'danger' ? 'var(--red)' : 
                                  item.health === 'warning' ? 'var(--yellow)' : 'var(--green)';
                var bgOpacity = !n.on ? '0.5' : '1';
                
                // Score
                var score = item.scoreData ? item.scoreData.score : null;
                var scoreClass = score >= 70 ? 'excellent' : score >= 55 ? 'good' : score >= 40 ? 'moderate' : 'poor';
                
                // Trend icon
                var trendIcon = item.trend === 'up' ? 'üìà' : item.trend === 'down' ? 'üìâ' : '‚û°Ô∏è';
                
                html += '<div class="niche-manager-card' + (!n.on ? ' paused' : '') + '" id="manager-card-' + displayIdx + '" style="border-left:4px solid ' + borderColor + ';opacity:' + bgOpacity + '">';
                
                // Header cliquable
                html += '<div class="niche-manager-header" onclick="toggleManagerCard(' + displayIdx + ')" style="position:relative">';
                
                // Indicateur expand/collapse
                html += '<div class="expand-indicator" style="position:absolute;right:1rem;top:50%;transform:translateY(-50%);color:var(--muted);font-size:.8rem;transition:transform .2s">‚ñº</div>';
                
                // Score badge (si donn√©es disponibles)
                if (score !== null) {
                    html += '<div class="niche-score ' + scoreClass + '" style="width:40px;height:40px;font-size:1rem">' + score + '</div>';
                } else {
                    html += '<div style="width:40px;height:40px;background:var(--border);border-radius:8px;display:flex;align-items:center;justify-content:center;color:var(--muted)">?</div>';
                }
                
                // Info principale
                html += '<div class="niche-manager-info">';
                html += '<div class="niche-manager-name">';
                html += '<span class="badge ' + circuitClass + '">' + item.circuit.toUpperCase() + '</span> ';
                html += n.name;
                if (!n.on) html += ' <span style="color:var(--muted);font-size:.75rem">(pause)</span>';
                html += '</div>';
                html += '<div class="niche-manager-meta">';
                if (item.betsAll > 0) {
                    html += '<span>' + item.betsAll + ' paris</span>';
                    if (item.rAll) html += '<span>' + item.rAll.yrsPos + '/' + item.rAll.yrs + ' ans +</span>';
                    html += '<span>' + trendIcon + '</span>';
                }
                html += '</div>';
                html += '</div>';
                
                // ROI + Actions (sur m√™me ligne en mobile)
                html += '<div class="niche-manager-roi" onclick="event.stopPropagation()">';
                // ROI
                if (item.roiAll !== null) {
                    var roiColor = item.roiAll >= 0 ? 'var(--green)' : 'var(--red)';
                    html += '<div><div style="font-size:1.4rem;font-weight:700;color:' + roiColor + '">' + (item.roiAll >= 0 ? '+' : '') + item.roiAll.toFixed(0) + '%</div>';
                    html += '<div style="font-size:.65rem;color:var(--muted)">ROI</div></div>';
                } else {
                    html += '<div style="color:var(--muted)">-</div>';
                }
                // Toggle inline
                if (n.on) {
                    html += '<button onclick="toggleNicheFromManager(\'' + n.id + '\',\'' + item.circuit + '\',false)" class="toggle-switch on">ON</button>';
                } else {
                    html += '<button onclick="toggleNicheFromManager(\'' + n.id + '\',\'' + item.circuit + '\',true)" class="toggle-switch off">OFF</button>';
                }
                html += '</div>';

                // Delete s√©par√© (visible dans actions)
                html += '<div class="niche-manager-actions" onclick="event.stopPropagation()">';
                html += '<button onclick="deleteNicheFromManager(\'' + n.id + '\',\'' + item.circuit + '\',false)" class="delete-btn">üóëÔ∏è</button>';
                html += '</div>';
                
                html += '</div>'; // header
                
                // D√©tails (cach√©s par d√©faut, r√©v√©l√©s au clic)
                html += '<div class="niche-manager-details">';
                
                if (hasData && item.rAll) {
                    // M√©triques
                    html += '<div class="niche-metrics" style="grid-template-columns:repeat(5,1fr)">';
                    html += '<div class="niche-metric"><div class="val">' + (score !== null ? score : '-') + '</div><div class="lbl">Score</div></div>';
                    html += '<div class="niche-metric"><div class="val">' + (item.rAll ? item.rAll.yrsPos + '/' + item.rAll.yrs : '-') + '</div><div class="lbl">Ann√©es +</div></div>';
                    html += '<div class="niche-metric"><div class="val">' + (item.roi3 !== null ? (item.roi3 >= 0 ? '+' : '') + item.roi3.toFixed(0) + '%' : '-') + '</div><div class="lbl">ROI 3 ans</div></div>';
                    html += '<div class="niche-metric"><div class="val">' + (item.rAll ? (item.rAll.bets / item.rAll.yrs).toFixed(1) : '-') + '</div><div class="lbl">Paris/an</div></div>';
                    html += '<div class="niche-metric"><div class="val">' + (item.rAll ? '-' + item.rAll.maxDD.toFixed(1) + 'u' : '-') + '</div><div class="lbl">Max DD</div></div>';
                    html += '</div>';
                    
                    // Warnings et bonuses
                    if (item.scoreData && item.scoreData.warnings && item.scoreData.warnings.length > 0) {
                        html += '<div style="background:rgba(239,68,68,.1);border:1px solid rgba(239,68,68,.3);border-radius:6px;padding:.5rem;margin-bottom:.75rem">';
                        html += '<div style="font-size:.7rem;color:var(--red);margin-bottom:.25rem">‚ö†Ô∏è Alertes</div>';
                        item.scoreData.warnings.forEach(function(w) {
                            html += '<div style="font-size:.7rem;color:var(--text);padding-left:.5rem">' + w + '</div>';
                        });
                        html += '</div>';
                    }
                    
                    if (item.scoreData && item.scoreData.bonuses && item.scoreData.bonuses.length > 0) {
                        html += '<div style="background:rgba(34,197,94,.1);border:1px solid rgba(34,197,94,.3);border-radius:6px;padding:.5rem;margin-bottom:.75rem">';
                        html += '<div style="font-size:.7rem;color:var(--green);margin-bottom:.25rem">‚úÖ Points forts</div>';
                        item.scoreData.bonuses.forEach(function(b) {
                            html += '<div style="font-size:.7rem;color:var(--text);padding-left:.5rem">' + b + '</div>';
                        });
                        html += '</div>';
                    }
                    
                    // Performance ann√©e par ann√©e
                    if (item.yearlyData && item.yearlyData.length > 0) {
                        html += '<div style="font-size:.7rem;color:var(--muted);margin-bottom:.4rem">Performance par ann√©e:</div>';
                        html += '<div class="niche-years-detailed">';
                        item.yearlyData.forEach(function(y) {
                            var yClass = y.roi > 20 ? 'very-pos' : y.roi > 0 ? 'pos' : y.roi > -20 ? 'neg' : 'very-neg';
                            html += '<div class="niche-year-detail ' + yClass + '">';
                            html += '<div class="year-label">' + y.year + '</div>';
                            html += '<div class="year-bets">' + y.bets + 'p</div>';
                            html += '<div class="year-roi">' + (y.roi >= 0 ? '+' : '') + y.roi.toFixed(0) + '%</div>';
                            html += '</div>';
                        });
                        html += '</div>';
                    }
                    
                    // Breakdown du score si disponible
                    if (item.scoreData && item.scoreData.breakdown) {
                        var bd = item.scoreData.breakdown;
                        html += '<div style="background:var(--bg);border:1px solid var(--border);border-radius:6px;padding:.5rem;margin-top:.5rem">';
                        html += '<div style="font-size:.7rem;color:var(--muted);margin-bottom:.4rem">üìä D√©composition: Base ' + bd.base + ' ‚Üí Final ' + item.scoreData.score + '</div>';
                        html += '<div style="display:flex;gap:.5rem;flex-wrap:wrap;font-size:.65rem">';
                        html += '<span>Consist: ' + bd.consistencyScore.toFixed(0) + '/30</span>';
                        html += '<span>ROI: ' + bd.roiScore + '/25</span>';
                        html += '<span>Vol: ' + bd.volumeScore + '/20</span>';
                        html += '<span>Trend: ' + bd.trendScore + '/15</span>';
                        html += '<span style="color:var(--red)">P√©nal: -' + bd.penalties.total + '</span>';
                        html += '</div>';
                        html += '</div>';
                    }
                    
                    // Bouton Playground
                    html += '<button onclick="event.stopPropagation();loadDetNiche(\'' + n.cat + '\',\'' + n.surf + '\',\'' + n.rounds.join(',') + '\',\'' + n.strat + '\',' + n.min + ',' + n.max + ',\'' + item.circuit + '\')" style="width:100%;margin-top:.75rem;padding:.6rem;background:linear-gradient(135deg,var(--blue),#3b82f6);color:#fff;border:none;border-radius:6px;font-size:.8rem;font-weight:600;cursor:pointer">üî¨ Analyser dans le Playground</button>';
                    
                } else {
                    html += '<div style="text-align:center;padding:1rem;color:var(--muted);font-size:.85rem">Charge les donn√©es CSV pour voir l\'analyse d√©taill√©e</div>';
                }
                
                html += '</div>'; // details
                html += '</div>'; // card
            });
            
            container.innerHTML = html;
        }
        
        function toggleManagerCard(idx) {
            console.log('toggleManagerCard called:', idx);
            var card = document.getElementById('manager-card-' + idx);
            console.log('Card found:', card);
            if (card) {
                card.classList.toggle('expanded');
                console.log('Card expanded:', card.classList.contains('expanded'));
            }
        }
        
        function toggleNicheFromManager(nicheId, circuit, newStatus) {
            toggleNicheStatus(nicheId, circuit, newStatus);
            renderNichesList();
        }
        
        function deleteNicheFromManager(nicheId, circuit, confirmed) {
            console.log('deleteNicheFromManager called:', nicheId, circuit, confirmed);
            
            // Si pas encore confirm√©, demander confirmation en changeant le bouton
            if (!confirmed) {
                // Trouver le bouton et le changer en "Confirmer?"
                var btn = event.target;
                btn.textContent = '‚ö†Ô∏è S√ªr?';
                btn.style.background = '#dc2626';
                btn.onclick = function() { deleteNicheFromManager(nicheId, circuit, true); };
                // Reset apr√®s 3 secondes si pas cliqu√©
                setTimeout(function() {
                    btn.textContent = '‚úï';
                    btn.style.background = 'var(--red)';
                    btn.onclick = function() { deleteNicheFromManager(nicheId, circuit, false); };
                }, 3000);
                return;
            }
            
            var niches = circuit === 'atp' ? NICHES_ATP : NICHES_WTA;
            var found = false;
            for (var i = 0; i < niches.length; i++) {
                if (niches[i].id === nicheId) {
                    console.log('Found niche at index', i, '- removing');
                    niches.splice(i, 1);
                    found = true;
                    break;
                }
            }
            
            if (!found) {
                console.log('Niche not found in', circuit);
                var otherNiches = circuit === 'atp' ? NICHES_WTA : NICHES_ATP;
                for (var i = 0; i < otherNiches.length; i++) {
                    if (otherNiches[i].id === nicheId) {
                        console.log('Found in other circuit at index', i);
                        otherNiches.splice(i, 1);
                        found = true;
                        break;
                    }
                }
            }
            
            console.log('Refreshing UI...');
            syncAllNichesUI();
            console.log('Done - ATP niches:', NICHES_ATP.length, 'WTA niches:', NICHES_WTA.length);
        }

        // ==================== CONFIG ====================
        function updateConfig() {
            var el;
            el = document.getElementById('cfgBankroll'); if (el) el.value = state.initialBankroll;
            el = document.getElementById('cfgStake'); if (el) el.value = state.stake;
            el = document.getElementById('cfgGoal'); if (el) el.value = state.goal || 5000;
            el = document.getElementById('cfgGoalYear'); if (el) el.value = state.goalYear || 2025;
            safeText('calStake', state.stake);

            // Calcul dynamique des projections
            updateProjections();
        }
        
        function updateProjections() {
            // Section projection supprim√©e - fonction gard√©e pour compatibilit√©
            var projBetsEl = document.getElementById('projBets');
            if (!projBetsEl) return; // Section supprim√©e
            
            var atpStats = calcDynamicCalendarStats('atp');
            var wtaStats = calcDynamicCalendarStats('wta');
            var atpROI = calcDynamicROI('atp');
            var wtaROI = calcDynamicROI('wta');
            
            var totalNiches = atpStats.niches.length + wtaStats.niches.length;
            var totalAvgBets = atpStats.avgBets + wtaStats.avgBets;
            
            // ROI combin√©
            var combinedROI = 0;
            var combinedProfit = 0;
            var hasData = atpROI.hasData || wtaROI.hasData;
            
            if (hasData) {
                var totalDataBets = atpROI.bets + wtaROI.bets;
                if (totalDataBets > 0) {
                    combinedROI = ((atpROI.profit + wtaROI.profit) / totalDataBets * 100);
                    // Profit = Mis√© √ó ROI (utiliser totalAvgBets pour coh√©rence)
                    combinedProfit = totalAvgBets * state.stake * combinedROI / 100;
                }
            }
            
            var maxDD = Math.max(atpStats.avgBets, wtaStats.avgBets) * 0.4 * state.stake;
            
            projBetsEl.textContent = totalAvgBets > 0 ? '~' + totalAvgBets : '-';
            safeText('projROI', hasData ? '+' + combinedROI.toFixed(0) + '%' : '-');
            safeText('projProfit', hasData ? '+' + combinedProfit.toFixed(0) + '‚Ç¨' : '-');
            safeText('projDD', totalAvgBets > 0 ? '-' + maxDD.toFixed(0) + '‚Ç¨' : '-');
            safeText('projSource', totalNiches + ' niches actives' + (hasData ? ' ‚Ä¢ ROI calcul√© sur 3 ans' : ' ‚Ä¢ Charge CSV pour ROI'));
        }

        function saveGoal() {
            state.goal = parseFloat(document.getElementById('cfgGoal').value) || 5000;
            state.goalYear = parseInt(document.getElementById('cfgGoalYear').value) || 2025;
            saveState();
            updateGoal();
            alert('Objectif d√©fini !');
        }

        function saveConfig() {
            state.initialBankroll = parseFloat(document.getElementById('cfgBankroll').value) || 5000;
            state.stake = parseFloat(document.getElementById('cfgStake').value) || 250;
            if (state.history.length === 0 && state.pending.length === 0) {
                state.bankroll = state.initialBankroll;
            }
            saveState();
            updateConfig();
            renderCalendar();
            alert('Configuration sauvegard√©e !');
        }

        function resetAll() {
            if (!confirm('‚ö†Ô∏è Effacer TOUS les paris et r√©initialiser la bankroll ?')) return;
            state.pending = [];
            state.history = [];
            state.milestones = state.milestones || [];
            state.bankroll = state.initialBankroll;
            saveState();
        }

        // ==================== THEME ====================
        function toggleTheme() {
            document.body.classList.toggle('light-mode');
            localStorage.setItem('theme', document.body.classList.contains('light-mode') ? 'light' : 'dark');
        }
        if (localStorage.getItem('theme') === 'light') document.body.classList.add('light-mode');

        // ==================== WEEK ALERT ====================
        const TOURNAMENT_CALENDAR = [
            // ==================== JANVIER 2026 ====================
            // Semaine 1: 5-11 Jan
            { start: '01-05', end: '01-11', tournaments: [
                { name: 'Brisbane', circuit: 'atp', cat: 'ATP 250', surf: 'Hard' },
                { name: 'Brisbane', circuit: 'wta', cat: 'WTA 500', surf: 'Hard' },
                { name: 'Hong Kong', circuit: 'atp', cat: 'ATP 250', surf: 'Hard' },
                { name: 'Auckland', circuit: 'wta', cat: 'WTA 250', surf: 'Hard' },
            ]},
            // Semaine 2: 12-17 Jan
            { start: '01-12', end: '01-17', tournaments: [
                { name: 'Adelaide', circuit: 'atp', cat: 'ATP 250', surf: 'Hard' },
                { name: 'Adelaide', circuit: 'wta', cat: 'WTA 500', surf: 'Hard' },
                { name: 'Auckland', circuit: 'atp', cat: 'ATP 250', surf: 'Hard' },
                { name: 'Hobart', circuit: 'wta', cat: 'WTA 250', surf: 'Hard' },
            ]},
            // Semaine 3-4: 19 Jan - 1 F√©v - AUSTRALIAN OPEN
            { start: '01-19', end: '02-01', tournaments: [
                { name: 'AUSTRALIAN OPEN', circuit: 'both', cat: 'Grand Slam', surf: 'Hard' },
            ]},
            // ==================== F√âVRIER 2026 ====================
            // Semaine 5: 2-8 F√©v
            { start: '02-02', end: '02-08', tournaments: [
                { name: 'Montpellier', circuit: 'atp', cat: 'ATP 250', surf: 'Hard' },
                { name: 'Abu Dhabi', circuit: 'wta', cat: 'WTA 500', surf: 'Hard' },
                { name: 'Cluj-Napoca', circuit: 'wta', cat: 'WTA 500', surf: 'Hard' },
                { name: 'Ostrava', circuit: 'wta', cat: 'WTA 500', surf: 'Hard' },
            ]},
            // Semaine 6: 9-15 F√©v
            { start: '02-09', end: '02-15', tournaments: [
                { name: 'Dallas', circuit: 'atp', cat: 'ATP 500', surf: 'Hard' },
                { name: 'Rotterdam', circuit: 'atp', cat: 'ATP 500', surf: 'Hard' },
                { name: 'Buenos Aires', circuit: 'atp', cat: 'ATP 250', surf: 'Clay' },
                { name: 'Doha', circuit: 'wta', cat: 'WTA 1000', surf: 'Hard' },
            ]},
            // Semaine 7: 16-22 F√©v
            { start: '02-16', end: '02-22', tournaments: [
                { name: 'Doha', circuit: 'atp', cat: 'ATP 500', surf: 'Hard' },
                { name: 'Rio', circuit: 'atp', cat: 'ATP 500', surf: 'Clay' },
                { name: 'Delray Beach', circuit: 'atp', cat: 'ATP 250', surf: 'Hard' },
                { name: 'Dubai', circuit: 'wta', cat: 'WTA 1000', surf: 'Hard' },
            ]},
            // Semaine 8: 23 F√©v - 1 Mar
            { start: '02-23', end: '03-01', tournaments: [
                { name: 'Acapulco', circuit: 'atp', cat: 'ATP 500', surf: 'Hard' },
                { name: 'Dubai', circuit: 'atp', cat: 'ATP 500', surf: 'Hard' },
                { name: 'Santiago', circuit: 'atp', cat: 'ATP 250', surf: 'Clay' },
                { name: 'Merida', circuit: 'wta', cat: 'WTA 250', surf: 'Hard' },
                { name: 'Austin', circuit: 'wta', cat: 'WTA 250', surf: 'Hard' },
            ]},
            // ==================== MARS 2026 ====================
            // Semaine 9-10: 2-15 Mar - INDIAN WELLS
            { start: '03-02', end: '03-15', tournaments: [
                { name: 'INDIAN WELLS', circuit: 'both', cat: 'Masters 1000', surf: 'Hard' },
            ]},
            // Semaine 11-12: 16-29 Mar - MIAMI
            { start: '03-16', end: '03-29', tournaments: [
                { name: 'MIAMI', circuit: 'both', cat: 'Masters 1000', surf: 'Hard' },
            ]},
            // Semaine 13: 30 Mar - 5 Avr
            { start: '03-30', end: '04-05', tournaments: [
                { name: 'Marrakech', circuit: 'atp', cat: 'ATP 250', surf: 'Clay' },
                { name: 'Houston', circuit: 'atp', cat: 'ATP 250', surf: 'Clay' },
                { name: 'Bucharest', circuit: 'atp', cat: 'ATP 250', surf: 'Clay' },
                { name: 'Charleston', circuit: 'wta', cat: 'WTA 500', surf: 'Clay' },
                { name: 'Bogota', circuit: 'wta', cat: 'WTA 250', surf: 'Clay' },
            ]},
            // ==================== AVRIL 2026 ====================
            // Semaine 14: 5-12 Avr - MONTE-CARLO
            { start: '04-05', end: '04-12', tournaments: [
                { name: 'MONTE-CARLO', circuit: 'atp', cat: 'Masters 1000', surf: 'Clay' },
                { name: 'Linz', circuit: 'wta', cat: 'WTA 500', surf: 'Clay' },
            ]},
            // Semaine 15: 13-19 Avr
            { start: '04-13', end: '04-19', tournaments: [
                { name: 'Barcelona', circuit: 'atp', cat: 'ATP 500', surf: 'Clay' },
                { name: 'Munich', circuit: 'atp', cat: 'ATP 500', surf: 'Clay' },
                { name: 'Stuttgart', circuit: 'wta', cat: 'WTA 500', surf: 'Clay' },
                { name: 'Rouen', circuit: 'wta', cat: 'WTA 250', surf: 'Clay' },
            ]},
            // Semaine 16-17: 20 Avr - 3 Mai - MADRID
            { start: '04-20', end: '05-03', tournaments: [
                { name: 'MADRID', circuit: 'both', cat: 'Masters 1000', surf: 'Clay' },
            ]},
            // ==================== MAI 2026 ====================
            // Semaine 18-19: 4-17 Mai - ROME
            { start: '05-04', end: '05-17', tournaments: [
                { name: 'ROME', circuit: 'both', cat: 'Masters 1000', surf: 'Clay' },
            ]},
            // Semaine 20: 17-24 Mai
            { start: '05-17', end: '05-24', tournaments: [
                { name: 'Hamburg', circuit: 'atp', cat: 'ATP 500', surf: 'Clay' },
                { name: 'Geneva', circuit: 'atp', cat: 'ATP 250', surf: 'Clay' },
                { name: 'Strasbourg', circuit: 'wta', cat: 'WTA 250', surf: 'Clay' },
                { name: 'Rabat', circuit: 'wta', cat: 'WTA 500', surf: 'Clay' },
            ]},
            // Semaine 21-22: 25 Mai - 7 Juin - ROLAND GARROS
            { start: '05-25', end: '06-07', tournaments: [
                { name: 'ROLAND GARROS', circuit: 'both', cat: 'Grand Slam', surf: 'Clay' },
            ]},
            // ==================== JUIN 2026 - GRASS SEASON ====================
            // Semaine 23: 8-14 Juin
            { start: '06-08', end: '06-14', tournaments: [
                { name: 's-Hertogenbosch', circuit: 'atp', cat: 'ATP 250', surf: 'Grass' },
                { name: 'Stuttgart', circuit: 'atp', cat: 'ATP 250', surf: 'Grass' },
                { name: 'London', circuit: 'wta', cat: 'WTA 500', surf: 'Grass' },
                { name: 's-Hertogenbosch', circuit: 'wta', cat: 'WTA 250', surf: 'Grass' },
            ]},
            // Semaine 24: 15-21 Juin
            { start: '06-15', end: '06-21', tournaments: [
                { name: 'Halle', circuit: 'atp', cat: 'ATP 500', surf: 'Grass' },
                { name: "Queen's", circuit: 'atp', cat: 'ATP 500', surf: 'Grass' },
                { name: 'Berlin', circuit: 'wta', cat: 'WTA 500', surf: 'Grass' },
                { name: 'Nottingham', circuit: 'wta', cat: 'WTA 250', surf: 'Grass' },
            ]},
            // Semaine 25: 21-28 Juin
            { start: '06-21', end: '06-28', tournaments: [
                { name: 'Mallorca', circuit: 'atp', cat: 'ATP 250', surf: 'Grass' },
                { name: 'Eastbourne', circuit: 'atp', cat: 'ATP 250', surf: 'Grass' },
                { name: 'Eastbourne', circuit: 'wta', cat: 'WTA 500', surf: 'Grass' },
                { name: 'Bad Homburg', circuit: 'wta', cat: 'WTA 250', surf: 'Grass' },
            ]},
            // ==================== JUILLET 2026 ====================
            // Semaine 26-27: 29 Juin - 12 Juil - WIMBLEDON
            { start: '06-29', end: '07-12', tournaments: [
                { name: 'WIMBLEDON', circuit: 'both', cat: 'Grand Slam', surf: 'Grass' },
            ]},
            // Semaine 28: 13-19 Juil
            { start: '07-13', end: '07-19', tournaments: [
                { name: 'Bastad', circuit: 'atp', cat: 'ATP 250', surf: 'Clay' },
                { name: 'Gstaad', circuit: 'atp', cat: 'ATP 250', surf: 'Clay' },
                { name: 'Umag', circuit: 'atp', cat: 'ATP 250', surf: 'Clay' },
                { name: 'Iasi', circuit: 'wta', cat: 'WTA 250', surf: 'Clay' },
            ]},
            // Semaine 29: 20-26 Juil
            { start: '07-20', end: '07-26', tournaments: [
                { name: 'Kitzbuhel', circuit: 'atp', cat: 'ATP 250', surf: 'Clay' },
                { name: 'Estoril', circuit: 'atp', cat: 'ATP 250', surf: 'Clay' },
                { name: 'Hamburg', circuit: 'wta', cat: 'WTA 250', surf: 'Clay' },
                { name: 'Prague', circuit: 'wta', cat: 'WTA 250', surf: 'Hard' },
            ]},
            // Semaine 30: 27 Juil - 2 Ao√ªt
            { start: '07-27', end: '08-02', tournaments: [
                { name: 'Washington', circuit: 'atp', cat: 'ATP 500', surf: 'Hard' },
                { name: 'Los Cabos', circuit: 'atp', cat: 'ATP 250', surf: 'Hard' },
                { name: 'Washington', circuit: 'wta', cat: 'WTA 500', surf: 'Hard' },
            ]},
            // ==================== AO√õT 2026 ====================
            // Semaine 31-32: 2-10 Ao√ªt - MONTREAL (ATP) / TORONTO (WTA)
            { start: '08-02', end: '08-10', tournaments: [
                { name: 'MONTREAL', circuit: 'atp', cat: 'Masters 1000', surf: 'Hard' },
                { name: 'TORONTO', circuit: 'wta', cat: 'WTA 1000', surf: 'Hard' },
            ]},
            // Semaine 32-33: 10-17 Ao√ªt - CINCINNATI
            { start: '08-10', end: '08-17', tournaments: [
                { name: 'CINCINNATI', circuit: 'both', cat: 'Masters 1000', surf: 'Hard' },
            ]},
            // Semaine 34: 23-30 Ao√ªt
            { start: '08-23', end: '08-30', tournaments: [
                { name: 'Winston-Salem', circuit: 'atp', cat: 'ATP 250', surf: 'Hard' },
                { name: 'Monterrey', circuit: 'wta', cat: 'WTA 250', surf: 'Hard' },
                { name: 'Cleveland', circuit: 'wta', cat: 'WTA 250', surf: 'Hard' },
            ]},
            // Semaine 35-36: 31 Ao√ªt - 13 Sept - US OPEN
            { start: '08-31', end: '09-13', tournaments: [
                { name: 'US OPEN', circuit: 'both', cat: 'Grand Slam', surf: 'Hard' },
            ]},
            // ==================== SEPTEMBRE 2026 ====================
            // Semaine 37: 14-20 Sept
            { start: '09-14', end: '09-20', tournaments: [
                { name: 'Guadalajara', circuit: 'wta', cat: 'WTA 500', surf: 'Hard' },
                { name: 'S√£o Paulo', circuit: 'wta', cat: 'WTA 250', surf: 'Hard' },
            ]},
            // Semaine 38: 21-27 Sept
            { start: '09-21', end: '09-27', tournaments: [
                { name: 'Singapore', circuit: 'wta', cat: 'WTA 250', surf: 'Hard' },
                { name: 'Seoul', circuit: 'wta', cat: 'WTA 500', surf: 'Hard' },
            ]},
            // Semaine 38: 23-28 Sept (ATP Asie)
            { start: '09-23', end: '09-28', tournaments: [
                { name: 'Chengdu', circuit: 'atp', cat: 'ATP 250', surf: 'Hard' },
                { name: 'Hangzhou', circuit: 'atp', cat: 'ATP 250', surf: 'Hard' },
            ]},
            // Semaine 39: 28 Sept - 5 Oct
            { start: '09-28', end: '10-05', tournaments: [
                { name: 'BEIJING', circuit: 'wta', cat: 'WTA 1000', surf: 'Hard' },
            ]},
            // Semaine 39: 30 Sept - 5 Oct (ATP)
            { start: '09-30', end: '10-05', tournaments: [
                { name: 'Tokyo', circuit: 'atp', cat: 'ATP 500', surf: 'Hard' },
                { name: 'Beijing', circuit: 'atp', cat: 'ATP 500', surf: 'Hard' },
            ]},
            // ==================== OCTOBRE 2026 ====================
            // Semaine 40-41: 7-19 Oct - SHANGHAI
            { start: '10-07', end: '10-19', tournaments: [
                { name: 'SHANGHAI', circuit: 'atp', cat: 'Masters 1000', surf: 'Hard' },
            ]},
            // Semaine 41: 12-18 Oct - WUHAN
            { start: '10-12', end: '10-18', tournaments: [
                { name: 'WUHAN', circuit: 'wta', cat: 'WTA 1000', surf: 'Hard' },
            ]},
            // Semaine 42: 19-25 Oct
            { start: '10-19', end: '10-25', tournaments: [
                { name: 'Almaty', circuit: 'atp', cat: 'ATP 250', surf: 'Hard' },
                { name: 'Brussels', circuit: 'atp', cat: 'ATP 250', surf: 'Hard' },
                { name: 'Lyon', circuit: 'atp', cat: 'ATP 250', surf: 'Hard' },
                { name: 'Ningbo', circuit: 'wta', cat: 'WTA 250', surf: 'Hard' },
                { name: 'Osaka', circuit: 'wta', cat: 'WTA 250', surf: 'Hard' },
            ]},
            // Semaine 43: 26 Oct - 1 Nov
            { start: '10-26', end: '11-01', tournaments: [
                { name: 'Basel', circuit: 'atp', cat: 'ATP 500', surf: 'Hard' },
                { name: 'Vienna', circuit: 'atp', cat: 'ATP 500', surf: 'Hard' },
                { name: 'Tokyo', circuit: 'wta', cat: 'WTA 500', surf: 'Hard' },
                { name: 'Guangzhou', circuit: 'wta', cat: 'WTA 250', surf: 'Hard' },
            ]},
            // ==================== NOVEMBRE 2026 ====================
            // Semaine 44: 2-8 Nov - PARIS MASTERS
            { start: '11-02', end: '11-08', tournaments: [
                { name: 'PARIS MASTERS', circuit: 'atp', cat: 'Masters 1000', surf: 'Hard' },
                { name: 'Chennai', circuit: 'wta', cat: 'WTA 250', surf: 'Hard' },
                { name: 'Hong Kong', circuit: 'wta', cat: 'WTA 250', surf: 'Hard' },
                { name: 'Jiujiang', circuit: 'wta', cat: 'WTA 250', surf: 'Hard' },
            ]},
            // Semaine 45: 8-15 Nov
            { start: '11-08', end: '11-15', tournaments: [
                { name: 'Stockholm', circuit: 'atp', cat: 'ATP 250', surf: 'Hard' },
                { name: 'WTA FINALS', circuit: 'wta', cat: 'WTA Finals', surf: 'Hard' },
            ]},
            // Semaine 46: 15-22 Nov - ATP FINALS
            { start: '11-15', end: '11-22', tournaments: [
                { name: 'ATP FINALS', circuit: 'atp', cat: 'ATP Finals', surf: 'Hard' },
            ]},
        ];

        function getMatchingNichesForTournament(tournament) {
            // Trouver les niches actives qui matchent ce tournoi
            var matchingNiches = [];
            var circuits = tournament.circuit === 'both' ? ['atp', 'wta'] : [tournament.circuit];
            
            console.log('Checking tournament:', tournament.name, '| cat:', tournament.cat, '| surf:', tournament.surf, '| circuit:', tournament.circuit);
            
            circuits.forEach(function(circuit) {
                var niches = circuit === 'atp' ? NICHES_ATP : NICHES_WTA;
                console.log('  Circuit', circuit, '- checking', niches.length, 'niches');
                
                niches.forEach(function(niche) {
                    if (!niche.on) {
                        // console.log('    Niche OFF:', niche.name);
                        return;
                    }
                    if (niche.cat !== tournament.cat) {
                        // console.log('    Cat mismatch:', niche.cat, '!=', tournament.cat);
                        return;
                    }
                    if (niche.surf !== tournament.surf) {
                        // console.log('    Surf mismatch:', niche.surf, '!=', tournament.surf);
                        return;
                    }
                    
                    console.log('    ‚úÖ MATCH:', niche.name);
                    // Cette niche matche
                    matchingNiches.push({
                        circuit: circuit,
                        strat: niche.strat,
                        rounds: niche.rounds.slice(), // Copie
                        min: niche.min,
                        max: niche.max,
                        niche: niche
                    });
                });
            });
            
            // Fusionner les niches qui se chevauchent (m√™me strat, m√™me cotes, rounds inclus)
            // Ex: F @2-2.5 et SF+F @2-2.5 ‚Üí garder seulement SF+F @2-2.5
            var merged = [];
            for (var i = 0; i < matchingNiches.length; i++) {
                var n1 = matchingNiches[i];
                var isSubset = false;
                
                for (var j = 0; j < matchingNiches.length; j++) {
                    if (i === j) continue;
                    var n2 = matchingNiches[j];
                    
                    // M√™me circuit, strat, et cotes ?
                    if (n1.circuit !== n2.circuit) continue;
                    if (n1.strat !== n2.strat) continue;
                    if (Math.abs(n1.min - n2.min) > 0.1 || Math.abs(n1.max - n2.max) > 0.1) continue;
                    
                    // n1 est-il un sous-ensemble de n2 ?
                    var allRoundsIn = true;
                    for (var r = 0; r < n1.rounds.length; r++) {
                        if (n2.rounds.indexOf(n1.rounds[r]) < 0) {
                            allRoundsIn = false;
                            break;
                        }
                    }
                    
                    // Si n1 est inclus dans n2 et n2 a plus de rounds, n1 est un subset
                    if (allRoundsIn && n2.rounds.length > n1.rounds.length) {
                        isSubset = true;
                        break;
                    }
                }
                
                if (!isSubset) {
                    var label = (n1.strat === 'underdog' ? 'UND' : 'FAV') + ' ' + n1.rounds.join('+') + ' @' + n1.min + '-' + n1.max;
                    merged.push({
                        circuit: n1.circuit,
                        label: label,
                        niche: n1.niche
                    });
                }
            }
            
            return merged;
        }
        
        function formatNichesForDisplay(matchingNiches) {
            if (matchingNiches.length === 0) return null;
            
            // Grouper par circuit
            var atpNiches = matchingNiches.filter(n => n.circuit === 'atp');
            var wtaNiches = matchingNiches.filter(n => n.circuit === 'wta');
            
            function formatWithCoef(n) {
                var label = n.label;
                var coef = n.niche && n.niche.stakeCoef ? n.niche.stakeCoef : 1.0;
                if (coef !== 1.0) {
                    label += ' <span style="color:var(--yellow);font-size:.7rem">√ó' + coef.toFixed(1) + '</span>';
                }
                return label;
            }
            
            var parts = [];
            if (atpNiches.length > 0) {
                parts.push('üü¢ ' + atpNiches.map(formatWithCoef).join(', '));
            }
            if (wtaNiches.length > 0) {
                parts.push('ü©∑ ' + wtaNiches.map(formatWithCoef).join(', '));
            }
            
            return parts.join(' | ');
        }

        function checkWeekTournaments() {
            const now = new Date();
            const currentYear = now.getFullYear();
            
            // Trouver les tournois en cours avec des niches actives
            const activeTournaments = [];
            
            TOURNAMENT_CALENDAR.forEach(period => {
                const [startMonth, startDay] = period.start.split('-').map(Number);
                const [endMonth, endDay] = period.end.split('-').map(Number);
                
                // G√©rer le cas o√π le tournoi chevauche l'ann√©e (ex: 12-29 √† 01-05)
                let startDate, endDate;
                if (startMonth > endMonth) {
                    // Tournoi √† cheval sur l'ann√©e
                    if (now.getMonth() + 1 >= startMonth) {
                        startDate = new Date(currentYear, startMonth - 1, startDay);
                        endDate = new Date(currentYear + 1, endMonth - 1, endDay);
                    } else {
                        startDate = new Date(currentYear - 1, startMonth - 1, startDay);
                        endDate = new Date(currentYear, endMonth - 1, endDay);
                    }
                } else {
                    startDate = new Date(currentYear, startMonth - 1, startDay);
                    endDate = new Date(currentYear, endMonth - 1, endDay);
                }
                
                // V√©rifier si on est dans la p√©riode
                if (now >= startDate && now <= endDate) {
                    period.tournaments.forEach(t => {
                        var matchingNiches = getMatchingNichesForTournament(t);
                        if (matchingNiches.length > 0) {
                            var tourWithNiches = Object.assign({}, t, {
                                matchingNiches: matchingNiches,
                                nicheDisplay: formatNichesForDisplay(matchingNiches)
                            });
                            activeTournaments.push(tourWithNiches);
                        }
                    });
                }
            });
            
            if (activeTournaments.length > 0) {
                // Construire l'affichage
                const html = activeTournaments.map(t => {
                    const circuitIcon = t.circuit === 'atp' ? 'üü¢' : (t.circuit === 'wta' ? 'ü©∑' : 'üü¢ü©∑');
                    const isHot = t.matchingNiches.length >= 2 ? 'font-weight:700;' : '';
                    
                    return `<span style="display:inline-flex;align-items:center;gap:.3rem;margin-right:1rem;${isHot}">
                        ${circuitIcon} <b>${t.name}</b> 
                        <span style="color:var(--green);font-weight:600;font-size:.75rem">${t.nicheDisplay}</span>
                    </span>`;
                }).join('');
                
                safeHTML('weekTournaments', html);
                var alertEl = document.getElementById('weekAlert');
                var titleEl = document.getElementById('weekAlertTitle');
                if (alertEl) alertEl.style.display = 'flex';
                if (titleEl) titleEl.textContent = 'üî¥ EN COURS (' + activeTournaments.length + ' opportunit√©s) :';
                
                // Mettre √† jour le panneau d√©taill√©
                updateTodayPanel();
            } else {
                // Pas de tournoi en cours avec niches actives - afficher les prochains
                showUpcomingTournaments();
            }
        }

        function showUpcomingTournaments() {
            const now = new Date();
            const currentYear = now.getFullYear();
            
            // Trouver les prochains tournois avec niches actives
            let allUpcoming = [];
            
            TOURNAMENT_CALENDAR.forEach(period => {
                const [startMonth, startDay] = period.start.split('-').map(Number);
                let startDate = new Date(currentYear, startMonth - 1, startDay);
                
                // Si la date est pass√©e, regarder l'ann√©e prochaine
                if (startDate < now) {
                    startDate = new Date(currentYear + 1, startMonth - 1, startDay);
                }
                
                const daysUntil = Math.floor((startDate - now) / (1000 * 60 * 60 * 24));
                
                if (daysUntil >= 0 && daysUntil <= 30) {
                    period.tournaments.forEach(t => {
                        var matchingNiches = getMatchingNichesForTournament(t);
                        if (matchingNiches.length > 0) {
                            var tourWithNiches = Object.assign({}, t, {
                                daysUntil: daysUntil,
                                matchingNiches: matchingNiches,
                                nicheDisplay: formatNichesForDisplay(matchingNiches)
                            });
                            allUpcoming.push(tourWithNiches);
                        }
                    });
                }
            });
            
            // Trier par date
            allUpcoming.sort((a, b) => a.daysUntil - b.daysUntil);
            
            if (allUpcoming.length > 0) {
                const minDays = allUpcoming[0].daysUntil;
                const soonTournaments = allUpcoming.filter(t => t.daysUntil <= minDays + 7).slice(0, 4);
                
                const html = soonTournaments.map(t => {
                    const circuitIcon = t.circuit === 'atp' ? 'üü¢' : (t.circuit === 'wta' ? 'ü©∑' : 'üü¢ü©∑');
                    return `<span style="margin-right:.75rem">${circuitIcon} <b>${t.name}</b> <span style="color:var(--green);font-size:.7rem">${t.nicheDisplay}</span></span>`;
                }).join('');
                
                var weekTourEl = document.getElementById('weekTournaments');
                var alertEl = document.getElementById('weekAlert');
                var titleEl = document.getElementById('weekAlertTitle');
                if (weekTourEl) weekTourEl.innerHTML = html;
                if (alertEl) alertEl.style.display = 'flex';
                if (titleEl) titleEl.textContent = `üìÖ Dans ${minDays} jour${minDays > 1 ? 's' : ''} (${soonTournaments.length} opportunit√©s) :`;
            } else {
                // Aucun tournoi avec niches dans les 30 prochains jours
                var alertEl = document.getElementById('weekAlert');
                if (alertEl) alertEl.style.display = 'none';
            }
            
            // Mettre √† jour le panneau d√©taill√©
            updateTodayPanel();
        }
        
        function updateTodayPanel() {
            const now = new Date();
            const currentYear = now.getFullYear();
            
            // R√©cup√©rer tous les tournois en cours avec niches
            const activeTournaments = [];
            
            TOURNAMENT_CALENDAR.forEach(period => {
                const [startMonth, startDay] = period.start.split('-').map(Number);
                const [endMonth, endDay] = period.end.split('-').map(Number);
                
                let startDate, endDate;
                if (startMonth > endMonth) {
                    if (now.getMonth() + 1 >= startMonth) {
                        startDate = new Date(currentYear, startMonth - 1, startDay);
                        endDate = new Date(currentYear + 1, endMonth - 1, endDay);
                    } else {
                        startDate = new Date(currentYear - 1, startMonth - 1, startDay);
                        endDate = new Date(currentYear, endMonth - 1, endDay);
                    }
                } else {
                    startDate = new Date(currentYear, startMonth - 1, startDay);
                    endDate = new Date(currentYear, endMonth - 1, endDay);
                }
                
                if (now >= startDate && now <= endDate) {
                    period.tournaments.forEach(t => {
                        var matchingNiches = getMatchingNichesForTournament(t);
                        if (matchingNiches.length > 0) {
                            activeTournaments.push({
                                name: t.name,
                                circuit: t.circuit,
                                cat: t.cat,
                                surface: t.surface,
                                matchingNiches: matchingNiches
                            });
                        }
                    });
                }
            });
            
            // Panneau d√©taill√© supprim√© - le bandeau suffit
        }

        // ==================== STREAKS ====================
        function getStreaks() {
            if (state.history.length === 0) return { current: 0, currentType: null, bestWin: 0, worstLoss: 0 };
            let bestWin = 0, worstLoss = 0, streak = 0, lastWon = null;
            const sorted = [...state.history].reverse();
            for (const bet of sorted) {
                if (bet.won === lastWon || lastWon === null) { streak++; }
                else { if (lastWon) bestWin = Math.max(bestWin, streak); else worstLoss = Math.max(worstLoss, streak); streak = 1; }
                lastWon = bet.won;
            }
            if (lastWon) bestWin = Math.max(bestWin, streak); else worstLoss = Math.max(worstLoss, streak);
            return { current: streak, currentType: lastWon, bestWin, worstLoss };
        }

        function updateStreaks() {
            const s = getStreaks();
            const el = document.getElementById('currentStreak');
            if (el) {
                var numEl = el.querySelector('.num');
                if (numEl) numEl.textContent = s.current;
                el.className = 'streak ' + (s.currentType ? 'win' : (s.currentType === false ? 'loss' : ''));
            }
            var bestEl = document.getElementById('bestWinStreak');
            var worstEl = document.getElementById('worstLossStreak');
            if (bestEl) bestEl.textContent = s.bestWin;
            if (worstEl) worstEl.textContent = s.worstLoss;
        }

        // ==================== GOAL ====================
        function updateGoal() {
            // Fonction gard√©e pour compatibilit√© mais ne fait rien si l'objectif est retir√©
            var goalYearEl = document.getElementById('goalYear');
            if (!goalYearEl) return;
            
            const goal = state.goal || 5000;
            const goalYear = state.goalYear || new Date().getFullYear();
            const yearProfit = state.history
                .filter(b => new Date(b.resolvedDate || b.date).getFullYear() === goalYear)
                .reduce((s, b) => s + b.pnl, 0);
            const pct = goal > 0 ? Math.min(100, Math.max(0, (yearProfit / goal) * 100)) : 0;
            
            goalYearEl.textContent = goalYear;
            var goalProgressEl = document.getElementById('goalProgress');
            if (goalProgressEl) goalProgressEl.textContent = yearProfit.toFixed(0) + '‚Ç¨ / ' + goal + '‚Ç¨';
            var goalFillEl = document.getElementById('goalFill');
            if (goalFillEl) goalFillEl.style.width = pct + '%';
            var goalPercentEl = document.getElementById('goalPercent');
            if (goalPercentEl) goalPercentEl.textContent = pct.toFixed(0) + '%';
        }

        // ==================== QUICK CHECK ====================
        // ==================== MILESTONES ====================
        function checkMilestones() {
            if (!state.milestones) state.milestones = [];
            const profit = state.history.reduce((s, b) => s + b.pnl, 0);
            const milestones = [500, 1000, 2500, 5000, 10000];
            for (const m of milestones) {
                if (profit >= m && !state.milestones.includes(m)) {
                    state.milestones.push(m);
                    showCelebration('Tu as atteint +' + m + '‚Ç¨ de profit ! üöÄ');
                    saveState();
                    break;
                }
            }
        }

        function showCelebration(text) {
            safeText('celebrationText', text);
            safeDisplay('celebrationOverlay', true);
            safeDisplay('celebrationModal', true);
        }

        function closeCelebration() {
            safeDisplay('celebrationOverlay', false);
            safeDisplay('celebrationModal', false);
        }

        // ==================== EXPORT CSV ====================
        function exportBetsCSV() {
            const allBets = [...state.history, ...state.pending];
            if (allBets.length === 0) { alert('Aucun pari √† exporter'); return; }
            const csv = 'date,circuit,tournament,round,bet_on,vs,odds,stake,status,pnl,niche\n' + 
                allBets.map(b => [b.date, b.circuit, b.tournament, b.round, b.betOn, b.vs, b.odds, b.stake, 
                    b.won === undefined ? 'pending' : (b.won ? 'won' : 'lost'), b.pnl || 0, b.niche].join(',')).join('\n');
            const a = document.createElement('a');
            a.href = URL.createObjectURL(new Blob([csv], { type: 'text/csv' }));
            a.download = 'mes_paris_tennis_' + new Date().toISOString().split('T')[0] + '.csv';
            a.click();
        }

        // ==================== STATS AVANCEES ====================
        let bankrollChart = null;
        let pieChart = null;

        function renderStats() {
            const history = state.history;
            
            if (history.length === 0) {
                safeDisplay('statsEmpty', true);
                safeDisplay('statsContent', false);
                return;
            }
            
            safeDisplay('statsEmpty', false);
            safeDisplay('statsContent', true);
            
            const stake = state.stake;
            
            // Stats par circuit
            const atpBets = history.filter(b => b.circuit === 'atp');
            const wtaBets = history.filter(b => b.circuit === 'wta');
            const atpWins = atpBets.filter(b => b.won).length;
            const wtaWins = wtaBets.filter(b => b.won).length;
            const atpProfit = atpBets.reduce((s, b) => s + (b.pnl || 0), 0);
            const wtaProfit = wtaBets.reduce((s, b) => s + (b.pnl || 0), 0);
            const totalWins = history.filter(b => b.won).length;
            const totalProfit = history.reduce((s, b) => s + (b.pnl || 0), 0);
            
            safeText('statAtpBets', atpBets.length);
            safeText('statAtpWinrate', atpBets.length > 0 ? (atpWins / atpBets.length * 100).toFixed(0) + '%' : '-');
            safeText('statAtpProfit', (atpProfit >= 0 ? '+' : '') + atpProfit.toFixed(0) + '‚Ç¨');
            document.getElementById('statAtpProfit').className = 'val ' + (atpProfit >= 0 ? 'pos' : 'neg');
            
            safeText('statWtaBets', wtaBets.length);
            safeText('statWtaWinrate', wtaBets.length > 0 ? (wtaWins / wtaBets.length * 100).toFixed(0) + '%' : '-');
            safeText('statWtaProfit', (wtaProfit >= 0 ? '+' : '') + wtaProfit.toFixed(0) + '‚Ç¨');
            document.getElementById('statWtaProfit').className = 'val ' + (wtaProfit >= 0 ? 'pos' : 'neg');
            
            safeText('statTotalBets', history.length);
            safeText('statTotalWinrate', history.length > 0 ? (totalWins / history.length * 100).toFixed(0) + '%' : '-');
            safeText('statTotalProfit', (totalProfit >= 0 ? '+' : '') + totalProfit.toFixed(0) + '‚Ç¨');
            document.getElementById('statTotalProfit').className = 'val ' + (totalProfit >= 0 ? 'pos' : 'neg');
            
            // Graphique √©volution bankroll
            const sorted = [...history].sort((a, b) => (a.resolvedDate || a.date).localeCompare(b.resolvedDate || b.date));
            let cum = state.initialBankroll;
            const bankrollHist = [cum];
            sorted.forEach(b => { cum += (b.pnl || 0); bankrollHist.push(cum); });
            
            const ctx = document.getElementById('bankrollChart').getContext('2d');
            if (bankrollChart) bankrollChart.destroy();
            bankrollChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: bankrollHist.map((_, i) => i),
                    datasets: [{
                        data: bankrollHist,
                        borderColor: '#4d9fff',
                        backgroundColor: 'rgba(77,159,255,.15)',
                        fill: true,
                        tension: 0.3,
                        pointRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        x: { display: false },
                        y: { grid: { color: 'rgba(255,255,255,.05)' }, ticks: { color: '#666', callback: v => v + '‚Ç¨' } }
                    }
                }
            });
            
            // Camembert ATP/WTA
            const ctxPie = document.getElementById('pieChart').getContext('2d');
            if (pieChart) pieChart.destroy();
            pieChart = new Chart(ctxPie, {
                type: 'doughnut',
                data: {
                    labels: ['ATP', 'WTA'],
                    datasets: [{
                        data: [atpBets.length, wtaBets.length],
                        backgroundColor: ['#22c55e', '#ec4899'],
                        borderWidth: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { position: 'bottom', labels: { color: '#999', font: { size: 11 } } }
                    }
                }
            });
            
            // Meilleur tournoi
            const byTournament = {};
            history.forEach(b => {
                const key = b.tournament;
                if (!byTournament[key]) byTournament[key] = { bets: 0, profit: 0 };
                byTournament[key].bets++;
                byTournament[key].profit += (b.pnl || 0);
            });
            const bestTournament = Object.entries(byTournament).sort((a, b) => b[1].profit - a[1].profit)[0];
            if (bestTournament) {
                safeText('statBestTournament', bestTournament[0]);
                safeText('statBestTournamentDetail', bestTournament[1].bets + ' paris ‚Ä¢ ' + (bestTournament[1].profit >= 0 ? '+' : '') + bestTournament[1].profit.toFixed(0) + '‚Ç¨');
            }
            
            // Meilleur round
            const byRound = {};
            history.forEach(b => {
                const key = b.round;
                if (!byRound[key]) byRound[key] = { bets: 0, profit: 0 };
                byRound[key].bets++;
                byRound[key].profit += (b.pnl || 0);
            });
            const bestRound = Object.entries(byRound).sort((a, b) => b[1].profit - a[1].profit)[0];
            if (bestRound) {
                safeText('statBestRound', bestRound[0]);
                safeText('statBestRoundDetail', bestRound[1].bets + ' paris ‚Ä¢ ' + (bestRound[1].profit >= 0 ? '+' : '') + bestRound[1].profit.toFixed(0) + '‚Ç¨');
            }
            
            // Meilleure surface (si disponible)
            const bySurface = {};
            history.forEach(b => {
                const key = b.surface || 'N/A';
                if (!bySurface[key]) bySurface[key] = { bets: 0, profit: 0 };
                bySurface[key].bets++;
                bySurface[key].profit += (b.pnl || 0);
            });
            const bestSurface = Object.entries(bySurface).sort((a, b) => b[1].profit - a[1].profit)[0];
            if (bestSurface) {
                safeText('statBestSurface', bestSurface[0]);
                safeText('statBestSurfaceDetail', bestSurface[1].bets + ' paris ‚Ä¢ ' + (bestSurface[1].profit >= 0 ? '+' : '') + bestSurface[1].profit.toFixed(0) + '‚Ç¨');
            }
            
            // Meilleur jour de la semaine
            const days = ['Dimanche', 'Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi'];
            const byDay = {};
            history.forEach(b => {
                const d = new Date(b.date);
                const dayName = days[d.getDay()];
                if (!byDay[dayName]) byDay[dayName] = { bets: 0, profit: 0 };
                byDay[dayName].bets++;
                byDay[dayName].profit += (b.pnl || 0);
            });
            const bestDay = Object.entries(byDay).sort((a, b) => b[1].profit - a[1].profit)[0];
            if (bestDay) {
                safeText('statBestDay', bestDay[0]);
                safeText('statBestDayDetail', bestDay[1].bets + ' paris ‚Ä¢ ' + (bestDay[1].profit >= 0 ? '+' : '') + bestDay[1].profit.toFixed(0) + '‚Ç¨');
            }
            
            // Plus gros gain / perte
            const sortedByPnl = [...history].sort((a, b) => (b.pnl || 0) - (a.pnl || 0));
            const biggestWin = sortedByPnl.find(b => b.won);
            const biggestLoss = sortedByPnl.reverse().find(b => !b.won);
            
            if (biggestWin) {
                safeText('statBiggestWin', '+' + (biggestWin.pnl || 0).toFixed(0) + '‚Ç¨');
                safeText('statBiggestWinDetail', biggestWin.betOn + ' @' + biggestWin.odds + ' ‚Ä¢ ' + biggestWin.tournament);
            }
            if (biggestLoss) {
                safeText('statBiggestLoss', (biggestLoss.pnl || 0).toFixed(0) + '‚Ç¨');
                safeText('statBiggestLossDetail', biggestLoss.betOn + ' @' + biggestLoss.odds + ' ‚Ä¢ ' + biggestLoss.tournament);
            }
            
            // Cotes moyennes
            const wins = history.filter(b => b.won);
            const losses = history.filter(b => !b.won);
            
            if (wins.length > 0) {
                const avgWinOdds = wins.reduce((s, b) => s + b.odds, 0) / wins.length;
                const minWinOdds = Math.min(...wins.map(b => b.odds));
                const maxWinOdds = Math.max(...wins.map(b => b.odds));
                safeText('statAvgWinOdds', avgWinOdds.toFixed(2));
                safeText('statMinWinOdds', minWinOdds.toFixed(2));
                safeText('statMaxWinOdds', maxWinOdds.toFixed(2));
            }
            if (losses.length > 0) {
                const avgLossOdds = losses.reduce((s, b) => s + b.odds, 0) / losses.length;
                safeText('statAvgLossOdds', avgLossOdds.toFixed(2));
            }
            
            // Performance par niche
            const byNiche = {};
            history.forEach(b => {
                const key = b.niche || 'N/A';
                if (!byNiche[key]) byNiche[key] = { bets: 0, wins: 0, profit: 0 };
                byNiche[key].bets++;
                if (b.won) byNiche[key].wins++;
                byNiche[key].profit += (b.pnl || 0);
            });
            
            document.getElementById('statNicheTable').innerHTML = Object.entries(byNiche)
                .sort((a, b) => b[1].profit - a[1].profit)
                .map(([niche, stats]) => {
                    const roi = stats.bets > 0 ? (stats.profit / stats.bets * 100) : 0;
                    const winrate = stats.bets > 0 ? (stats.wins / stats.bets * 100) : 0;
                    return `<tr>
                        <td>${niche}</td>
                        <td>${stats.bets}</td>
                        <td>${stats.wins}</td>
                        <td>${winrate.toFixed(0)}%</td>
                        <td class="${stats.profit >= 0 ? 'pos' : 'neg'}">${stats.profit >= 0 ? '+' : ''}${stats.profit.toFixed(0)}‚Ç¨</td>
                        <td class="${roi >= 0 ? 'pos' : 'neg'}">${roi >= 0 ? '+' : ''}${roi.toFixed(1)}%</td>
                    </tr>`;
                }).join('');
        }

        // ==================== NOTIFICATIONS ====================
        // ==================== API FUNCTIONS ====================
        
        // Recherche un joueur sur Flashscore
        async function searchPlayer(playerName) {
            try {
                const url = `https://${FLASHSCORE_HOST}/v1/search/multi-search?locale=en_INT&query=${encodeURIComponent(playerName)}`;
                const response = await fetch(CORS_PROXY + encodeURIComponent(url), {
                    method: 'GET',
                    headers: {
                        'X-RapidAPI-Key': RAPIDAPI_KEY,
                        'X-RapidAPI-Host': FLASHSCORE_HOST
                    }
                });
                const data = await response.json();
                // Chercher dans les r√©sultats tennis
                if (data && data.length > 0) {
                    const tennisPlayer = data.find(r => r.SPORT_ID === 2); // 2 = Tennis
                    return tennisPlayer || null;
                }
                return null;
            } catch (err) {
                console.error('Erreur recherche joueur:', err);
                return null;
            }
        }

        // R√©cup√®re les derniers matchs d'un joueur
        async function getPlayerMatches(playerId) {
            try {
                const url = `https://${FLASHSCORE_HOST}/v1/teams/results?team_id=${playerId}&locale=en_INT`;
                const response = await fetch(CORS_PROXY + encodeURIComponent(url), {
                    method: 'GET',
                    headers: {
                        'X-RapidAPI-Key': RAPIDAPI_KEY,
                        'X-RapidAPI-Host': FLASHSCORE_HOST
                    }
                });
                return await response.json();
            } catch (err) {
                console.error('Erreur matchs joueur:', err);
                return null;
            }
        }

        // R√©cup√®re les matchs tennis du jour avec r√©sultats
        async function getTodayTennisResults() {
            try {
                const url = `https://${FLASHSCORE_HOST}/v1/events/list?locale=en_INT&sport_id=2&indent_days=0`;
                const response = await fetch(CORS_PROXY + encodeURIComponent(url), {
                    method: 'GET',
                    headers: {
                        'X-RapidAPI-Key': RAPIDAPI_KEY,
                        'X-RapidAPI-Host': FLASHSCORE_HOST
                    }
                });
                return await response.json();
            } catch (err) {
                console.error('Erreur matchs du jour:', err);
                return null;
            }
        }

        // Auto-r√©solution de tous les paris en attente
        async function autoResolveAll() {
            if (state.pending.length === 0) {
                alert('Aucun pari en attente √† r√©soudre');
                return;
            }

            const statusDiv = document.getElementById('autoResolveStatus');
            const btn = document.getElementById('btnAutoResolve');
            btn.disabled = true;
            btn.textContent = '‚è≥ Recherche...';
            statusDiv.style.display = 'block';
            statusDiv.style.background = 'rgba(77,159,255,.15)';
            statusDiv.style.color = 'var(--blue)';
            statusDiv.innerHTML = 'üîç Recherche des r√©sultats en cours...';

            let resolved = 0;
            let notFound = 0;
            const errors = [];

            for (const bet of [...state.pending]) {
                statusDiv.innerHTML = `üîç Recherche: ${bet.betOn} vs ${bet.vs}...`;
                
                try {
                    // Chercher le joueur sur qui on a pari√©
                    const player = await searchPlayer(bet.betOn);
                    
                    if (player && player.ID) {
                        // R√©cup√©rer ses derniers matchs
                        const matches = await getPlayerMatches(player.ID);
                        
                        if (matches && matches.EVENTS) {
                            // Chercher le match correspondant
                            const match = matches.EVENTS.find(m => {
                                const opponent = m.HOME_PARTICIPANT_NAME_ONE === bet.betOn ? 
                                    m.AWAY_PARTICIPANT_NAME_ONE : m.HOME_PARTICIPANT_NAME_ONE;
                                // V√©rifier si l'adversaire correspond (approximatif)
                                return opponent && (
                                    opponent.toLowerCase().includes(bet.vs.split(' ')[0].toLowerCase()) ||
                                    bet.vs.toLowerCase().includes(opponent.split(' ')[0].toLowerCase())
                                );
                            });

                            if (match && match.STAGE === 'FINISHED') {
                                // D√©terminer le gagnant
                                const homeWon = parseInt(match.HOME_SCORE_CURRENT) > parseInt(match.AWAY_SCORE_CURRENT);
                                const betOnIsHome = match.HOME_PARTICIPANT_NAME_ONE.toLowerCase().includes(bet.betOn.split(' ')[0].toLowerCase());
                                const won = (betOnIsHome && homeWon) || (!betOnIsHome && !homeWon);
                                
                                // R√©soudre le pari
                                resolveBetAuto(bet.id, won);
                                resolved++;
                                continue;
                            }
                        }
                    }
                    notFound++;
                } catch (err) {
                    console.error('Erreur r√©solution:', bet.betOn, err);
                    errors.push(bet.betOn);
                }
                
                // Petite pause pour √©viter le rate limit
                await new Promise(r => setTimeout(r, 500));
            }

            btn.disabled = false;
            btn.textContent = 'üîÑ R√©soudre auto';

            if (resolved > 0) {
                statusDiv.style.background = 'rgba(34,197,94,.15)';
                statusDiv.style.color = 'var(--green)';
                statusDiv.innerHTML = `‚úÖ ${resolved} pari(s) r√©solu(s) automatiquement!` + 
                    (notFound > 0 ? ` | ‚ö†Ô∏è ${notFound} non trouv√©(s)` : '');
            } else {
                statusDiv.style.background = 'rgba(234,179,8,.15)';
                statusDiv.style.color = 'var(--yellow)';
                statusDiv.innerHTML = `‚ö†Ô∏è Aucun r√©sultat trouv√©. Les matchs sont peut-√™tre en cours ou pas encore jou√©s.`;
            }

            setTimeout(() => { statusDiv.style.display = 'none'; }, 5000);
        }

        function resolveBetAuto(id, won) {
            const bet = state.pending.find(b => b.id === id);
            if (!bet) return;
            
            bet.won = won;
            bet.pnl = won ? (bet.odds - 1) * bet.stake : -bet.stake;
            bet.resolvedDate = new Date().toISOString().split('T')[0];
            state.bankroll += bet.pnl;
            state.history.unshift(bet);
            state.pending = state.pending.filter(b => b.id !== id);
            saveState();
        }

        // ==================== PINNACLE ODDS ====================
        
        // Mapping des tournois vers cat√©gories
        const TOURNAMENT_CATEGORIES = {
            // ATP
            'australian open': { cat: 'Grand Slam', surf: 'Hard' },
            'roland garros': { cat: 'Grand Slam', surf: 'Clay' },
            'french open': { cat: 'Grand Slam', surf: 'Clay' },
            'wimbledon': { cat: 'Grand Slam', surf: 'Grass' },
            'us open': { cat: 'Grand Slam', surf: 'Hard' },
            'indian wells': { cat: 'Masters 1000', surf: 'Hard' },
            'miami': { cat: 'Masters 1000', surf: 'Hard' },
            'monte carlo': { cat: 'Masters 1000', surf: 'Clay' },
            'madrid': { cat: 'Masters 1000', surf: 'Clay' },
            'rome': { cat: 'Masters 1000', surf: 'Clay' },
            'canada': { cat: 'Masters 1000', surf: 'Hard' },
            'toronto': { cat: 'Masters 1000', surf: 'Hard' },
            'montreal': { cat: 'Masters 1000', surf: 'Hard' },
            'cincinnati': { cat: 'Masters 1000', surf: 'Hard' },
            'shanghai': { cat: 'Masters 1000', surf: 'Hard' },
            'paris': { cat: 'Masters 1000', surf: 'Hard' },
            'barcelona': { cat: 'ATP 500', surf: 'Clay' },
            'hamburg': { cat: 'ATP 500', surf: 'Clay' },
            'rio': { cat: 'ATP 500', surf: 'Clay' },
            'acapulco': { cat: 'ATP 500', surf: 'Hard' },
            'dubai': { cat: 'ATP 500', surf: 'Hard' },
            'rotterdam': { cat: 'ATP 500', surf: 'Hard' },
            'halle': { cat: 'ATP 500', surf: 'Grass' },
            'queen': { cat: 'ATP 500', surf: 'Grass' },
            'queens': { cat: 'ATP 500', surf: 'Grass' },
            'vienna': { cat: 'ATP 500', surf: 'Hard' },
            'basel': { cat: 'ATP 500', surf: 'Hard' },
            'beijing': { cat: 'ATP 500', surf: 'Hard' },
            'tokyo': { cat: 'ATP 500', surf: 'Hard' },
            'washington': { cat: 'ATP 500', surf: 'Hard' },
        };

        // R√©cup√®re les cotes tennis - VERSION MANUELLE
        // L'utilisateur peut coller du JSON ou utiliser les donn√©es de test
        let cachedMatches = null;
        
        async function getPinnacleOdds() {
            // Si on a des donn√©es en cache, les utiliser
            if (cachedMatches) {
                return { events: cachedMatches };
            }
            
            // Sinon, utiliser les donn√©es de d√©monstration
            // (√† remplacer par de vraies donn√©es coll√©es par l'utilisateur)
            return { events: [] };
        }

        // Fonction pour importer des matchs manuellement
        function importMatchesJSON() {
            const json = prompt("Colle le JSON des matchs ici (format: [{home, away, odds1, odds2, league}]):");
            if (!json) return;
            
            try {
                cachedMatches = JSON.parse(json);
                alert(`‚úÖ ${cachedMatches.length} matchs import√©s !`);
                fetchTodayMatches();
            } catch (e) {
                alert("‚ùå JSON invalide: " + e.message);
            }
        }

        // Fonction pour charger des matchs depuis OddsPortal (ouvre dans nouvel onglet)
        function openOddsPortal() {
            window.open('https://www.oddsportal.com/matches/tennis/', '_blank');
        }

        // R√©cup√®re les d√©tails d'un √©v√©nement Pinnacle
        async function getPinnacleEvent(eventId) {
            return null;
        }

        // D√©tecte la cat√©gorie d'un tournoi √† partir de son nom
        function detectTournamentCategory(leagueName) {
            const name = leagueName.toLowerCase();
            
            // Check explicit categories
            for (const [key, value] of Object.entries(TOURNAMENT_CATEGORIES)) {
                if (name.includes(key)) return value;
            }
            
            // Detect by keywords
            if (name.includes('atp') && name.includes('250')) return { cat: 'ATP 250', surf: 'Hard' };
            if (name.includes('atp') && name.includes('500')) return { cat: 'ATP 500', surf: 'Hard' };
            if (name.includes('wta') && name.includes('1000')) return { cat: 'WTA 1000', surf: 'Hard' };
            if (name.includes('wta') && name.includes('500')) return { cat: 'WTA 500', surf: 'Hard' };
            if (name.includes('wta') && name.includes('250')) return { cat: 'WTA 250', surf: 'Hard' };
            if (name.includes('challenger')) return { cat: 'Challenger', surf: 'Hard' };
            if (name.includes('itf')) return { cat: 'ITF', surf: 'Hard' };
            
            // Default
            return { cat: 'Unknown', surf: 'Hard' };
        }

        // D√©tecte le circuit (ATP ou WTA)
        function detectCircuit(leagueName) {
            const name = leagueName.toLowerCase();
            if (name.includes('wta') || name.includes('women')) return 'wta';
            return 'atp';
        }

        // Check si un match est dans une niche
        function checkMatchNiche(odds1, odds2, category, surface, circuit) {
            const niches = circuit === 'atp' ? NICHES_ATP : NICHES_WTA;
            const dogOdds = Math.max(odds1, odds2);
            const favOdds = Math.min(odds1, odds2);
            
            for (const niche of niches.filter(n => n.on !== false)) {
                // Check category
                if (niche.cat !== category) continue;
                
                // Check surface (if we know it)
                if (niche.surf && surface && niche.surf !== surface) continue;
                
                // Check odds
                const targetOdds = niche.strat === 'favorite' ? favOdds : dogOdds;
                if (targetOdds >= niche.min && targetOdds <= niche.max) {
                    return {
                        matched: true,
                        niche: niche,
                        betOn: niche.strat === 'favorite' ? 'FAVORI' : 'UNDERDOG',
                        odds: targetOdds
                    };
                }
                
                // Check if close (within 0.2)
                if (targetOdds >= niche.min - 0.2 && targetOdds <= niche.max + 0.2) {
                    return {
                        matched: false,
                        close: true,
                        niche: niche,
                        betOn: niche.strat === 'favorite' ? 'FAVORI' : 'UNDERDOG',
                        odds: targetOdds
                    };
                }
            }
            
            return { matched: false, close: false };
        }

        // Fetch et affiche les matchs du jour
        async function fetchTodayMatches() {
            const btn = document.getElementById('btnFetchMatches');
            const status = document.getElementById('todayMatchesStatus');
            
            btn.disabled = true;
            btn.textContent = '‚è≥ Chargement...';
            status.innerHTML = 'üîç R√©cup√©ration des cotes Pinnacle en cours...';
            status.style.background = 'rgba(77,159,255,.15)';
            status.style.color = 'var(--blue)';
            
            try {
                const data = await getPinnacleOdds();
                
                if (!data || !data.events) {
                    status.innerHTML = '‚ùå Erreur: Pas de donn√©es re√ßues';
                    status.style.background = 'rgba(239,68,68,.15)';
                    status.style.color = 'var(--red)';
                    btn.disabled = false;
                    btn.textContent = 'üîÑ Actualiser';
                    return;
                }
                
                const nicheMatches = [];
                const otherMatches = [];
                
                for (const event of data.events) {
                    if (!event.home || !event.away) continue;
                    
                    const leagueName = event.league_name || event.league || '';
                    const circuit = detectCircuit(leagueName);
                    const { cat, surf } = detectTournamentCategory(leagueName);
                    
                    // Skip non-ATP/WTA
                    if (cat === 'Challenger' || cat === 'ITF' || cat === 'Unknown') {
                        continue;
                    }
                    
                    // Get odds
                    const odds1 = event.home_od || event.odds?.home || 0;
                    const odds2 = event.away_od || event.odds?.away || 0;
                    
                    if (odds1 < 1.01 || odds2 < 1.01) continue;
                    
                    const nicheCheck = checkMatchNiche(odds1, odds2, cat, surf, circuit);
                    
                    const match = {
                        home: event.home,
                        away: event.away,
                        odds1: odds1,
                        odds2: odds2,
                        league: leagueName,
                        category: cat,
                        surface: surf,
                        circuit: circuit,
                        time: event.starts || event.time || '',
                        nicheCheck: nicheCheck
                    };
                    
                    if (nicheCheck.matched || nicheCheck.close) {
                        nicheMatches.push(match);
                    } else {
                        otherMatches.push(match);
                    }
                }
                
                // Render niche matches
                if (nicheMatches.length > 0) {
                    safeDisplay('nicheMatchesCard', true);
                    safeHTML('nicheMatches', nicheMatches.map(m => renderMatchCard(m, true)).join(''));
                } else {
                    safeDisplay('nicheMatchesCard', true);
                    safeHTML('nicheMatches', '<div class="no-data">Aucun match dans les niches actuellement</div>');
                }
                
                // Render other matches
                if (otherMatches.length > 0) {
                    safeDisplay('otherMatchesCard', true);
                    safeHTML('otherMatches', otherMatches.slice(0, 50).map(m => renderMatchCard(m, false)).join(''));
                }
                
                status.innerHTML = `‚úÖ ${nicheMatches.length} match(s) dans les niches | ${otherMatches.length} autres matchs`;
                status.style.background = 'rgba(34,197,94,.15)';
                status.style.color = 'var(--green)';
                
            } catch (err) {
                console.error('Erreur fetch matchs:', err);
                status.innerHTML = '‚ùå Erreur: ' + err.message;
                status.style.background = 'rgba(239,68,68,.15)';
                status.style.color = 'var(--red)';
            }
            
            btn.disabled = false;
            btn.textContent = 'üîÑ Actualiser';
        }

        function renderMatchCard(match, isNiche) {
            const circuitIcon = match.circuit === 'atp' ? 'üü¢' : 'ü©∑';
            const nicheInfo = match.nicheCheck;
            
            let statusBadge = '';
            let borderColor = 'var(--border)';
            let bgColor = 'var(--bg)';
            
            if (nicheInfo.matched) {
                statusBadge = `<span style="background:var(--green);color:#000;padding:.2rem .5rem;border-radius:4px;font-size:.7rem;font-weight:600">‚úÖ ${nicheInfo.niche.name}</span>`;
                borderColor = 'var(--green)';
                bgColor = 'rgba(34,197,94,.1)';
            } else if (nicheInfo.close) {
                statusBadge = `<span style="background:var(--yellow);color:#000;padding:.2rem .5rem;border-radius:4px;font-size:.7rem;font-weight:600">‚ö†Ô∏è Proche: ${nicheInfo.niche.name}</span>`;
                borderColor = 'var(--yellow)';
                bgColor = 'rgba(234,179,8,.1)';
            }
            
            const dogOdds = Math.max(match.odds1, match.odds2);
            const favOdds = Math.min(match.odds1, match.odds2);
            const dogIsHome = match.odds1 > match.odds2;
            
            return `
                <div style="background:${bgColor};border:1px solid ${borderColor};border-radius:8px;padding:.75rem;margin-bottom:.5rem">
                    <div style="display:flex;justify-content:space-between;align-items:flex-start;gap:.5rem;flex-wrap:wrap">
                        <div style="flex:1;min-width:200px">
                            <div style="font-size:.7rem;color:var(--muted);margin-bottom:.3rem">${circuitIcon} ${match.league}</div>
                            <div style="display:flex;gap:1rem;align-items:center">
                                <div>
                                    <div style="font-weight:${!dogIsHome ? '700' : '400'};${!dogIsHome ? 'color:var(--green)' : ''}">${match.home} <span class="mono">@${match.odds1.toFixed(2)}</span></div>
                                    <div style="font-weight:${dogIsHome ? '700' : '400'};${dogIsHome ? 'color:var(--green)' : ''}">${match.away} <span class="mono">@${match.odds2.toFixed(2)}</span></div>
                                </div>
                            </div>
                            <div style="font-size:.7rem;color:var(--muted);margin-top:.3rem">${match.category} ‚Ä¢ ${match.surface}</div>
                        </div>
                        <div style="text-align:right">
                            ${statusBadge}
                            ${nicheInfo.matched ? `<div style="margin-top:.5rem"><button class="btn-sm btn-green" onclick="quickAddBet('${match.home}', '${match.away}', ${nicheInfo.odds}, '${match.circuit}', '${match.league}', '${nicheInfo.niche.name}')">‚ûï Ajouter pari</button></div>` : ''}
                        </div>
                    </div>
                </div>
            `;
        }

        function toggleOtherMatches() {
            const el = document.getElementById('otherMatches');
            el.style.display = el.style.display === 'none' ? 'block' : 'none';
        }

        function renderActiveNiches() {
            var atpEl = document.getElementById('activeNichesATP');
            var wtaEl = document.getElementById('activeNichesWTA');
            if (!atpEl || !wtaEl) return; // Elements don't exist, skip
            
            const atpActive = NICHES_ATP.filter(n => n.on !== false);
            const wtaActive = NICHES_WTA.filter(n => n.on !== false);
            
            atpEl.innerHTML = atpActive.length > 0 
                ? atpActive.map(n => `<div style="padding:.2rem 0;border-bottom:1px solid var(--border)">‚Ä¢ ${n.name}</div>`).join('')
                : '<div style="color:var(--muted)">Aucune niche active</div>';
            
            wtaEl.innerHTML = wtaActive.length > 0
                ? wtaActive.map(n => `<div style="padding:.2rem 0;border-bottom:1px solid var(--border)">‚Ä¢ ${n.name}</div>`).join('')
                : '<div style="color:var(--muted)">Aucune niche active</div>';
        }

        function quickAddBet(home, away, odds, circuit, tournament, niche) {
            // D√©terminer qui est le favori/underdog
            const dogOdds = odds;
            const isFavorite = niche.toLowerCase().includes('fav');
            
            // Remplir le formulaire d'ajout de pari
            showMainTab('tracker');
            setTrackerCircuit(circuit);
            
            // Les champs seront pr√©-remplis si possible
            alert(`Pari √† ajouter:\n${isFavorite ? 'FAVORI' : 'UNDERDOG'} @${odds.toFixed(2)}\n${tournament}\n\nAjoute-le manuellement dans le tracker.`);
        }

        // Ouvre PS3838 pour un tournoi
        function openPS3838(tournament) {
            const searchTerm = encodeURIComponent(tournament);
            window.open(`https://www.ps3838.com/en/sports/tennis`, '_blank');
        }

        // ==================== SIMULATEUR AVANC√â ====================
        
        // Fonction pour formater proprement le score (enlever .0 et tirets inutiles)
        function formatScore(score) {
            if (!score) return '';
            // Remplacer les .0 par rien (6.0 -> 6)
            var formatted = score.replace(/\.0/g, '');
            // Enlever les "- -" ou " - " en fin de cha√Æne
            formatted = formatted.replace(/(\s*-\s*)+$/g, '');
            // Nettoyer les espaces multiples
            formatted = formatted.replace(/\s+/g, ' ').trim();
            return formatted;
        }
        
        var simChart = null;
        var drawdownChart = null;
        var simChartScale = 'linear';
        var mbRuinChart = null;
        var mbProfitChart = null;
        var mbTrajectoriesChart = null;
        var wiProfitByYearChart = null;
        var wiTrajectoryChart = null;
        var wiCachedResults = null; // Cache pour √©viter de recalculer
        var simProfitChart = null; // Nouveau graphique d'√©volution du profit
        
        // Navigation paris par paris
        var simNavData = {
            bets: [],
            profitData: [],
            currentIndex: 0
        };
        
        // Donn√©es des strat√©gies pour le switch
        var simStrategiesData = {
            flat: null,
            pct: null,
            kelly: null,
            bets: null,
            params: null
        };
        var currentViewStrategy = 'flat';
        
        // S√©lectionner une strat√©gie √† visualiser
        function selectViewStrategy(strat) {
            currentViewStrategy = strat;
            
            // Mettre √† jour les tabs visuellement
            var tabs = document.querySelectorAll('.strat-tab');
            tabs.forEach(function(tab) {
                var s = tab.getAttribute('data-strat');
                if (s === strat) {
                    tab.style.background = s === 'flat' ? 'var(--blue)' : s === 'pct' ? 'var(--green)' : 'var(--purple)';
                    tab.style.color = '#fff';
                } else {
                    tab.style.background = 'transparent';
                    tab.style.color = s === 'flat' ? 'var(--blue)' : s === 'pct' ? 'var(--green)' : 'var(--purple)';
                }
            });
            
            // Mettre √† jour les affichages
            updateStrategyView();
        }
        
        // ==================== NAVIGATION PARIS PAR PARIS ====================
        
        function simNavPrev() {
            if (simNavData.bets.length === 0) return;
            simNavData.currentIndex = Math.max(1, simNavData.currentIndex - 1);
            simNavUpdateDisplay();
            simNavHighlightPoint();
        }
        
        function simNavNext() {
            if (simNavData.bets.length === 0) return;
            simNavData.currentIndex = Math.min(simNavData.bets.length, simNavData.currentIndex + 1);
            simNavUpdateDisplay();
            simNavHighlightPoint();
        }
        
        function simNavGoTo(index) {
            if (simNavData.bets.length === 0) return;
            simNavData.currentIndex = Math.max(1, Math.min(simNavData.bets.length, index));
            simNavUpdateDisplay();
            simNavHighlightPoint();
        }
        
        function simNavUpdateDisplay() {
            var idx = simNavData.currentIndex;
            var total = simNavData.bets.length;
            
            // Mettre √† jour l'index
            safeText('simNavIndex', idx + ' / ' + total);
            
            // D√©sactiver les boutons si n√©cessaire
            var prevBtn = document.getElementById('simNavPrevBtn');
            var nextBtn = document.getElementById('simNavNextBtn');
            if (prevBtn) prevBtn.disabled = idx <= 1;
            if (nextBtn) nextBtn.disabled = idx >= total;
            
            // Afficher les d√©tails du pari
            if (idx > 0 && idx <= simNavData.bets.length) {
                var bet = simNavData.bets[idx - 1];
                if (!bet) return;
                
                // Utiliser cumProfit stock√© dans bet, ou calculer depuis profitData
                var profit = bet.cumProfit !== undefined ? bet.cumProfit : (simNavData.profitData[idx - 1] || 0);
                
                var icon = bet.won ? '‚úÖ' : '‚ùå';
                var pnlColor = bet.pnl >= 0 ? 'var(--green)' : 'var(--red)';
                var profitColor = profit >= 0 ? 'var(--green)' : 'var(--red)';
                var circuitIcon = bet.circuit === 'ATP' ? 'üü¢' : 'ü©∑';
                
                var html = '<div style="display:grid;grid-template-columns:1fr 1fr;gap:1rem">';
                html += '<div>';
                html += '<div style="font-weight:700;font-size:1rem;margin-bottom:.5rem">' + icon + ' ' + bet.player + ' <span style="color:var(--blue)">@' + bet.odds.toFixed(2) + '</span></div>';
                html += '<div style="color:var(--muted);font-size:.8rem">vs ' + bet.opponent + (bet.opponentOdds ? ' @' + bet.opponentOdds.toFixed(2) : '') + '</div>';
                if (bet.score) html += '<div style="margin-top:.5rem;font-family:\'JetBrains Mono\',monospace;font-size:.9rem">' + formatScore(bet.score) + '</div>';
                html += '</div>';
                html += '<div style="text-align:right">';
                html += '<div style="font-size:.8rem;color:var(--muted)">' + circuitIcon + ' ' + (bet.tournament || '') + '</div>';
                html += '<div style="font-size:.8rem;color:var(--muted)">' + bet.round + ' ‚Ä¢ ' + bet.date + '</div>';
                html += '<div style="margin-top:.75rem">';
                html += '<span style="font-weight:700;color:' + pnlColor + '">' + (bet.pnl >= 0 ? '+' : '') + Math.round(bet.pnl) + '‚Ç¨</span>';
                html += '<span style="color:var(--muted);margin:0 .5rem">‚Üí</span>';
                html += '<span style="font-weight:700;color:' + profitColor + '">Profit: ' + (profit >= 0 ? '+' : '') + Math.round(profit) + '‚Ç¨</span>';
                if (bet.bankroll) html += '<span style="color:var(--muted);margin-left:.75rem;font-size:.85rem">üí∞ ' + Math.round(bet.bankroll) + '‚Ç¨</span>';
                html += '</div>';
                html += '</div>';
                html += '</div>';
                
                safeHTML('simNavDetail', html);
            }
        }
        
        function simNavHighlightPoint() {
            if (!simProfitChart) return;
            
            // Mettre √† jour le tooltip actif
            var idx = simNavData.currentIndex;
            simProfitChart.setActiveElements([{
                datasetIndex: 0,
                index: idx
            }]);
            simProfitChart.tooltip.setActiveElements([{
                datasetIndex: 0,
                index: idx
            }], {x: 0, y: 0});
            simProfitChart.update();
        }
        
        function simNavShow(bets, profitData) {
            simNavData.bets = bets || [];
            simNavData.profitData = profitData || [];
            simNavData.currentIndex = bets.length > 0 ? bets.length : 0;
            
            var navEl = document.getElementById('simChartNav');
            if (navEl) {
                navEl.style.display = bets.length > 0 ? 'block' : 'none';
            }
            
            if (bets.length > 0) {
                simNavUpdateDisplay();
            }
        }
        
        // Event listener pour les fl√®ches clavier (Simulateur et Playground)
        document.addEventListener('keydown', function(e) {
            // Ne pas interf√©rer si on est dans un input
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') return;
            
            // V√©rifier si la nav Simulateur est visible
            var simNavEl = document.getElementById('simChartNav');
            var simNavVisible = simNavEl && simNavEl.style.display !== 'none';
            
            // V√©rifier si la nav Playground est visible
            var labNavEl = document.getElementById('labChartNav');
            var labNavVisible = labNavEl && labNavEl.style.display !== 'none';
            
            if (e.key === 'ArrowLeft') {
                e.preventDefault();
                if (simNavVisible) simNavPrev();
                else if (labNavVisible) labNavPrev();
            } else if (e.key === 'ArrowRight') {
                e.preventDefault();
                if (simNavVisible) simNavNext();
                else if (labNavVisible) labNavNext();
            }
        });
        
        // ==================== FIN NAVIGATION ====================
        
        // Mettre √† jour tous les affichages pour la strat√©gie s√©lectionn√©e
        function updateStrategyView() {
            if (!simStrategiesData.bets || !simStrategiesData.params) return;
            
            var data = simStrategiesData[currentViewStrategy];
            if (!data) return;
            
            var params = simStrategiesData.params;
            var stratName = currentViewStrategy === 'flat' ? 'Flat ' + params.flatStake + '‚Ç¨' : 
                           currentViewStrategy === 'pct' ? params.pctStake + '% BR' : 
                           'Kelly √∑' + params.kellyDiv;
            var stratColor = currentViewStrategy === 'flat' ? 'var(--blue)' : 
                            currentViewStrategy === 'pct' ? 'var(--green)' : 'var(--purple)';
            
            // Stats principales
            var profitEl = document.getElementById('statProfit');
            var roiEl = document.getElementById('statROI');
            var ddEl = document.getElementById('statDD');
            var finalEl = document.getElementById('statFinal');
            var sharpeEl = document.getElementById('statSharpe');
            
            if (profitEl) {
                profitEl.textContent = (data.profit >= 0 ? '+' : '') + formatMoneyShort(data.profit);
                profitEl.style.color = data.profit >= 0 ? 'var(--green)' : 'var(--red)';
            }
            if (roiEl) {
                roiEl.textContent = (data.roi >= 0 ? '+' : '') + data.roi.toFixed(1) + '%';
                roiEl.style.color = data.roi >= 0 ? 'var(--green)' : 'var(--red)';
            }
            if (ddEl) ddEl.textContent = '-' + data.maxDrawdown.toFixed(1) + '%';
            if (finalEl) finalEl.textContent = formatMoneyShort(data.finalBankroll);
            if (sharpeEl) sharpeEl.textContent = data.sharpe.toFixed(2);
            
            // Labels
            var chartLabel = document.getElementById('chartStratLabel');
            var yearLabel = document.getElementById('yearStratLabel');
            if (chartLabel) chartLabel.innerHTML = 'Strat√©gie: <b style="color:' + stratColor + '">' + stratName + '</b>';
            if (yearLabel) yearLabel.textContent = '(' + stratName + ')';
            
            // Redessiner le graphique avec la bonne strat√©gie
            renderSimProfitChartForStrategy(currentViewStrategy);
            
            // Redessiner les ann√©es
            renderSimYearsForStrategy(currentViewStrategy);
            
            // Redessiner l'historique
            renderSimHistoryForStrategy(currentViewStrategy);
        }
        
        // Fonction helper pour formater les montants courts
        function formatMoneyShort(val) {
            if (Math.abs(val) >= 1000000) return (val / 1000000).toFixed(1) + 'M‚Ç¨';
            if (Math.abs(val) >= 10000) return (val / 1000).toFixed(0) + 'k‚Ç¨';
            return Math.round(val) + '‚Ç¨';
        }
        
        // Version globale de formatMoney
        function formatMoney(val) {
            if (Math.abs(val) >= 1000000) return (val / 1000000).toFixed(1) + 'M‚Ç¨';
            if (Math.abs(val) >= 10000) return (val / 1000).toFixed(0) + 'k‚Ç¨';
            return Math.round(val) + '‚Ç¨';
        }
        
        // Fonction pour cr√©er le graphique d'√©volution du profit
        function renderSimProfitChart(bets, stake, initialBankroll) {
            console.log('>>> renderSimProfitChart appel√© avec', bets.length, 'paris, stake:', stake);
            
            var canvas = document.getElementById('simProfitChart');
            console.log('Canvas trouv√©:', canvas);
            
            if (!canvas) {
                console.error('Canvas simProfitChart non trouv√©');
                return;
            }
            
            // V√©rifier que le parent est visible
            var parent = canvas.parentElement;
            console.log('Parent:', parent, 'offsetHeight:', parent ? parent.offsetHeight : 0);
            
            if (simProfitChart) {
                console.log('Destruction ancien graphique');
                simProfitChart.destroy();
                simProfitChart = null;
            }
            
            // Pr√©parer les donn√©es
            var labels = ['D√©part'];
            var profitData = [0];
            var pointColors = ['#666'];
            var betDetails = [null];
            
            var cumProfit = 0;
            var cumBankroll = initialBankroll;
            
            for (var i = 0; i < bets.length; i++) {
                var b = bets[i];
                // Appliquer le coefficient de la niche SEULEMENT en mode custom
                var stakeCoef = 1.0;
                if (currentStakeMode === 'custom' && b.nicheObj && b.nicheObj.stakeCoef) {
                    stakeCoef = b.nicheObj.stakeCoef;
                }
                var adjustedStake = stake * stakeCoef;
                var pnl = b.won ? (b.odds - 1) * adjustedStake : -adjustedStake;
                cumProfit += pnl;
                cumBankroll += pnl;
                
                labels.push(b.date);
                profitData.push(Math.round(cumProfit));
                pointColors.push(b.won ? '#22c55e' : '#ef4444');
                betDetails.push({
                    player: b.player || '-',
                    opponent: b.opponent || '-',
                    odds: b.odds,
                    opponentOdds: b.opponentOdds || 0,
                    pnl: pnl,
                    cumProfit: Math.round(cumProfit),
                    stake: adjustedStake,
                    stakeCoef: stakeCoef,
                    won: b.won,
                    tournament: b.tournament || '',
                    round: b.round || '',
                    score: b.score || '',
                    bankroll: cumBankroll,
                    circuit: b.circuit || '',
                    date: b.date || ''
                });
            }
            
            console.log('Donn√©es pr√©par√©es:', labels.length, 'points, profit final:', cumProfit);
            
            try {
                var ctx = canvas.getContext('2d');
                console.log('Context 2D:', ctx);
                
                simProfitChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Profit cumul√©',
                            data: profitData,
                            borderColor: cumProfit >= 0 ? '#22c55e' : '#ef4444',
                            backgroundColor: cumProfit >= 0 ? 'rgba(34,197,94,.1)' : 'rgba(239,68,68,.1)',
                            fill: true,
                            tension: 0.1,
                            pointRadius: bets.length < 50 ? 4 : bets.length < 200 ? 2 : 0,
                            pointHoverRadius: 6,
                            pointBackgroundColor: pointColors,
                            pointBorderColor: '#fff',
                            pointBorderWidth: 1,
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        onClick: function(evt, elements) {
                            if (elements && elements.length > 0) {
                                var idx = elements[0].index;
                                if (idx > 0) simNavGoTo(idx);
                            }
                        },
                        interaction: {
                            intersect: false,
                            mode: 'index'
                        },
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                backgroundColor: 'rgba(0,0,0,0.9)',
                                titleColor: '#fff',
                                bodyColor: '#fff',
                                padding: 12,
                                displayColors: false,
                                callbacks: {
                                    title: function(context) {
                                        var idx = context[0].dataIndex;
                                        if (idx === 0) return 'Point de d√©part';
                                        return labels[idx];
                                    },
                                    label: function(context) {
                                        var idx = context.dataIndex;
                                        if (idx === 0) return ['Profit: 0‚Ç¨', 'Bankroll: ' + initialBankroll + '‚Ç¨'];
                                        
                                        var bet = betDetails[idx - 1]; // Fix: idx-1 car betDetails ne contient pas le d√©part
                                        if (!bet) return [];
                                        var lines = [];
                                        lines.push((bet.won ? '‚úÖ ' : '‚ùå ') + bet.player + ' @' + bet.odds.toFixed(2));
                                        lines.push('vs ' + bet.opponent + ' @' + (bet.opponentOdds ? bet.opponentOdds.toFixed(2) : '-'));
                                        if (bet.score) lines.push('Score: ' + formatScore(bet.score));
                                        if (bet.tournament) lines.push(bet.tournament + ' ‚Ä¢ ' + bet.round);
                                        lines.push('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
                                        lines.push('P&L: ' + (bet.pnl >= 0 ? '+' : '') + bet.pnl.toFixed(0) + '‚Ç¨');
                                        lines.push('Profit total: ' + (profitData[idx] >= 0 ? '+' : '') + profitData[idx] + '‚Ç¨');
                                        lines.push('Bankroll: ' + bet.bankroll.toFixed(0) + '‚Ç¨');
                                        return lines;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                display: true,
                                grid: { color: 'rgba(255,255,255,.05)' },
                                ticks: { 
                                    color: '#888',
                                    maxTicksLimit: 8,
                                    maxRotation: 0
                                }
                            },
                            y: {
                                display: true,
                                grid: { color: 'rgba(255,255,255,.1)' },
                                ticks: {
                                    color: '#888',
                                    callback: function(value) { return value + '‚Ç¨'; }
                                }
                            }
                        }
                    }
                });
                
                console.log('>>> GRAPHIQUE CREE AVEC SUCCES <<<');
                
                // Activer la navigation paris par paris (exclure le null initial)
                simNavShow(betDetails.slice(1), profitData.slice(1));
            } catch(e) {
                console.error('ERREUR cr√©ation graphique:', e);
            }
        }
        
        // Fonction pour redessiner le graphique selon la strat√©gie s√©lectionn√©e
        function renderSimProfitChartForStrategy(strat) {
            if (!simStrategiesData.bets || !simStrategiesData.params) return;
            
            var data = simStrategiesData[strat];
            var params = simStrategiesData.params;
            var bets = simStrategiesData.bets;
            
            if (!data || !data.results) return;
            
            var canvas = document.getElementById('simProfitChart');
            if (!canvas) return;
            
            if (simProfitChart) {
                simProfitChart.destroy();
                simProfitChart = null;
            }
            
            var stratColor = strat === 'flat' ? '#4d9fff' : strat === 'pct' ? '#22c55e' : '#8b5cf6';
            var labels = [];
            var profitData = [];
            var pointColors = [];
            var betDetails = [];
            
            // Construire les donn√©es depuis les r√©sultats de la simulation
            for (var i = 0; i < data.results.length; i++) {
                var r = data.results[i];
                if (i === 0) {
                    labels.push('D√©part');
                    profitData.push(0);
                    pointColors.push('#666');
                    betDetails.push(null);
                } else {
                    var bet = bets[i - 1];
                    labels.push(bet ? bet.date : 'Pari ' + i);
                    profitData.push(Math.round(r.bankroll - params.bankroll));
                    pointColors.push(r.won ? '#22c55e' : '#ef4444');
                    betDetails.push({
                        player: bet ? bet.player : '-',
                        opponent: bet ? bet.opponent : '-',
                        odds: bet ? bet.odds : 0,
                        opponentOdds: bet ? bet.opponentOdds : 0,
                        won: r.won,
                        pnl: r.pnl,
                        cumProfit: Math.round(r.bankroll - params.bankroll),
                        stake: r.stake,
                        bankroll: r.bankroll,
                        tournament: bet ? bet.tournament : '',
                        round: bet ? bet.round : '',
                        score: bet ? bet.score : '',
                        circuit: bet ? bet.circuit : '',
                        date: bet ? bet.date : ''
                    });
                }
            }
            
            var finalProfit = profitData[profitData.length - 1] || 0;
            
            try {
                var ctx = canvas.getContext('2d');
                simProfitChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Profit cumul√©',
                            data: profitData,
                            borderColor: stratColor,
                            backgroundColor: stratColor + '20',
                            fill: true,
                            tension: 0.1,
                            pointRadius: bets.length < 50 ? 4 : bets.length < 200 ? 2 : 0,
                            pointHoverRadius: 6,
                            pointBackgroundColor: pointColors,
                            pointBorderColor: '#fff',
                            pointBorderWidth: 1,
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        onClick: function(evt, elements) {
                            if (elements && elements.length > 0) {
                                var idx = elements[0].index;
                                if (idx > 0) simNavGoTo(idx);
                            }
                        },
                        interaction: { intersect: false, mode: 'index' },
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                backgroundColor: 'rgba(0,0,0,0.9)',
                                padding: 12,
                                callbacks: {
                                    title: function(context) {
                                        var idx = context[0].dataIndex;
                                        if (idx === 0) return 'Point de d√©part';
                                        return labels[idx];
                                    },
                                    label: function(context) {
                                        var idx = context.dataIndex;
                                        if (idx === 0) return ['Profit: 0‚Ç¨', 'Bankroll: ' + params.bankroll + '‚Ç¨'];
                                        var bet = betDetails[idx];
                                        if (!bet) return [];
                                        var lines = [];
                                        lines.push((bet.won ? '‚úÖ ' : '‚ùå ') + bet.player + ' @' + (bet.odds ? bet.odds.toFixed(2) : '-'));
                                        lines.push('Mise: ' + (bet.stake ? Math.round(bet.stake) + '‚Ç¨' : '-'));
                                        if (bet.tournament) lines.push(bet.tournament + ' ‚Ä¢ ' + bet.round);
                                        lines.push('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
                                        lines.push('P&L: ' + (bet.pnl >= 0 ? '+' : '') + Math.round(bet.pnl) + '‚Ç¨');
                                        lines.push('Profit total: ' + (profitData[idx] >= 0 ? '+' : '') + profitData[idx] + '‚Ç¨');
                                        lines.push('Bankroll: ' + Math.round(bet.bankroll) + '‚Ç¨');
                                        return lines;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: { display: true, grid: { color: 'rgba(255,255,255,.05)' }, ticks: { color: '#888', maxTicksLimit: 8 } },
                            y: { display: true, grid: { color: 'rgba(255,255,255,.1)' }, ticks: { color: '#888', callback: function(v) { return v >= 0 ? '+' + v + '‚Ç¨' : v + '‚Ç¨'; } } }
                        }
                    }
                });
                
                // Activer la navigation paris par paris (exclure le premier √©l√©ment null)
                simNavShow(betDetails.slice(1), profitData.slice(1));
            } catch(e) {
                console.error('Erreur graphique strat√©gie:', e);
            }
        }
        
        // Fonction pour afficher les ann√©es selon la strat√©gie
        function renderSimYearsForStrategy(strat) {
            if (!simStrategiesData.bets || !simStrategiesData.params) return;
            
            var params = simStrategiesData.params;
            var bets = simStrategiesData.bets;
            var data = simStrategiesData[strat];
            if (!data) return;
            
            var stratColor = strat === 'flat' ? 'var(--blue)' : strat === 'pct' ? 'var(--green)' : 'var(--purple)';
            
            // Grouper par ann√©e et calculer les profits selon la strat√©gie
            var yearStats = {};
            var currentBankroll = params.bankroll;
            
            for (var i = 0; i < bets.length; i++) {
                var bet = bets[i];
                var year = bet.date.substring(0, 4);
                if (!yearStats[year]) yearStats[year] = { bets: 0, wins: 0, profit: 0, staked: 0 };
                
                // Calculer la mise selon la strat√©gie
                var stake;
                var stakeCoef = 1.0;
                if (currentStakeMode === 'custom' && bet.nicheObj && bet.nicheObj.stakeCoef) {
                    stakeCoef = bet.nicheObj.stakeCoef;
                }
                
                if (strat === 'flat') {
                    stake = params.flatStake * stakeCoef;
                } else if (strat === 'pct') {
                    stake = currentBankroll * (params.pctStake / 100) * stakeCoef;
                } else {
                    // Kelly simplifi√©
                    var wr = 0.45;
                    var avgOdds = bet.odds || 2.5;
                    var kellyPct = Math.max(0, Math.min(0.2, (wr * avgOdds - 1) / (avgOdds - 1)));
                    stake = currentBankroll * kellyPct / params.kellyDiv * stakeCoef;
                }
                stake = Math.min(stake, currentBankroll);
                
                var pnl = bet.won ? stake * (bet.odds - 1) : -stake;
                currentBankroll += pnl;
                
                yearStats[year].bets++;
                if (bet.won) yearStats[year].wins++;
                yearStats[year].profit += pnl;
                yearStats[year].staked += stake;
            }
            
            // Afficher
            var container = document.getElementById('simYears');
            if (!container) return;
            
            var html = '';
            var years = Object.keys(yearStats).sort();
            
            for (var y = 0; y < years.length; y++) {
                var year = years[y];
                var s = yearStats[year];
                var roi = s.staked > 0 ? (s.profit / s.staked * 100) : 0;
                var isPos = s.profit >= 0;
                
                html += '<div class="year ' + (isPos ? 'pos' : 'neg') + '" style="border-color:' + stratColor + '">';
                html += '<b>' + year + '</b>';
                html += '<span>' + s.bets + 'p</span>';
                html += '<div style="font-family:monospace" class="' + (isPos ? 'pos' : 'neg') + '">' + (isPos ? '+' : '') + Math.round(s.profit) + '‚Ç¨</div>';
                html += '<div style="font-size:.65rem;color:var(--muted)">' + (roi >= 0 ? '+' : '') + roi.toFixed(0) + '% ROI</div>';
                html += '</div>';
            }
            
            container.innerHTML = html;
        }
        
        // Fonction pour afficher l'historique selon la strat√©gie
        function renderSimHistoryForStrategy(strat) {
            if (!simStrategiesData.bets || !simStrategiesData.params) return;
            
            var params = simStrategiesData.params;
            var bets = simStrategiesData.bets;
            
            var stratColor = strat === 'flat' ? 'var(--blue)' : strat === 'pct' ? 'var(--green)' : 'var(--purple)';
            var stratName = strat === 'flat' ? 'Flat ' + params.flatStake + '‚Ç¨' : 
                           strat === 'pct' ? params.pctStake + '% BR' : 'Kelly √∑' + params.kellyDiv;
            
            // Recalculer les paris avec la strat√©gie
            var currentBankroll = params.bankroll;
            var historyData = [];
            
            for (var i = 0; i < bets.length; i++) {
                var bet = bets[i];
                
                var stake;
                var stakeCoef = 1.0;
                if (currentStakeMode === 'custom' && bet.nicheObj && bet.nicheObj.stakeCoef) {
                    stakeCoef = bet.nicheObj.stakeCoef;
                }
                
                if (strat === 'flat') {
                    stake = params.flatStake * stakeCoef;
                } else if (strat === 'pct') {
                    stake = currentBankroll * (params.pctStake / 100) * stakeCoef;
                } else {
                    var wr = 0.45;
                    var avgOdds = bet.odds || 2.5;
                    var kellyPct = Math.max(0, Math.min(0.2, (wr * avgOdds - 1) / (avgOdds - 1)));
                    stake = currentBankroll * kellyPct / params.kellyDiv * stakeCoef;
                }
                stake = Math.min(stake, currentBankroll);
                
                var pnl = bet.won ? stake * (bet.odds - 1) : -stake;
                currentBankroll += pnl;
                
                historyData.push({
                    date: bet.date,
                    player: bet.player,
                    opponent: bet.opponent,
                    odds: bet.odds,
                    won: bet.won,
                    stake: stake,
                    pnl: pnl,
                    bankroll: currentBankroll,
                    tournament: bet.tournament,
                    round: bet.round,
                    niche: bet.niche,
                    circuit: bet.circuit,
                    stakeCoef: stakeCoef
                });
            }
            
            // Afficher
            var container = document.getElementById('simHistoryList');
            if (!container) return;
            
            var countEl = document.getElementById('simHistoryCount');
            if (countEl) countEl.textContent = '(' + historyData.length + ' paris - ' + stratName + ')';
            
            // Filtrer et trier
            var filter = (document.getElementById('simHistoryFilter') || {}).value || '';
            var sortBy = (document.getElementById('simHistorySort') || {}).value || 'date-desc';
            
            var filtered = historyData;
            if (filter) {
                filter = filter.toLowerCase();
                filtered = historyData.filter(function(b) {
                    return (b.player && b.player.toLowerCase().includes(filter)) ||
                           (b.tournament && b.tournament.toLowerCase().includes(filter)) ||
                           (b.niche && b.niche.toLowerCase().includes(filter));
                });
            }
            
            // Tri
            filtered.sort(function(a, b) {
                if (sortBy === 'date-asc') return a.date.localeCompare(b.date);
                if (sortBy === 'profit-desc') return b.pnl - a.pnl;
                if (sortBy === 'profit-asc') return a.pnl - b.pnl;
                if (sortBy === 'odds-desc') return b.odds - a.odds;
                return b.date.localeCompare(a.date);
            });
            
            // Limiter √† 100 pour la perf
            var display = filtered.slice(0, 100);
            
            var html = '';
            for (var i = 0; i < display.length; i++) {
                var b = display[i];
                var pnlColor = b.pnl >= 0 ? 'var(--green)' : 'var(--red)';
                var icon = b.won ? '‚úÖ' : '‚ùå';
                var coefDisplay = b.stakeCoef !== 1 ? ' <span style="color:var(--yellow);font-size:.7rem">√ó' + b.stakeCoef.toFixed(2) + '</span>' : '';
                
                html += '<div style="display:grid;grid-template-columns:90px 1fr 60px 70px 80px;gap:.5rem;padding:.5rem;border-bottom:1px solid var(--border);font-size:.8rem;align-items:center">';
                html += '<div style="color:var(--muted)">' + b.date + '</div>';
                html += '<div><span style="color:' + (b.won ? 'var(--green)' : 'var(--red)') + '">' + icon + ' ' + b.player + '</span> <span style="color:var(--muted);font-size:.7rem">@' + b.odds.toFixed(2) + '</span></div>';
                html += '<div style="text-align:right">' + Math.round(b.stake) + '‚Ç¨' + coefDisplay + '</div>';
                html += '<div style="text-align:right;color:' + pnlColor + ';font-weight:600">' + (b.pnl >= 0 ? '+' : '') + Math.round(b.pnl) + '‚Ç¨</div>';
                html += '<div style="text-align:right;font-size:.75rem">' + Math.round(b.bankroll) + '‚Ç¨</div>';
                html += '</div>';
            }
            
            if (filtered.length > 100) {
                html += '<div style="text-align:center;padding:1rem;color:var(--muted);font-size:.8rem">... et ' + (filtered.length - 100) + ' autres paris</div>';
            }
            
            container.innerHTML = html || '<div style="text-align:center;color:var(--muted);padding:1rem">Aucun pari</div>';
            
            // AUSSI METTRE √Ä JOUR LES S√âRIES
            renderSimStreaksForStrategy(strat, historyData);
        }
        
        // Fonction pour afficher les s√©ries selon la strat√©gie
        function renderSimStreaksForStrategy(strat, historyData) {
            if (!historyData || historyData.length === 0) return;
            
            var params = simStrategiesData.params;
            var stratName = strat === 'flat' ? 'Flat' : strat === 'pct' ? '% BR' : 'Kelly';
            
            // Trouver les s√©ries
            var currentWinStreak = [];
            var currentLoseStreak = [];
            var bestWinning = [];
            var worstLosing = [];
            
            for (var i = 0; i < historyData.length; i++) {
                var b = historyData[i];
                
                if (b.won) {
                    currentWinStreak.push(b);
                    if (currentLoseStreak.length > worstLosing.length) {
                        worstLosing = currentLoseStreak.slice();
                    }
                    currentLoseStreak = [];
                } else {
                    currentLoseStreak.push(b);
                    if (currentWinStreak.length > bestWinning.length) {
                        bestWinning = currentWinStreak.slice();
                    }
                    currentWinStreak = [];
                }
            }
            // V√©rifier les derni√®res
            if (currentWinStreak.length > bestWinning.length) bestWinning = currentWinStreak;
            if (currentLoseStreak.length > worstLosing.length) worstLosing = currentLoseStreak;
            
            // Afficher pire s√©rie
            var worstEl = document.getElementById('simWorstStreak');
            if (worstEl && worstLosing.length > 0) {
                var worstTotal = worstLosing.reduce(function(s, b) { return s + b.pnl; }, 0);
                var html = '<div style="font-weight:700;color:var(--red);margin-bottom:.5rem">' + worstLosing.length + ' d√©faites cons√©cutives ‚Ä¢ ' + Math.round(worstTotal) + '‚Ç¨</div>';
                html += '<div style="max-height:200px;overflow-y:auto">';
                worstLosing.forEach(function(b) {
                    html += '<div style="padding:.4rem;font-size:.75rem;border-bottom:1px solid var(--border);background:rgba(239,68,68,.05)">';
                    html += '<div style="display:flex;justify-content:space-between">';
                    html += '<span style="color:var(--muted);font-size:.65rem">' + b.date + '</span>';
                    html += '<span style="color:var(--red);font-weight:600">' + Math.round(b.pnl) + '‚Ç¨</span>';
                    html += '</div>';
                    html += '<div>‚ùå <b>' + b.player + '</b> @' + b.odds.toFixed(2) + ' <span style="color:var(--muted)">(' + Math.round(b.stake) + '‚Ç¨)</span></div>';
                    html += '</div>';
                });
                html += '</div>';
                worstEl.innerHTML = html;
            }
            
            // Afficher meilleure s√©rie
            var bestEl = document.getElementById('simBestStreak');
            if (bestEl && bestWinning.length > 0) {
                var bestTotal = bestWinning.reduce(function(s, b) { return s + b.pnl; }, 0);
                var html = '<div style="font-weight:700;color:var(--green);margin-bottom:.5rem">' + bestWinning.length + ' victoires cons√©cutives ‚Ä¢ +' + Math.round(bestTotal) + '‚Ç¨</div>';
                html += '<div style="max-height:200px;overflow-y:auto">';
                bestWinning.forEach(function(b) {
                    html += '<div style="padding:.4rem;font-size:.75rem;border-bottom:1px solid var(--border);background:rgba(34,197,94,.05)">';
                    html += '<div style="display:flex;justify-content:space-between">';
                    html += '<span style="color:var(--muted);font-size:.65rem">' + b.date + '</span>';
                    html += '<span style="color:var(--green);font-weight:600">+' + Math.round(b.pnl) + '‚Ç¨</span>';
                    html += '</div>';
                    html += '<div>‚úÖ <b>' + b.player + '</b> @' + b.odds.toFixed(2) + ' <span style="color:var(--muted)">(' + Math.round(b.stake) + '‚Ç¨)</span></div>';
                    html += '</div>';
                });
                html += '</div>';
                bestEl.innerHTML = html;
            }
        }
        
        function updateSimNicheSelect() {
            // Plus utilis√© - on utilise les niches actives du Labo maintenant
            if (typeof updateSimNichesSummary === 'function') updateSimNichesSummary();
        }
        
        function updateSimNicheCheckboxes() {
            // Plus utilis√© - on utilise les niches actives du Labo maintenant
            if (typeof updateSimNichesSummary === 'function') updateSimNichesSummary();
        }
        
        function toggleAllSimNiches(state) {
            var checkboxes = document.querySelectorAll('.sim-niche-cb');
            checkboxes.forEach(function(cb) {
                cb.checked = state;
            });
            updateSimStats();
        }
        
        function getSelectedSimNiches() {
            var selected = { atp: [], wta: [] };
            var checkboxes = document.querySelectorAll('.sim-niche-cb:checked');
            
            checkboxes.forEach(function(cb) {
                var circuit = cb.dataset.circuit;
                var id = cb.dataset.id;
                selected[circuit].push(id);
            });
            
            return selected;
        }
        
        function updateStrategyOptions() {
            var strategyEl = document.getElementById('simStrategy');
            if (!strategyEl) return;
            
            var strategy = strategyEl.value;
            var paramsDiv = document.getElementById('strategyParams');
            var recoDiv = document.getElementById('strategyRecommendation');
            var bankroll = parseFloat(document.getElementById('cfgBankroll').value) || 5000;
            
            // Mettre √† jour les hidden inputs pour compatibilit√© (si existent)
            var useFlat = document.getElementById('simUseFlat');
            var usePct = document.getElementById('simUsePct');
            var useKelly = document.getElementById('simUseKelly');
            if (useFlat) useFlat.value = strategy === 'flat' ? '1' : '0';
            if (usePct) usePct.value = strategy === 'percent' ? '1' : '0';
            if (useKelly) useKelly.value = strategy === 'kelly' ? '1' : '0';
            
            // Si recoDiv n'existe pas, on sort
            if (!recoDiv) return;
            
            if (strategy === 'flat') {
                var flatVal = document.getElementById('cfgStake').value || 150;
                recoDiv.innerHTML = '<span style="color:var(--blue);font-weight:600">üíµ Flat ' + flatVal + '‚Ç¨</span> = mise toujours identique. Simple et pr√©visible.';
                recoDiv.style.borderColor = 'var(--blue)';
                recoDiv.style.background = 'rgba(77,159,255,.1)';
            } else if (strategy === 'percent') {
                var pctVal = document.getElementById('cfgPctStake').value || 3;
                var miseExemple = Math.round(bankroll * pctVal / 100);
                recoDiv.innerHTML = '<span style="color:var(--green);font-weight:600">üìä ' + pctVal + '% Bankroll</span> = ' + miseExemple + '‚Ç¨ sur ' + bankroll + '‚Ç¨. La mise s\'adapte √† ta bankroll.';
                recoDiv.style.borderColor = 'var(--green)';
                recoDiv.style.background = 'rgba(34,197,94,.1)';
            } else if (strategy === 'kelly') {
                var kellyEl = document.getElementById('simKellyDiv');
                var kellyVal = kellyEl ? kellyEl.value : 4;
                recoDiv.innerHTML = '<span style="color:var(--purple);font-weight:600">üßÆ Kelly √∑' + kellyVal + '</span> = mise proportionnelle √† ton edge. Plus agressif mais optimis√©.';
                recoDiv.style.borderColor = 'var(--purple)';
                recoDiv.style.background = 'rgba(168,85,247,.1)';
            }
        }
        
        function setSimChartScale(scale) {
            simChartScale = scale;
            document.querySelectorAll('.sim-scale-btn').forEach(function(btn) {
                btn.style.background = 'var(--bg)';
                btn.style.color = 'var(--text)';
                btn.style.border = '1px solid var(--border)';
            });
            var activeBtn = document.getElementById(scale === 'log' ? 'btnScaleLog' : 'btnScaleLinear');
            activeBtn.style.background = 'var(--blue)';
            activeBtn.style.color = '#fff';
            activeBtn.style.border = 'none';
            
            if (simChart) {
                simChart.options.scales.y.type = scale === 'log' ? 'logarithmic' : 'linear';
                simChart.update();
            }
        }
        
        // R√©cup√©rer tous les paris correspondant aux niches s√©lectionn√©es
        function getSimulationBets() {
            // Utiliser les ann√©es s√©lectionn√©es
            var yearsToInclude = selectedSimYears.length > 0 ? selectedSimYears : ['2025', '2024', '2023'];
            
            console.log('Ann√©es s√©lectionn√©es:', yearsToInclude);
            
            // Utiliser les niches ACTIVES (ON) du Labo - plus de checkboxes s√©par√©es !
            var activeATP = NICHES_ATP.filter(function(n) { return n.on; });
            var activeWTA = NICHES_WTA.filter(function(n) { return n.on; });
            
            // Collecter tous les paris des deux circuits
            var bets = [];
            var seenKeys = {};
            
            // Fonction pour collecter les paris d'un circuit
            function collectBetsFromCircuit(data, niches, circuitName) {
                if (!data || data.length === 0 || niches.length === 0) return;
                
                for (var i = 0; i < data.length; i++) {
                    var m = data[i];
                    
                    // Filtre par ann√©es s√©lectionn√©es
                    var matchYear = m.date ? m.date.substring(0, 4) : '';
                    if (yearsToInclude.indexOf(matchYear) < 0) continue;
                    
                    var matchKey = circuitName + '|' + m.date + '|' + m.p1 + '|' + m.p2;
                    if (seenKeys[matchKey]) continue;
                    
                    // V√©rifier si ce match correspond √† une niche active
                    for (var j = 0; j < niches.length; j++) {
                        var niche = niches[j];
                        
                        // V√©rification cat√©gorie
                        var catMatch = false;
                        var mCat = (m.category || '').toLowerCase();
                        var nCat = niche.cat.toLowerCase();
                        
                        if (nCat.indexOf('grand slam') >= 0 && (mCat.indexOf('grand') >= 0 || mCat.indexOf('slam') >= 0)) catMatch = true;
                        else if (nCat.indexOf('masters 1000') >= 0 && mCat.indexOf('1000') >= 0) catMatch = true;
                        else if (nCat.indexOf('wta 1000') >= 0 && mCat.indexOf('1000') >= 0) catMatch = true;
                        else if (nCat.indexOf('atp 500') >= 0 && mCat.indexOf('500') >= 0) catMatch = true;
                        else if (nCat.indexOf('wta 500') >= 0 && mCat.indexOf('500') >= 0) catMatch = true;
                        else if (nCat.indexOf('atp 250') >= 0 && mCat.indexOf('250') >= 0) catMatch = true;
                        else if (nCat.indexOf('wta 250') >= 0 && mCat.indexOf('250') >= 0) catMatch = true;
                        
                        if (!catMatch) continue;
                        if (m.surface !== niche.surf) continue;
                        
                        var roundMatch = false;
                        for (var r = 0; r < niche.rounds.length; r++) {
                            if (m.round === niche.rounds[r]) { roundMatch = true; break; }
                        }
                        if (!roundMatch) continue;
                        
                        var dO = Math.max(m.o1, m.o2);
                        var fO = Math.min(m.o1, m.o2);
                        var odds = niche.strat === 'underdog' ? dO : fO;
                        
                        if (odds >= niche.min && odds <= niche.max) {
                            var dP1 = m.o1 > m.o2;
                            var won = niche.strat === 'underdog' ? dP1 : !dP1;
                            var opponentOdds = niche.strat === 'underdog' ? Math.min(m.o1, m.o2) : Math.max(m.o1, m.o2);
                            
                            // Inverser le score si on parie sur player2 (le perdant)
                            // CSV: player1 = toujours gagnant, score = perspective gagnant
                            var betOnP2 = (niche.strat === 'underdog' && !dP1) || (niche.strat === 'favorite' && dP1);
                            var scoreDisplay = betOnP2 ? invertScore(m.score || '') : (m.score || '');
                            
                            bets.push({
                                date: m.date,
                                odds: odds,
                                opponentOdds: opponentOdds,
                                won: won,
                                niche: niche.name,
                                nicheId: niche.id,
                                nicheObj: niche, // R√©f√©rence √† la niche pour calcul du coef
                                circuit: circuitName,
                                player: niche.strat === 'underdog' ? (dP1 ? m.p1 : m.p2) : (dP1 ? m.p2 : m.p1),
                                opponent: niche.strat === 'underdog' ? (dP1 ? m.p2 : m.p1) : (dP1 ? m.p1 : m.p2),
                                tournament: m.tournament || m.category,
                                round: m.round,
                                surface: m.surface,
                                score: scoreDisplay
                            });
                            seenKeys[matchKey] = true;
                            break;
                        }
                    }
                }
            }
            
            // Collecter des deux circuits
            collectBetsFromCircuit(btDataATP, activeATP, 'ATP');
            collectBetsFromCircuit(btDataWTA, activeWTA, 'WTA');
            
            // Trier par date
            bets.sort(function(a, b) { return a.date.localeCompare(b.date); });
            return bets;
        }
        
        // Version combin√©e ATP+WTA avec checkboxes
        function getSimulationBetsCombinedNew(selectedNiches, startYear, curYear) {
            var bets = [];
            var seenKeys = {};
            
            function collectBets(data, niches, circuitName, selectedIds) {
                if (data.length === 0 || selectedIds.length === 0) return;
                
                var activeNiches = niches.filter(function(n) {
                    return selectedIds.indexOf(n.id) >= 0;
                });
                
                for (var i = 0; i < data.length; i++) {
                    var m = data[i];
                    if (m.year < startYear || m.year > curYear) continue;
                    
                    var matchKey = circuitName + '|' + m.date + '|' + m.p1 + '|' + m.p2;
                    if (seenKeys[matchKey]) continue;
                    
                    for (var j = 0; j < activeNiches.length; j++) {
                        var niche = activeNiches[j];
                        
                        var catKey = niche.cat.replace('Masters ', '').replace('WTA ', '').replace('Grand Slam', 'Grand');
                        if (!m.category || m.category.indexOf(catKey) < 0) continue;
                        if (m.surface !== niche.surf) continue;
                        
                        var roundMatch = false;
                        for (var r = 0; r < niche.rounds.length; r++) {
                            if (m.round === niche.rounds[r]) { roundMatch = true; break; }
                        }
                        if (!roundMatch) continue;
                        
                        var dO = Math.max(m.o1, m.o2);
                        var fO = Math.min(m.o1, m.o2);
                        var odds = niche.strat === 'underdog' ? dO : fO;
                        
                        if (odds >= niche.min && odds <= niche.max) {
                            var dP1 = m.o1 > m.o2;
                            var won = niche.strat === 'underdog' ? dP1 : !dP1;
                            
                            bets.push({
                                date: m.date,
                                odds: odds,
                                won: won,
                                niche: niche.name,
                                nicheId: niche.id,
                                nicheObj: niche,
                                circuit: circuitName,
                                player: niche.strat === 'underdog' ? (dP1 ? m.p1 : m.p2) : (dP1 ? m.p2 : m.p1),
                                opponent: niche.strat === 'underdog' ? (dP1 ? m.p2 : m.p1) : (dP1 ? m.p1 : m.p2),
                                tournament: m.tournament || m.category,
                                round: m.round,
                                surface: m.surface
                            });
                            seenKeys[matchKey] = true;
                            break;
                        }
                    }
                }
            }
            
            collectBets(btDataATP, NICHES_ATP, 'ATP', selectedNiches.atp || []);
            collectBets(btDataWTA, NICHES_WTA, 'WTA', selectedNiches.wta || []);
            
            bets.sort(function(a, b) { return a.date.localeCompare(b.date); });
            return bets;
        }
        
        // Simuler une strat√©gie de mise
        function simulateStrategy(bets, bankroll, strategy, params) {
            var results = [];
            var currentBankroll = bankroll;
            var totalStaked = 0;
            var peak = bankroll;
            var maxDrawdown = 0;
            var maxDrawdownAbs = 0;
            var returns = [];
            
            // Ajouter le point de d√©part
            results.push({
                date: 'start',
                bankroll: bankroll,
                pnl: 0,
                stake: 0,
                won: null,
                betNum: 0
            });
            
            for (var i = 0; i < bets.length; i++) {
                var bet = bets[i];
                var stake = 0;
                
                // Calculer la mise selon la strat√©gie
                if (strategy === 'flat') {
                    stake = Math.min(params.flatStake, currentBankroll);
                } else if (strategy === 'percent') {
                    stake = currentBankroll * params.pctStake / 100;
                } else if (strategy === 'kelly') {
                    // Kelly avec winrate global des donn√©es
                    var totalWins = bets.filter(function(b) { return b.won; }).length;
                    var winrate = totalWins / bets.length;
                    var avgOdds = bets.reduce(function(a, b) { return a + b.odds; }, 0) / bets.length;
                    var kellyPct = (winrate * avgOdds - 1) / (avgOdds - 1);
                    kellyPct = Math.max(0, Math.min(kellyPct, 0.20)); // Cap √† 20%
                    stake = currentBankroll * kellyPct / params.kellyDiv;
                }
                
                // Appliquer le coefficient de mise selon le mode
                var stakeCoef = 1.0;
                if (currentStakeMode === 'custom' && bet.nicheObj && bet.nicheObj.stakeCoef) {
                    // Mode custom : utiliser le coefficient personnalis√© de la niche
                    stakeCoef = bet.nicheObj.stakeCoef;
                }
                // Mode uniform : stakeCoef reste √† 1.0
                stake = stake * stakeCoef;
                
                // S'assurer qu'on peut miser (minimum 1‚Ç¨, maximum bankroll)
                stake = Math.max(0, Math.min(stake, currentBankroll));
                if (stake < 1 || currentBankroll < 1) {
                    // Faillite - plus assez pour miser
                    results.push({
                        date: bet.date,
                        bankroll: currentBankroll,
                        pnl: 0,
                        stake: 0,
                        won: null,
                        betNum: i + 1,
                        bankrupt: true
                    });
                    break;
                }
                
                totalStaked += stake;
                var pnl = bet.won ? stake * (bet.odds - 1) : -stake;
                currentBankroll += pnl;
                
                // Emp√™cher bankroll n√©gative
                if (currentBankroll < 0) currentBankroll = 0;
                
                // Calculer le return pour Sharpe
                returns.push(pnl / stake);
                
                // Update peak et drawdown
                if (currentBankroll > peak) peak = currentBankroll;
                var ddPct = peak > 0 ? (peak - currentBankroll) / peak * 100 : 0;
                var ddAbs = peak - currentBankroll;
                if (ddPct > maxDrawdown) maxDrawdown = ddPct;
                if (ddAbs > maxDrawdownAbs) maxDrawdownAbs = ddAbs;
                
                results.push({
                    date: bet.date,
                    bankroll: currentBankroll,
                    pnl: pnl,
                    stake: stake,
                    won: bet.won,
                    betNum: i + 1
                });
                
                // Faillite
                if (currentBankroll < 1) break;
            }
            
            // Calculer Sharpe Ratio
            var avgReturn = 0, stdReturn = 0;
            if (returns.length > 0) {
                avgReturn = returns.reduce(function(a, b) { return a + b; }, 0) / returns.length;
                var variance = returns.reduce(function(a, b) { return a + Math.pow(b - avgReturn, 2); }, 0) / returns.length;
                stdReturn = Math.sqrt(variance);
            }
            var sharpe = stdReturn > 0 ? (avgReturn / stdReturn) * Math.sqrt(returns.length) : 0;
            
            return {
                results: results,
                finalBankroll: currentBankroll,
                peakBankroll: peak,
                profit: currentBankroll - bankroll,
                roi: totalStaked > 0 ? ((currentBankroll - bankroll) / totalStaked * 100) : 0,
                maxDrawdown: maxDrawdown,
                maxDrawdownAbs: maxDrawdownAbs,
                totalBets: results.length - 1,
                totalStaked: totalStaked,
                sharpe: sharpe
            };
        }
        
        // Met √† jour le r√©sum√© des niches actives en haut du simulateur
        function updateSimNichesSummary() {
            var container = document.getElementById('simNichesSummary');
            if (!container) return;
            
            var activeATP = NICHES_ATP.filter(function(n) { return n.on; });
            var activeWTA = NICHES_WTA.filter(function(n) { return n.on; });
            
            if (activeATP.length === 0 && activeWTA.length === 0) {
                container.innerHTML = '<div style="color:var(--yellow);font-size:.85rem">‚ö†Ô∏è Aucune niche active. Active des niches dans Labo ‚Üí Mes Niches</div>';
                return;
            }
            
            var html = '';
            
            // ATP
            activeATP.forEach(function(n) {
                html += '<span style="background:rgba(34,197,94,.2);color:var(--green);padding:.25rem .5rem;border-radius:4px;font-size:.7rem;border:1px solid var(--green)">üü¢ ' + n.name + '</span>';
            });
            
            // WTA
            activeWTA.forEach(function(n) {
                html += '<span style="background:rgba(236,72,153,.2);color:var(--pink);padding:.25rem .5rem;border-radius:4px;font-size:.7rem;border:1px solid var(--pink)">ü©∑ ' + n.name + '</span>';
            });
            
            container.innerHTML = html;
            
            // Mettre √† jour les stats
            updateSimStats();
        }
        
        // ==================== PROJECTION ANNUELLE DYNAMIQUE ====================
        function calcProjectedProfit(circuitFilter) {
            // circuitFilter: 'atp', 'wta', 'all' ou undefined (= 'all')
            circuitFilter = circuitFilter || 'all';
            
            var curYear = new Date().getFullYear();
            
            // Lire les valeurs depuis Config (prioritaire) ou Simulateur
            var cfgBankrollEl = document.getElementById('cfgBankroll');
            var cfgStakeEl = document.getElementById('cfgStake');
            var cfgPctStakeEl = document.getElementById('cfgPctStake');
            var cfgStrategyEl = document.getElementById('cfgStakeStrategy');
            
            var bankroll = cfgBankrollEl ? parseFloat(cfgBankrollEl.value) || 5000 : 5000;
            var flatStake = cfgStakeEl ? parseFloat(cfgStakeEl.value) || 100 : 100;
            var pctStake = cfgPctStakeEl ? parseFloat(cfgPctStakeEl.value) || 3 : 3;
            var strategy = cfgStrategyEl ? cfgStrategyEl.value : 'flat';
            
            // Calculer la mise de base selon la strat√©gie
            var baseStake;
            if (strategy === 'flat') {
                baseStake = flatStake;
            } else { // percent
                baseStake = bankroll * (pctStake / 100);
            }
            
            console.log('calcProjectedProfit - strategy:', strategy, 'baseStake:', baseStake, 'bankroll:', bankroll, 'circuitFilter:', circuitFilter);
            
            var projections = [];
            var totalBetsPerYear = 0;
            var totalProfitPerYear = 0;
            var totalStakedPerYear = 0;
            
            // ATP niches actives (seulement si filter = 'all' ou 'atp')
            if (circuitFilter === 'all' || circuitFilter === 'atp') {
            NICHES_ATP.filter(function(n) { return n.on; }).forEach(function(n) {
                if (btDataATP.length === 0) return;
                
                var r = testComboV2(btDataATP, n.cat, n.surf, n.rounds, n.strat, n.min, n.max, curYear - 3, curYear);
                if (!r || r.bets < 5) return;
                
                var betsPerYear = r.bets / Math.max(1, r.yrs);
                var roi = r.roi / 100;
                var stakeCoef = n.stakeCoef || 1.0;
                var adjustedStake = baseStake * stakeCoef;
                var profitPerYear = betsPerYear * adjustedStake * roi;
                var stakedPerYear = betsPerYear * adjustedStake;
                
                projections.push({
                    name: n.name,
                    circuit: 'ATP',
                    betsPerYear: betsPerYear,
                    roi: r.roi,
                    stakeCoef: stakeCoef,
                    adjustedStake: adjustedStake,
                    profitPerYear: profitPerYear,
                    stakedPerYear: stakedPerYear
                });
                
                totalBetsPerYear += betsPerYear;
                totalProfitPerYear += profitPerYear;
                totalStakedPerYear += stakedPerYear;
            });
            }
            
            // WTA niches actives (seulement si filter = 'all' ou 'wta')
            if (circuitFilter === 'all' || circuitFilter === 'wta') {
            NICHES_WTA.filter(function(n) { return n.on; }).forEach(function(n) {
                if (btDataWTA.length === 0) return;
                
                var r = testComboV2(btDataWTA, n.cat, n.surf, n.rounds, n.strat, n.min, n.max, curYear - 3, curYear);
                if (!r || r.bets < 5) return;
                
                var betsPerYear = r.bets / Math.max(1, r.yrs);
                var roi = r.roi / 100;
                var stakeCoef = n.stakeCoef || 1.0;
                var adjustedStake = baseStake * stakeCoef;
                var profitPerYear = betsPerYear * adjustedStake * roi;
                var stakedPerYear = betsPerYear * adjustedStake;
                
                projections.push({
                    name: n.name,
                    circuit: 'WTA',
                    betsPerYear: betsPerYear,
                    roi: r.roi,
                    stakeCoef: stakeCoef,
                    adjustedStake: adjustedStake,
                    profitPerYear: profitPerYear,
                    stakedPerYear: stakedPerYear
                });
                
                totalBetsPerYear += betsPerYear;
                totalProfitPerYear += profitPerYear;
                totalStakedPerYear += stakedPerYear;
            });
            }
            
            var avgROI = totalStakedPerYear > 0 ? (totalProfitPerYear / totalStakedPerYear * 100) : 0;
            
            return {
                projections: projections,
                totalBetsPerYear: totalBetsPerYear,
                totalProfitPerYear: totalProfitPerYear,
                totalStakedPerYear: totalStakedPerYear,
                avgROI: avgROI,
                strategy: strategy,
                baseStake: baseStake,
                pctStake: pctStake
            };
        }
        
        // Flag pour √©viter les appels multiples dans la m√™me frame
        var projectionUpdatePending = false;
        
        // Wrapper avec requestAnimationFrame pour updateProjectionDisplay
        function updateProjectionDisplay() {
            console.log('[DEBUG] updateProjectionDisplay called');
            
            // Si une mise √† jour est d√©j√† programm√©e, on ne fait rien
            if (projectionUpdatePending) {
                console.log('[DEBUG] Update already pending, skipping');
                return;
            }
            
            projectionUpdatePending = true;
            
            // requestAnimationFrame garantit l'ex√©cution AVANT le prochain repaint
            requestAnimationFrame(function() {
                console.log('[DEBUG] RAF executed - calling doUpdateProjectionDisplay');
                projectionUpdatePending = false;
                doUpdateProjectionDisplay();
            });
        }
        
        // Fonction qui fait vraiment le boulot d'affichage de la projection
        function doUpdateProjectionDisplay() {
            var container = document.getElementById('projectionContent');
            if (!container) {
                console.log('projectionContent not found');
                return;
            }
            
            // Afficher un indicateur de chargement temporaire
            container.innerHTML = '<div style="text-align:center;padding:1rem;color:var(--muted)">‚è≥ Calcul en cours...</div>';
            
            // V√©rifier si les donn√©es sont charg√©es
            console.log('updateProjectionDisplay - btDataATP:', btDataATP.length, 'btDataWTA:', btDataWTA.length);
            
            if (btDataATP.length === 0 && btDataWTA.length === 0) {
                container.innerHTML = '<div style="text-align:center;padding:1rem">' +
                    '<div style="font-size:2rem;margin-bottom:.5rem">üìä</div>' +
                    '<div style="color:var(--muted)">Charge les CSV dans <b>Labo ‚Üí Backtest</b> pour voir les projections</div>' +
                    '</div>';
                return;
            }
            
            var proj = calcProjectedProfit();
            console.log('Projection calculated:', proj.projections.length, 'niches, strategy:', proj.strategy, 'baseStake:', Math.round(proj.baseStake));
            
            if (proj.projections.length === 0) {
                container.innerHTML = '<span style="color:var(--muted)">Charge les CSV et active des niches pour voir les projections</span>';
                return;
            }
            
            var html = '';
            
            // Afficher la strat√©gie utilis√©e
            var stratIcon = proj.strategy === 'flat' ? 'üíµ' : 'üìä';
            var stratName = proj.strategy === 'flat' ? 'Flat ' + Math.round(proj.baseStake) + '‚Ç¨' : proj.pctStake + '% BR';
            var stratColor = proj.strategy === 'flat' ? 'var(--blue)' : 'var(--green)';
            
            html += '<div style="background:' + stratColor + '22;border:1px solid ' + stratColor + ';border-radius:6px;padding:.5rem .75rem;margin-bottom:.75rem;font-size:.8rem;display:flex;justify-content:space-between;align-items:center">';
            html += '<span>' + stratIcon + ' <b>' + stratName + '</b></span>';
            html += '<span style="color:var(--muted)">Mise base: ' + Math.round(proj.baseStake) + '‚Ç¨</span>';
            html += '</div>';
            
            // R√©sum√© global
            html += '<div style="display:grid;grid-template-columns:repeat(4,1fr);gap:.5rem;margin-bottom:.75rem">';
            html += '<div style="background:var(--bg);border-radius:6px;padding:.5rem;text-align:center;border-left:3px solid var(--green)">';
            html += '<div style="font-size:1.1rem;font-weight:700;color:var(--green)">' + (proj.totalProfitPerYear >= 0 ? '+' : '') + proj.totalProfitPerYear.toFixed(0) + '‚Ç¨</div>';
            html += '<div style="font-size:.65rem;color:var(--muted)">Profit/an</div>';
            html += '</div>';
            html += '<div style="background:var(--bg);border-radius:6px;padding:.5rem;text-align:center">';
            html += '<div style="font-size:1.1rem;font-weight:700">' + Math.round(proj.totalBetsPerYear) + '</div>';
            html += '<div style="font-size:.65rem;color:var(--muted)">Paris/an</div>';
            html += '</div>';
            html += '<div style="background:var(--bg);border-radius:6px;padding:.5rem;text-align:center">';
            html += '<div style="font-size:1.1rem;font-weight:700">' + proj.totalStakedPerYear.toFixed(0) + '‚Ç¨</div>';
            html += '<div style="font-size:.65rem;color:var(--muted)">Mis√©/an</div>';
            html += '</div>';
            html += '<div style="background:var(--bg);border-radius:6px;padding:.5rem;text-align:center;border-left:3px solid var(--blue)">';
            html += '<div style="font-size:1.1rem;font-weight:700;color:var(--blue)">' + (proj.avgROI >= 0 ? '+' : '') + proj.avgROI.toFixed(1) + '%</div>';
            html += '<div style="font-size:.65rem;color:var(--muted)">ROI pond√©r√©</div>';
            html += '</div>';
            html += '</div>';
            
            // Projection mensuelle
            var monthlyProfit = proj.totalProfitPerYear / 12;
            var monthlyBets = proj.totalBetsPerYear / 12;
            html += '<div style="background:rgba(77,159,255,.1);border:1px solid var(--blue);border-radius:6px;padding:.5rem .75rem;margin-bottom:.75rem">';
            html += '<div style="font-size:.75rem;font-weight:600;color:var(--blue);margin-bottom:.15rem">üìÖ Projection mensuelle</div>';
            html += '<div style="font-size:.8rem">~' + Math.round(monthlyBets) + ' paris/mois ‚Üí <b>' + (monthlyProfit >= 0 ? '+' : '') + monthlyProfit.toFixed(0) + '‚Ç¨/mois</b></div>';
            html += '</div>';
            
            // D√©tail par niche
            html += '<div style="font-size:.7rem;font-weight:600;margin-bottom:.4rem;color:var(--muted)">üìä D√©tail par niche</div>';
            html += '<div style="max-height:180px;overflow-y:auto">';
            
            // Trier par profit d√©croissant
            proj.projections.sort(function(a, b) { return b.profitPerYear - a.profitPerYear; });
            
            proj.projections.forEach(function(p) {
                var circuitIcon = p.circuit === 'ATP' ? 'üü¢' : 'ü©∑';
                var coefDisplay = p.stakeCoef !== 1.0 ? '<span style="color:var(--yellow);font-size:.7rem">√ó' + p.stakeCoef.toFixed(1) + '</span> ' : '';
                var profitColor = p.profitPerYear >= 0 ? 'var(--green)' : 'var(--red)';
                
                html += '<div style="display:flex;justify-content:space-between;align-items:center;padding:.35rem .4rem;background:var(--bg);border-radius:4px;margin-bottom:.2rem;font-size:.7rem">';
                html += '<div style="flex:1;white-space:nowrap;overflow:hidden;text-overflow:ellipsis">' + circuitIcon + ' ' + p.name + '</div>';
                html += '<div style="text-align:right;white-space:nowrap">' + coefDisplay + Math.round(p.adjustedStake) + '‚Ç¨ √ó ' + Math.round(p.betsPerYear) + 'p ‚Üí <b style="color:' + profitColor + '">' + (p.profitPerYear >= 0 ? '+' : '') + Math.round(p.profitPerYear) + '‚Ç¨</b></div>';
                html += '</div>';
            });
            
            html += '</div>';
            
            console.log('[DEBUG] HTML generated, length:', html.length);
            
            // SOLUTION SIMPLE : on r√©assigne directement le innerHTML
            // L'artillerie lourde √©tait overkill et potentiellement probl√©matique
            container.innerHTML = html;
            
            // Forcer un reflow en lisant une propri√©t√© de layout
            void container.offsetHeight;
            
            console.log('[DEBUG] Projection updated - innerHTML set and reflow forced');
        }
        
        // Calcule les recommandations de mise bas√©es sur le DD max historique
        function updateStakeRecommendations() {
            console.log('updateStakeRecommendations called');
            var container = document.getElementById('stakeRecoContent');
            if (!container) {
                console.log('stakeRecoContent not found');
                return;
            }
            
            // Utiliser cfgBankroll (config) ou simBankroll (simulateur)
            var bankrollEl = document.getElementById('cfgBankroll') || document.getElementById('cfgBankroll');
            var bankroll = bankrollEl ? parseFloat(bankrollEl.value) || 5000 : 5000;
            var bets = getSimulationBets();
            console.log('Bets for recommendations:', bets.length, 'Bankroll:', bankroll);
            
            if (bets.length < 20) {
                container.innerHTML = '<span style="color:var(--muted)">Pas assez de donn√©es (min 20 paris) - ' + bets.length + ' trouv√©s. Charge les CSV dans Labo ‚Üí Backtest.</span>';
                return;
            }
            
            // Calculer le DD max en unit√©s
            var maxDDUnits = 0;
            var cum = 0;
            var peak = 0;
            
            for (var i = 0; i < bets.length; i++) {
                var pnl = bets[i].won ? (bets[i].odds - 1) : -1;
                cum += pnl;
                if (cum > peak) peak = cum;
                var dd = peak - cum;
                if (dd > maxDDUnits) maxDDUnits = dd;
            }
            
            // S√©rie perdante max
            var maxLosingStreak = 0;
            var curStreak = 0;
            for (var i = 0; i < bets.length; i++) {
                if (!bets[i].won) {
                    curStreak++;
                    if (curStreak > maxLosingStreak) maxLosingStreak = curStreak;
                } else {
                    curStreak = 0;
                }
            }
            maxLosingStreak = Math.max(maxLosingStreak, 5);
            
            // Ajouter marge de s√©curit√© (le DD futur peut √™tre pire)
            var ddWithMargin = maxDDUnits * 1.5; // +50% marge
            
            // Calculer les mises Flat recommand√©es
            var flatSafe = Math.floor((bankroll * 0.20) / ddWithMargin);
            var flatModerate = Math.floor((bankroll * 0.35) / ddWithMargin);
            var flatRisky = Math.floor((bankroll * 0.50) / ddWithMargin);
            
            // Calculer les % BR recommand√©s
            var pctSafe = Math.min(2, (20 / (maxLosingStreak * 1.2))).toFixed(1);
            var pctModerate = Math.min(3.5, (35 / (maxLosingStreak * 1.2))).toFixed(1);
            var pctRisky = Math.min(5, (50 / (maxLosingStreak * 1.2))).toFixed(1);
            
            var html = '';
            
            // Section Flat
            html += '<div style="margin-bottom:1rem">';
            html += '<div style="font-size:.75rem;font-weight:600;color:var(--blue);margin-bottom:.5rem">üíµ MISE FLAT</div>';
            html += '<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:.5rem">';
            
            html += '<div style="background:rgba(34,197,94,.1);border:1px solid var(--green);border-radius:6px;padding:.5rem;text-align:center;cursor:pointer" onclick="applyStakeReco(\'flat\',' + flatSafe + ',' + pctSafe + ')">';
            html += '<div style="font-size:.6rem;color:var(--green);font-weight:600">üõ°Ô∏è SAFE</div>';
            html += '<div style="font-size:1rem;font-weight:700">' + flatSafe + '‚Ç¨</div>';
            html += '<div style="font-size:.55rem;color:var(--muted)">DD max ~20%</div>';
            html += '</div>';
            
            html += '<div style="background:rgba(234,179,8,.1);border:1px solid var(--yellow);border-radius:6px;padding:.5rem;text-align:center;cursor:pointer" onclick="applyStakeReco(\'flat\',' + flatModerate + ',' + pctModerate + ')">';
            html += '<div style="font-size:.6rem;color:var(--yellow);font-weight:600">‚öñÔ∏è MOD√âR√â</div>';
            html += '<div style="font-size:1rem;font-weight:700">' + flatModerate + '‚Ç¨</div>';
            html += '<div style="font-size:.55rem;color:var(--muted)">DD max ~35%</div>';
            html += '</div>';
            
            html += '<div style="background:rgba(239,68,68,.1);border:1px solid var(--red);border-radius:6px;padding:.5rem;text-align:center;cursor:pointer" onclick="applyStakeReco(\'flat\',' + flatRisky + ',' + pctRisky + ')">';
            html += '<div style="font-size:.6rem;color:var(--red);font-weight:600">üî• RISQU√â</div>';
            html += '<div style="font-size:1rem;font-weight:700">' + flatRisky + '‚Ç¨</div>';
            html += '<div style="font-size:.55rem;color:var(--muted)">DD max ~50%</div>';
            html += '</div>';
            
            html += '</div></div>';
            
            // Section % Bankroll
            html += '<div>';
            html += '<div style="font-size:.75rem;font-weight:600;color:var(--green);margin-bottom:.5rem">üìä % BANKROLL</div>';
            html += '<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:.5rem">';
            
            html += '<div style="background:rgba(34,197,94,.1);border:1px solid var(--green);border-radius:6px;padding:.5rem;text-align:center;cursor:pointer" onclick="applyStakeReco(\'percent\',' + flatSafe + ',' + pctSafe + ')">';
            html += '<div style="font-size:.6rem;color:var(--green);font-weight:600">üõ°Ô∏è SAFE</div>';
            html += '<div style="font-size:1rem;font-weight:700">' + pctSafe + '%</div>';
            html += '<div style="font-size:.55rem;color:var(--muted)">DD max ~20%</div>';
            html += '</div>';
            
            html += '<div style="background:rgba(234,179,8,.1);border:1px solid var(--yellow);border-radius:6px;padding:.5rem;text-align:center;cursor:pointer" onclick="applyStakeReco(\'percent\',' + flatModerate + ',' + pctModerate + ')">';
            html += '<div style="font-size:.6rem;color:var(--yellow);font-weight:600">‚öñÔ∏è MOD√âR√â</div>';
            html += '<div style="font-size:1rem;font-weight:700">' + pctModerate + '%</div>';
            html += '<div style="font-size:.55rem;color:var(--muted)">DD max ~35%</div>';
            html += '</div>';
            
            html += '<div style="background:rgba(239,68,68,.1);border:1px solid var(--red);border-radius:6px;padding:.5rem;text-align:center;cursor:pointer" onclick="applyStakeReco(\'percent\',' + flatRisky + ',' + pctRisky + ')">';
            html += '<div style="font-size:.6rem;color:var(--red);font-weight:600">üî• RISQU√â</div>';
            html += '<div style="font-size:1rem;font-weight:700">' + pctRisky + '%</div>';
            html += '<div style="font-size:.55rem;color:var(--muted)">DD max ~50%</div>';
            html += '</div>';
            
            html += '</div></div>';
            
            html += '<div style="font-size:.6rem;color:var(--muted);margin-top:.75rem;text-align:center">DD historique: ' + maxDDUnits.toFixed(1) + 'u ‚Ä¢ S√©rie perdante max: ' + maxLosingStreak + ' ‚Ä¢ Clique pour appliquer</div>';
            
            container.innerHTML = html;
        }
        
        // Applique une recommandation de mise
        function applyStakeReco(strategy, flat, pct) {
            // Mettre √† jour les champs de config
            var cfgStake = document.getElementById('cfgStake');
            var cfgPctStake = document.getElementById('cfgPctStake');
            var cfgStrategy = document.getElementById('cfgStakeStrategy');
            
            if (cfgStake) cfgStake.value = flat;
            if (cfgPctStake) cfgPctStake.value = pct;
            if (cfgStrategy) cfgStrategy.value = strategy;
            
            // Mettre √† jour aussi les champs du simulateur si pr√©sents
            var simFlatStake = document.getElementById('cfgStake');
            var simPctStake = document.getElementById('cfgPctStake');
            if (simFlatStake) simFlatStake.value = flat;
            if (simPctStake) simPctStake.value = pct;
            
            // Mettre √† jour state et sauvegarder
            state.stake = flat;
            state.pctStake = parseFloat(pct);
            state.stakeStrategy = strategy;
            if (typeof saveState === 'function') saveState();
            
            // Mettre √† jour le calendrier
            if (typeof renderCalendar === 'function') renderCalendar();
            
            var strategyLabel = strategy === 'flat' ? flat + '‚Ç¨ flat' : pct + '% BR';
            showToast('‚úÖ Strat√©gie appliqu√©e: ' + strategyLabel, 'success');
        }
        
        // Synchronisation Config -> Affichage Simulateur
        function updateSimDisplay() {
            var cfgBankroll = document.getElementById('cfgBankroll');
            var cfgStake = document.getElementById('cfgStake');
            var cfgPctStake = document.getElementById('cfgPctStake');
            
            var bankroll = cfgBankroll ? parseFloat(cfgBankroll.value) || 5000 : 5000;
            var stake = cfgStake ? parseFloat(cfgStake.value) || 150 : 150;
            var pct = cfgPctStake ? parseFloat(cfgPctStake.value) || 3 : 3;
            
            var dispBankroll = document.getElementById('simDisplayBankroll');
            var dispFlat = document.getElementById('simDisplayFlat');
            var dispPct = document.getElementById('simDisplayPct');
            if (dispBankroll) dispBankroll.textContent = bankroll + '‚Ç¨';
            if (dispFlat) dispFlat.textContent = stake + '‚Ç¨';
            if (dispPct) dispPct.textContent = pct + '%';
        }
        
        // ==================== FONCTION CENTRALE DE MISE √Ä JOUR CONFIG ====================
        var configChangeDebounce = null;
        
        function onConfigChange() {
            // Debounce pour √©viter trop d'appels pendant la frappe
            if (configChangeDebounce) clearTimeout(configChangeDebounce);
            
            configChangeDebounce = setTimeout(function() {
                console.log('[CONFIG] Mise √† jour d√©clench√©e');
                
                try {
                    // 1. R√©cup√©rer les valeurs
                    var bankroll = parseFloat(document.getElementById('cfgBankroll').value) || 5000;
                    var flatStake = parseFloat(document.getElementById('cfgStake').value) || 150;
                    var pctStake = parseFloat(document.getElementById('cfgPctStake').value) || 3;
                    var strategy = document.getElementById('cfgStakeStrategy').value || 'flat';
                    
                    // 2. Mettre √† jour le state
                    state.bankroll = bankroll;
                    state.initialBankroll = bankroll;
                    state.stake = flatStake;
                    state.pctStake = pctStake;
                    state.stakeStrategy = strategy;
                    if (typeof saveState === 'function') saveState();
                    
                    // 3. Mettre √† jour TOUS les composants
                    console.log('[CONFIG] Mise √† jour des composants...');
                    
                    // Header bankroll (en haut √† droite)
                    var headerBankroll = document.getElementById('headerBankroll');
                    if (headerBankroll) {
                        headerBankroll.textContent = bankroll.toFixed(0) + '‚Ç¨';
                        console.log('[CONFIG] ‚Üí headerBankroll updated to', bankroll);
                    }
                    
                    // Affichage dans le Simulateur
                    try { updateSimDisplay(); } catch(e) { console.log('[CONFIG] updateSimDisplay error:', e.message); }
                    
                    // Projection annuelle (Config)
                    if (typeof updateProjectionDisplay === 'function') {
                        try {
                            console.log('[CONFIG] ‚Üí updateProjectionDisplay');
                            updateProjectionDisplay();
                        } catch(e) { console.log('[CONFIG] updateProjectionDisplay error:', e.message); }
                    }
                    
                    // Recommandations de mise
                    if (typeof updateStakeRecommendations === 'function') {
                        try {
                            console.log('[CONFIG] ‚Üí updateStakeRecommendations');
                            updateStakeRecommendations();
                        } catch(e) { console.log('[CONFIG] updateStakeRecommendations error:', e.message); }
                    }
                    
                    // Calendrier
                    if (typeof renderCalendar === 'function') {
                        try {
                            console.log('[CONFIG] ‚Üí renderCalendar');
                            renderCalendar();
                        } catch(e) { console.log('[CONFIG] renderCalendar error:', e.message); }
                    }
                    if (typeof updateCalendarProjections === 'function') {
                        try {
                            console.log('[CONFIG] ‚Üí updateCalendarProjections');
                            updateCalendarProjections();
                        } catch(e) { console.log('[CONFIG] updateCalendarProjections error:', e.message); }
                    }
                    
                    // Tracker
                    if (typeof updateTrackerStratInfo === 'function') {
                        try {
                            console.log('[CONFIG] ‚Üí updateTrackerStratInfo');
                            updateTrackerStratInfo();
                        } catch(e) { console.log('[CONFIG] updateTrackerStratInfo error:', e.message); }
                    }
                    
                    // Bandeau "Cette Semaine"
                    if (typeof checkWeekTournaments === 'function') {
                        try {
                            console.log('[CONFIG] ‚Üí checkWeekTournaments');
                            checkWeekTournaments();
                        } catch(e) { console.log('[CONFIG] checkWeekTournaments error:', e.message); }
                    }
                    
                    // Marquer la simulation comme obsol√®te si elle existe
                    var simResults = document.getElementById('simResults');
                    if (simResults && simResults.style.display !== 'none') {
                        showSimulationStaleWarning();
                    }
                    
                    console.log('[CONFIG] Mise √† jour termin√©e');
                    
                } catch(e) {
                    console.error('[CONFIG] Erreur globale:', e);
                }
                
            }, 150); // Debounce de 150ms
        }
        
        // Affiche un avertissement que la simulation doit √™tre relanc√©e
        function showSimulationStaleWarning() {
            var warningEl = document.getElementById('simStaleWarning');
            if (!warningEl) {
                // Cr√©er l'√©l√©ment d'avertissement
                var simResults = document.getElementById('simResults');
                if (simResults) {
                    var warning = document.createElement('div');
                    warning.id = 'simStaleWarning';
                    warning.style.cssText = 'background:rgba(234,179,8,.15);border:1px solid var(--yellow);border-radius:8px;padding:.75rem 1rem;margin-bottom:1rem;display:flex;justify-content:space-between;align-items:center';
                    warning.innerHTML = '<span style="color:var(--yellow);font-size:.85rem">‚ö†Ô∏è Les param√®tres ont chang√©. La simulation affich√©e peut √™tre obsol√®te.</span>' +
                        '<button onclick="runSimulation();hideSimulationStaleWarning()" style="padding:.4rem .8rem;background:var(--yellow);color:#000;border:none;border-radius:4px;cursor:pointer;font-size:.8rem;font-weight:600">üîÑ Relancer</button>';
                    simResults.insertBefore(warning, simResults.firstChild);
                }
            } else {
                warningEl.style.display = 'flex';
            }
        }
        
        function hideSimulationStaleWarning() {
            var warningEl = document.getElementById('simStaleWarning');
            if (warningEl) warningEl.style.display = 'none';
        }
        
        function syncBankroll(value) {
            var val = parseFloat(value) || 5000;
            state.bankroll = val;
            state.initialBankroll = val;
            if (typeof saveState === 'function') saveState();
            updateSimDisplay();
            // Mettre √† jour tous les composants d√©pendants
            if (typeof updateProjectionDisplay === 'function') updateProjectionDisplay();
            if (typeof updateCalendarProjections === 'function') updateCalendarProjections();
            if (typeof renderCalendar === 'function') renderCalendar();
        }
        
        function syncBankrollReverse(value) {
            // Plus utilis√© - supprim√©
        }
        
        function syncFlatStake(value) {
            var val = parseFloat(value) || 150;
            state.stake = val;
            if (typeof saveState === 'function') saveState();
            if (typeof updateCalendarProjections === 'function') updateCalendarProjections();
            if (typeof updateProjectionDisplay === 'function') updateProjectionDisplay();
            if (typeof renderCalendar === 'function') renderCalendar();
            updateSimDisplay();
        }
        
        function syncPctStake(value) {
            var val = parseFloat(value) || 3;
            state.pctStake = val;
            if (typeof saveState === 'function') saveState();
            if (typeof updateCalendarProjections === 'function') updateCalendarProjections();
            if (typeof updateProjectionDisplay === 'function') updateProjectionDisplay();
            if (typeof renderCalendar === 'function') renderCalendar();
            updateSimDisplay();
        }
        
        // Met √† jour la strat√©gie du calendrier
        function updateCalendarStrategy() {
            var cfgStrategy = document.getElementById('cfgStakeStrategy');
            if (cfgStrategy) {
                state.stakeStrategy = cfgStrategy.value;
                if (typeof saveState === 'function') saveState();
                if (typeof renderCalendar === 'function') renderCalendar();
            }
        }
        
        // Met √† jour les stats du simulateur (paris, winrate, ROI)
        function updateSimStats() {
            var bets = getSimulationBets();
            
            var betsEl = document.getElementById('simStatBets');
            var wrEl = document.getElementById('simStatWinrate');
            var roiEl = document.getElementById('simStatROI');
            
            if (bets.length === 0) {
                if (betsEl) betsEl.textContent = '-';
                if (wrEl) wrEl.textContent = '-';
                if (roiEl) roiEl.textContent = '-';
                return;
            }
            
            var wins = bets.filter(function(b) { return b.won; }).length;
            var profit = bets.reduce(function(sum, b) {
                return sum + (b.won ? (b.odds - 1) : -1);
            }, 0);
            var roi = (profit / bets.length * 100);
            var winrate = (wins / bets.length * 100);
            
            if (betsEl) betsEl.textContent = bets.length;
            if (wrEl) wrEl.textContent = winrate.toFixed(0) + '%';
            if (roiEl) {
                roiEl.textContent = (roi >= 0 ? '+' : '') + roi.toFixed(0) + '%';
                roiEl.style.color = roi >= 0 ? 'var(--green)' : 'var(--red)';
            }
        }
        
        // ==================== GESTION DES MODES DE MISE PAR NICHE ====================
        var currentStakeMode = 'uniform';
        
        // ==================== S√âLECTEUR D'ANN√âES ET MODE D'AFFICHAGE ====================
        var selectedSimYears = []; // Ann√©es s√©lectionn√©es pour la simulation
        var monthlyDisplayMode = 'euros'; // 'euros' ou 'units'
        var yearlyDisplayMode = 'euros'; // 'euros' ou 'units'
        
        // Initialise le s√©lecteur d'ann√©es avec les ann√©es disponibles dans les donn√©es
        function initYearSelector() {
            var container = document.getElementById('simYearSelector');
            if (!container) return;
            
            // Collecter les ann√©es disponibles depuis les donn√©es ATP et WTA
            var years = new Set();
            
            if (btDataATP && btDataATP.length > 0) {
                btDataATP.forEach(function(row) {
                    if (row.date) {
                        var y = row.date.substring(0, 4);
                        if (y && !isNaN(parseInt(y))) years.add(y);
                    }
                });
            }
            
            if (btDataWTA && btDataWTA.length > 0) {
                btDataWTA.forEach(function(row) {
                    if (row.date) {
                        var y = row.date.substring(0, 4);
                        if (y && !isNaN(parseInt(y))) years.add(y);
                    }
                });
            }
            
            var sortedYears = Array.from(years).sort();
            
            if (sortedYears.length === 0) {
                container.innerHTML = '<span style="font-size:.7rem;color:var(--muted)">Chargez les donn√©es CSV d\'abord</span>';
                return;
            }
            
            // Par d√©faut, s√©lectionner les 3 derni√®res ann√©es (ou conserver la s√©lection existante)
            if (selectedSimYears.length === 0) {
                selectedSimYears = sortedYears.slice(-3);
            }
            
            // Cr√©er les boutons
            var html = '<button onclick="toggleAllSimYears()" style="padding:.25rem .4rem;font-size:.65rem;border:1px solid var(--border);background:transparent;color:var(--muted);border-radius:4px;cursor:pointer;margin-right:.25rem">Tout</button>';
            
            sortedYears.forEach(function(y) {
                var isSelected = selectedSimYears.indexOf(y) >= 0;
                html += '<button onclick="toggleSimYear(\'' + y + '\')" id="simYearBtn' + y + '" style="padding:.25rem .4rem;font-size:.65rem;border:1px solid ' + (isSelected ? 'var(--blue)' : 'var(--border)') + ';background:' + (isSelected ? 'var(--blue)' : 'transparent') + ';color:' + (isSelected ? '#fff' : 'var(--muted)') + ';border-radius:4px;cursor:pointer">' + y + '</button>';
            });
            
            container.innerHTML = html;
        }
        
        // Toggle une ann√©e dans la s√©lection
        function toggleSimYear(year) {
            var idx = selectedSimYears.indexOf(year);
            if (idx >= 0) {
                selectedSimYears.splice(idx, 1);
            } else {
                selectedSimYears.push(year);
            }
            selectedSimYears.sort();
            updateYearButtons();
        }
        
        // S√©lectionner/d√©s√©lectionner toutes les ann√©es
        function toggleAllSimYears() {
            var container = document.getElementById('simYearSelector');
            var allButtons = container.querySelectorAll('button[id^="simYearBtn"]');
            var allYears = [];
            allButtons.forEach(function(btn) {
                allYears.push(btn.id.replace('simYearBtn', ''));
            });
            
            if (selectedSimYears.length === allYears.length) {
                // Tout est s√©lectionn√© ‚Üí d√©s√©lectionner tout sauf les 3 derni√®res
                selectedSimYears = allYears.slice(-3);
            } else {
                // S√©lectionner tout
                selectedSimYears = allYears.slice();
            }
            updateYearButtons();
        }
        
        // Met √† jour l'apparence des boutons d'ann√©es
        function updateYearButtons() {
            var container = document.getElementById('simYearSelector');
            if (!container) return;
            
            var buttons = container.querySelectorAll('button[id^="simYearBtn"]');
            buttons.forEach(function(btn) {
                var year = btn.id.replace('simYearBtn', '');
                var isSelected = selectedSimYears.indexOf(year) >= 0;
                btn.style.border = '1px solid ' + (isSelected ? 'var(--blue)' : 'var(--border)');
                btn.style.background = isSelected ? 'var(--blue)' : 'transparent';
                btn.style.color = isSelected ? '#fff' : 'var(--muted)';
            });
        }
        
        // Change le mode d'affichage du d√©tail mensuel (‚Ç¨ ou Unit√©s)
        function setMonthlyDisplayMode(mode) {
            monthlyDisplayMode = mode;
            
            var btnEuros = document.getElementById('btnMonthlyEuros');
            var btnUnits = document.getElementById('btnMonthlyUnits');
            
            if (mode === 'euros') {
                btnEuros.style.background = 'var(--blue)';
                btnEuros.style.color = '#fff';
                btnEuros.style.border = '1px solid var(--blue)';
                btnUnits.style.background = 'transparent';
                btnUnits.style.color = 'var(--muted)';
                btnUnits.style.border = '1px solid var(--border)';
            } else {
                btnUnits.style.background = 'var(--blue)';
                btnUnits.style.color = '#fff';
                btnUnits.style.border = '1px solid var(--blue)';
                btnEuros.style.background = 'transparent';
                btnEuros.style.color = 'var(--muted)';
                btnEuros.style.border = '1px solid var(--border)';
            }
            
            // Rafra√Æchir le tableau
            if (window.simBetsCache) {
                renderMonthlyDetail();
            }
        }
        
        // Change le mode d'affichage du d√©tail annuel (‚Ç¨ ou Unit√©s)
        function setYearlyDisplayMode(mode) {
            yearlyDisplayMode = mode;
            
            var btnEuros = document.getElementById('btnYearlyEuros');
            var btnUnits = document.getElementById('btnYearlyUnits');
            
            if (mode === 'euros') {
                btnEuros.style.background = 'var(--blue)';
                btnEuros.style.color = '#fff';
                btnEuros.style.border = '1px solid var(--blue)';
                btnUnits.style.background = 'transparent';
                btnUnits.style.color = 'var(--muted)';
                btnUnits.style.border = '1px solid var(--border)';
            } else {
                btnUnits.style.background = 'var(--blue)';
                btnUnits.style.color = '#fff';
                btnUnits.style.border = '1px solid var(--blue)';
                btnEuros.style.background = 'transparent';
                btnEuros.style.color = 'var(--muted)';
                btnEuros.style.border = '1px solid var(--border)';
            }
            
            // Rafra√Æchir l'affichage
            if (window.simBetsCache) {
                renderYearlyBreakdown(window.simBetsCache.bets, window.simBetsCache.flatStake, window.simBetsCache.pctStake || 3);
            }
        }
        
        function setStakeMode(mode) {
            currentStakeMode = mode;
            var infoDiv = document.getElementById('stakeModeInfo');
            
            if (mode === 'uniform') {
                infoDiv.style.display = 'block';
                infoDiv.innerHTML = 'üíµ Toutes les mises seront identiques (coefficients personnalis√©s ignor√©s).';
                infoDiv.style.background = 'rgba(77,159,255,.1)';
                infoDiv.style.color = 'var(--blue)';
            } else if (mode === 'custom') {
                infoDiv.style.display = 'block';
                infoDiv.innerHTML = '‚úèÔ∏è Les coefficients d√©finis dans <a href="#" onclick="showMainTab(\'lab\');setLabMode(\'niches\');return false" style="color:var(--yellow);font-weight:600">Labo ‚Üí Mes Niches</a> seront appliqu√©s.';
                infoDiv.style.background = 'rgba(234,179,8,.1)';
                infoDiv.style.color = 'var(--yellow)';
            }
        }
        
        // Calcule le coefficient de variance automatique pour une niche (gard√© pour calcRecommendedCoef)
        function calcVarianceCoef(niche, betsForNiche) {
            // Bas√© sur la cote moyenne de la niche
            var avgOdds = (niche.min + niche.max) / 2;
            
            // Coefficient inversement proportionnel √† la cote
            // Cotes 1.5-2 ‚Üí coef 1.3
            // Cotes 2-3 ‚Üí coef 1.0
            // Cotes 3-5 ‚Üí coef 0.7
            // Cotes 5-7 ‚Üí coef 0.5
            
            var coef;
            if (avgOdds <= 2) {
                coef = 1.3;
            } else if (avgOdds <= 2.5) {
                coef = 1.15;
            } else if (avgOdds <= 3) {
                coef = 1.0;
            } else if (avgOdds <= 4) {
                coef = 0.85;
            } else if (avgOdds <= 5) {
                coef = 0.7;
            } else if (avgOdds <= 6) {
                coef = 0.6;
            } else {
                coef = 0.5;
            }
            
            // Ajustement selon le winrate r√©el si on a des donn√©es
            if (betsForNiche && betsForNiche.length >= 20) {
                var wins = betsForNiche.filter(function(b) { return b.won; }).length;
                var wr = wins / betsForNiche.length;
                var expectedWr = 1 / avgOdds;
                
                // Si le winrate r√©el est meilleur que pr√©vu, on peut augmenter l√©g√®rement
                if (wr > expectedWr * 1.1) {
                    coef *= 1.1;
                }
                // Si le winrate est pire, on r√©duit
                else if (wr < expectedWr * 0.9) {
                    coef *= 0.9;
                }
            }
            
            // Limiter entre 0.4 et 1.5
            return Math.max(0.4, Math.min(1.5, coef));
        }
        
        // Calcule le coefficient RECOMMAND√â bas√© sur une formule math√©matique
        // Formule r√©vis√©e avec : Shrinkage Bay√©sien + Borne basse + Tendance + Variance
        function calcRecommendedCoef(niche, rAll, r3) {
            // Pas assez de donn√©es = prudence
            if (!rAll || rAll.bets < 20) return 0.6;
            if (rAll.bets < 30) return 0.7;
            
            // 1. ROI ajust√© avec shrinkage bay√©sien
            // On "shrink" vers un ROI r√©aliste de 2% (edge long terme r√©aliste)
            // Plus on a de donn√©es, plus on fait confiance au ROI observ√©
            var k = 80; // Prior strength (√©quivalent √† 80 paris fictifs √† 2% ROI)
            var priorROI = 2; // Prior: edge r√©aliste long terme
            var roiAdj = (rAll.bets * rAll.roi + k * priorROI) / (rAll.bets + k);
            
            // 2. P√©nalit√© incertitude (erreur standard approxim√©e)
            // SE ‚âà 100 / sqrt(n) pour des paris √† cotes ~2.5
            var avgOdds = (niche.min + niche.max) / 2;
            var se = (avgOdds * 30) / Math.sqrt(rAll.bets); // Ajust√© aux cotes
            var roiLower = roiAdj - se; // Borne basse √† 1 sigma (68% confiance)
            
            // 3. Base coefficient selon la borne basse du ROI
            var base;
            if (roiLower < -5) base = 0.4;      // Probablement perdant
            else if (roiLower < 0) base = 0.55; // Risque de n√©gatif
            else if (roiLower < 2) base = 0.7;  // Edge faible/incertain
            else if (roiLower < 5) base = 0.85; // Edge probable mais modeste
            else if (roiLower < 8) base = 1.0;  // Bon edge confirm√©
            else if (roiLower < 12) base = 1.1; // Tr√®s bon edge
            else base = 1.2;                     // Edge exceptionnel (rare)
            
            // 4. Ajustement tendance (ROI r√©cent vs historique)
            var trend = 1.0;
            if (r3 && r3.bets >= 15) {
                var diff = r3.roi - rAll.roi;
                // Tendance influence de ¬±15% max
                trend = Math.max(0.75, Math.min(1.15, 1 + diff / 40));
                
                // Malus suppl√©mentaire si ROI r√©cent n√©gatif
                if (r3.roi < 0) {
                    trend *= 0.85;
                }
            }
            
            // 5. Ajustement variance (cotes hautes = plus de variance = r√©duire)
            // Cotes basses (1.5-2) ‚Üí variance faible ‚Üí peut augmenter l√©g√®rement
            // Cotes hautes (4-6) ‚Üí variance √©lev√©e ‚Üí r√©duire
            var varianceAdj;
            if (avgOdds <= 1.8) varianceAdj = 1.08;
            else if (avgOdds <= 2.2) varianceAdj = 1.03;
            else if (avgOdds <= 2.8) varianceAdj = 1.0;
            else if (avgOdds <= 3.5) varianceAdj = 0.92;
            else if (avgOdds <= 4.5) varianceAdj = 0.82;
            else if (avgOdds <= 6) varianceAdj = 0.7;
            else varianceAdj = 0.6;
            
            // 6. Ajustement r√©gularit√© (ann√©es positives r√©centes)
            var regularityAdj = 1.0;
            if (rAll.yearlyData && rAll.yearlyData.length >= 3) {
                var recentYears = rAll.yearlyData.slice(-5);
                var posCount = recentYears.filter(function(y) { return y.roi > 0; }).length;
                var negCount = recentYears.length - posCount;
                
                // Malus si majorit√© d'ann√©es n√©gatives r√©cemment
                if (negCount >= 3) regularityAdj = 0.8;
                else if (negCount >= 2) regularityAdj = 0.9;
                // Bonus l√©ger si toutes positives
                else if (posCount === recentYears.length && recentYears.length >= 4) {
                    regularityAdj = 1.05;
                }
            }
            
            // Calcul final
            var coef = base * trend * varianceAdj * regularityAdj;
            
            // Plafonner entre 0.4 et 1.3 (jamais surpond√©rer excessivement)
            coef = Math.max(0.4, Math.min(1.3, coef));
            
            // Arrondir √† 0.05 pr√®s
            return Math.round(coef * 20) / 20;
        }
        
        // Applique le coefficient recommand√©
        function applyRecommendedCoef(nicheId, circuit, coef) {
            var sliderId = 'slider-' + nicheId;
            var numId = 'num-' + nicheId;
            
            var slider = document.getElementById(sliderId);
            var num = document.getElementById(numId);
            
            if (slider) slider.value = coef;
            if (num) num.value = coef;
            
            updateNicheStakeCoef(nicheId, circuit, coef);
        }
        
        // R√©cup√®re le coefficient de mise pour une niche donn√©e
        function getStakeCoefForNiche(niche, betsForNiche) {
            if (currentStakeMode === 'uniform') {
                return 1.0;
            } else if (currentStakeMode === 'custom') {
                // Utiliser le coefficient personnalis√© de la niche, ou 1.0 par d√©faut
                return niche.stakeCoef || 1.0;
            }
            return 1.0;
        }
        
        function runSimulation() {
            console.log('runSimulation called');
            
            // Mettre √† jour le r√©sum√© d'abord
            updateSimNichesSummary();
            
            var bets = getSimulationBets();
            console.log('Bets found:', bets.length);
            
            if (bets.length < 10) {
                alert('Pas assez de donn√©es pour la simulation (minimum 10 paris).\n\n‚Ä¢ V√©rifie que tu as charg√© les CSV\n‚Ä¢ V√©rifie que tu as des niches actives (ON) dans le Labo\n\nParis trouv√©s: ' + bets.length);
                return;
            }
            
            // Lire les valeurs depuis CONFIG (onglet ‚öôÔ∏è)
            var cfgBankroll = document.getElementById('cfgBankroll');
            var cfgStake = document.getElementById('cfgStake');
            var cfgPctStake = document.getElementById('cfgPctStake');
            
            var bankroll = cfgBankroll ? parseFloat(cfgBankroll.value) || 5000 : 5000;
            var flatStake = cfgStake ? parseFloat(cfgStake.value) || 150 : 150;
            var pctStake = cfgPctStake ? parseFloat(cfgPctStake.value) || 3 : 3;
            var kellyDiv = 4; // Valeur par d√©faut
            
            console.log('Config values:', { bankroll: bankroll, flatStake: flatStake, pctStake: pctStake });
            
            // Mettre √† jour l'affichage dans le simulateur
            var dispBankroll = document.getElementById('simDisplayBankroll');
            var dispFlat = document.getElementById('simDisplayFlat');
            var dispPct = document.getElementById('simDisplayPct');
            if (dispBankroll) dispBankroll.textContent = bankroll + '‚Ç¨';
            if (dispFlat) dispFlat.textContent = flatStake + '‚Ç¨';
            if (dispPct) dispPct.textContent = pctStake + '%';
            
            // Calculer stats des donn√©es
            var wins = bets.filter(function(b) { return b.won; }).length;
            var winrate = (wins / bets.length * 100).toFixed(1);
            var avgOdds = (bets.reduce(function(a, b) { return a + b.odds; }, 0) / bets.length).toFixed(2);
            var years = {};
            bets.forEach(function(b) { 
                var y = b.date.substring(0, 4); 
                years[y] = true; 
            });
            var numYears = Object.keys(years).length || 1;
            
            console.log('Stats calculated:', { wins, winrate, avgOdds, numYears });
            
            // Simuler les 3 strat√©gies
            console.log('Running simulations...');
            var flatSim = simulateStrategy(bets, bankroll, 'flat', { flatStake: flatStake });
            console.log('Flat done:', flatSim);
            var pctSim = simulateStrategy(bets, bankroll, 'percent', { pctStake: pctStake });
            console.log('Pct done:', pctSim);
            var kellySim = simulateStrategy(bets, bankroll, 'kelly', { kellyDiv: kellyDiv });
            console.log('Kelly done:', kellySim);
            
            // Stocker les donn√©es pour le switch de strat√©gie
            simStrategiesData = {
                flat: flatSim,
                pct: pctSim,
                kelly: kellySim,
                bets: bets,
                params: {
                    bankroll: bankroll,
                    flatStake: flatStake,
                    pctStake: pctStake,
                    kellyDiv: kellyDiv
                }
            };
            
            // Mettre √† jour les infos des tabs
            var tabFlatInfo = document.getElementById('tabFlatInfo');
            var tabPctInfo = document.getElementById('tabPctInfo');
            var tabKellyInfo = document.getElementById('tabKellyInfo');
            if (tabFlatInfo) tabFlatInfo.textContent = flatStake + '‚Ç¨ ‚Üí ' + (flatSim.profit >= 0 ? '+' : '') + formatMoneyShort(flatSim.profit);
            if (tabPctInfo) tabPctInfo.textContent = pctStake + '% ‚Üí ' + (pctSim.profit >= 0 ? '+' : '') + formatMoneyShort(pctSim.profit);
            if (tabKellyInfo) tabKellyInfo.textContent = '√∑' + kellyDiv + ' ‚Üí ' + (kellySim.profit >= 0 ? '+' : '') + formatMoneyShort(kellySim.profit);
            
            // Afficher les r√©sultats
            safeDisplay('simResults', true);
            
            // Cacher l'avertissement de simulation obsol√®te
            if (typeof hideSimulationStaleWarning === 'function') hideSimulationStaleWarning();
            
            // Initialiser la vue sur la strat√©gie s√©lectionn√©e
            selectViewStrategy(currentViewStrategy);
            
            // Remplir les stats principales (style Playground)
            var totalPnl = flatSim.profit;
            safeText('simResBets', bets.length);
            safeText('simResWins', wins);
            safeText('simResWR', winrate + '%');
            safeText('simResProfit', (totalPnl >= 0 ? '+' : '') + totalPnl.toFixed(0) + '‚Ç¨');
            document.getElementById('simResProfit').className = 'val ' + (totalPnl >= 0 ? 'pos' : 'neg');
            safeText('simResROI', (flatSim.roi >= 0 ? '+' : '') + flatSim.roi.toFixed(1) + '%');
            document.getElementById('simResROI').className = 'val ' + (flatSim.roi >= 0 ? 'pos' : 'neg');
            safeText('simResDD', '-' + flatSim.maxDrawdownAbs.toFixed(0) + '‚Ç¨');
            
            // R√©sultats Flat (si l'√©l√©ment existe)
            var flatResultEl = document.getElementById('simFlatResult');
            if (flatResultEl) {
                var flatHtml = '<div style="display:grid;grid-template-columns:repeat(2,1fr);gap:.5rem;font-size:.85rem">' +
                    '<div>Profit: <span style="color:' + (flatSim.profit >= 0 ? 'var(--green)' : 'var(--red)') + ';font-weight:700">' + (flatSim.profit >= 0 ? '+' : '') + flatSim.profit.toFixed(0) + '‚Ç¨</span></div>' +
                    '<div>ROI: <span style="color:' + (flatSim.roi >= 0 ? 'var(--green)' : 'var(--red)') + '">' + (flatSim.roi >= 0 ? '+' : '') + flatSim.roi.toFixed(1) + '%</span></div>' +
                    '<div>Max DD: <span style="color:var(--red)">-' + flatSim.maxDrawdownAbs.toFixed(0) + '‚Ç¨</span></div>' +
                    '<div>Bankroll fin: <span style="font-weight:700">' + flatSim.finalBankroll.toFixed(0) + '‚Ç¨</span></div>' +
                    '</div>';
                flatResultEl.innerHTML = flatHtml;
            }
            
            // R√©sultats % Bankroll (si l'√©l√©ment existe)
            var pctResultEl = document.getElementById('simPctResult');
            if (pctResultEl) {
                var pctHtml = '<div style="display:grid;grid-template-columns:repeat(2,1fr);gap:.5rem;font-size:.85rem">' +
                    '<div>Profit: <span style="color:' + (pctSim.profit >= 0 ? 'var(--green)' : 'var(--red)') + ';font-weight:700">' + (pctSim.profit >= 0 ? '+' : '') + pctSim.profit.toFixed(0) + '‚Ç¨</span></div>' +
                    '<div>ROI: <span style="color:' + (pctSim.roi >= 0 ? 'var(--green)' : 'var(--red)') + '">' + (pctSim.roi >= 0 ? '+' : '') + pctSim.roi.toFixed(1) + '%</span></div>' +
                    '<div>Max DD: <span style="color:var(--red)">-' + pctSim.maxDrawdown.toFixed(1) + '%</span></div>' +
                    '<div>Bankroll fin: <span style="font-weight:700">' + pctSim.finalBankroll.toFixed(0) + '‚Ç¨</span></div>' +
                    '</div>';
                pctResultEl.innerHTML = pctHtml;
            }
            
            // Verdict
            var verdictEl = document.getElementById('simVerdict');
            var bestStrategy = flatSim.profit > pctSim.profit ? 'Flat' : '% Bankroll';
            var bestProfit = Math.max(flatSim.profit, pctSim.profit);
            var avgProfitPerYear = bestProfit / numYears;
            
            if (bestProfit > 0) {
                verdictEl.style.display = 'block';
                verdictEl.style.borderLeft = '4px solid var(--green)';
                verdictEl.innerHTML = '<div style="display:flex;align-items:center;gap:1rem">' +
                    '<span style="font-size:2rem">üèÜ</span>' +
                    '<div><div style="font-weight:700">Strat√©gie rentable !</div>' +
                    '<div style="font-size:.8rem;color:var(--muted)">' + bestStrategy + ' gagne ‚Ä¢ ~+' + avgProfitPerYear.toFixed(0) + '‚Ç¨/an ‚Ä¢ ' + bets.length + ' paris sur ' + numYears + ' ans</div></div></div>';
            } else {
                verdictEl.style.display = 'block';
                verdictEl.style.borderLeft = '4px solid var(--red)';
                verdictEl.innerHTML = '<div style="display:flex;align-items:center;gap:1rem">' +
                    '<span style="font-size:2rem">‚ùå</span>' +
                    '<div><div style="font-weight:700">Strat√©gie non rentable</div>' +
                    '<div style="font-size:.8rem;color:var(--muted)">Perte de ' + Math.abs(bestProfit).toFixed(0) + '‚Ç¨ sur ' + numYears + ' ans</div></div></div>';
            }
            
            // S√©ries (style Playground)
            var simStreaks = calcStreaks(bets.map(function(b) { 
                return { 
                    won: b.won, 
                    pnl: b.won ? (b.odds - 1) : -1, 
                    date: b.date, 
                    betOn: b.player || b.betOn, 
                    vs: b.opponent || b.vs || '', 
                    odds: b.odds,
                    opponentOdds: b.opponentOdds || 0,
                    score: b.score || '', 
                    tournament: b.tournament || '', 
                    round: b.round || '' 
                }; 
            }), flatStake);
            
            // Pire s√©rie perdante
            var worstHtml = '';
            if (simStreaks.worstLosing.length > 0) {
                var worstLoss = simStreaks.worstLosing.reduce(function(sum, r) { return sum + r.pnl * flatStake; }, 0);
                worstHtml += '<div style="font-weight:700;color:var(--red);margin-bottom:.5rem">' + simStreaks.worstLosing.length + ' d√©faites cons√©cutives ‚Ä¢ ' + worstLoss.toFixed(0) + '‚Ç¨</div>';
                worstHtml += '<div style="max-height:250px;overflow-y:auto">';
                simStreaks.worstLosing.forEach(function(r, idx) {
                    worstHtml += '<div style="padding:.5rem;font-size:.75rem;border-bottom:1px solid var(--border);background:rgba(239,68,68,.05)">';
                    worstHtml += '<div style="display:flex;justify-content:space-between;align-items:center">';
                    worstHtml += '<span style="color:var(--muted);font-size:.65rem">' + (r.date || '') + '</span>';
                    worstHtml += '<span style="color:var(--red);font-weight:600">' + (r.pnl * flatStake).toFixed(0) + '‚Ç¨</span>';
                    worstHtml += '</div>';
                    worstHtml += '<div style="margin-top:.25rem">';
                    worstHtml += '<span style="color:var(--red)">‚ùå</span> ';
                    worstHtml += '<span style="background:rgba(239,68,68,.2);padding:.1rem .3rem;border-radius:3px;font-weight:700">' + (r.betOn || '?') + '</span>';
                    worstHtml += ' <span style="color:var(--blue);font-size:.7rem">@' + (r.odds ? r.odds.toFixed(2) : '-') + '</span>';
                    worstHtml += ' <span style="color:var(--muted)">vs</span> ';
                    worstHtml += '<span>' + (r.vs || '?') + '</span>';
                    worstHtml += ' <span style="color:var(--muted);font-size:.7rem">@' + (r.opponentOdds ? r.opponentOdds.toFixed(2) : '-') + '</span>';
                    if (r.score) worstHtml += ' <span style="color:var(--text);font-size:.7rem;font-weight:600">(' + formatScore(r.score) + ')</span>';
                    worstHtml += '</div>';
                    if (r.tournament) worstHtml += '<div style="font-size:.65rem;color:var(--muted);margin-top:.15rem">' + r.tournament + (r.round ? ' ‚Ä¢ ' + r.round : '') + '</div>';
                    worstHtml += '</div>';
                });
                worstHtml += '</div>';
            } else {
                worstHtml = '<div style="color:var(--muted)">-</div>';
            }
            safeHTML('simWorstStreak', worstHtml);
            
            // Meilleure s√©rie gagnante
            var bestHtml = '';
            if (simStreaks.bestWinning.length > 0) {
                var bestWin = simStreaks.bestWinning.reduce(function(sum, r) { return sum + r.pnl * flatStake; }, 0);
                bestHtml += '<div style="font-weight:700;color:var(--green);margin-bottom:.5rem">' + simStreaks.bestWinning.length + ' victoires cons√©cutives ‚Ä¢ +' + bestWin.toFixed(0) + '‚Ç¨</div>';
                bestHtml += '<div style="max-height:250px;overflow-y:auto">';
                simStreaks.bestWinning.forEach(function(r, idx) {
                    bestHtml += '<div style="padding:.5rem;font-size:.75rem;border-bottom:1px solid var(--border);background:rgba(34,197,94,.05)">';
                    bestHtml += '<div style="display:flex;justify-content:space-between;align-items:center">';
                    bestHtml += '<span style="color:var(--muted);font-size:.65rem">' + (r.date || '') + '</span>';
                    bestHtml += '<span style="color:var(--green);font-weight:600">+' + (r.pnl * flatStake).toFixed(0) + '‚Ç¨</span>';
                    bestHtml += '</div>';
                    bestHtml += '<div style="margin-top:.25rem">';
                    bestHtml += '<span style="color:var(--green)">‚úÖ</span> ';
                    bestHtml += '<span style="background:rgba(34,197,94,.2);padding:.1rem .3rem;border-radius:3px;font-weight:700">' + (r.betOn || '?') + '</span>';
                    bestHtml += ' <span style="color:var(--blue);font-size:.7rem">@' + (r.odds ? r.odds.toFixed(2) : '-') + '</span>';
                    bestHtml += ' <span style="color:var(--muted)">vs</span> ';
                    bestHtml += '<span>' + (r.vs || '?') + '</span>';
                    bestHtml += ' <span style="color:var(--muted);font-size:.7rem">@' + (r.opponentOdds ? r.opponentOdds.toFixed(2) : '-') + '</span>';
                    if (r.score) bestHtml += ' <span style="color:var(--text);font-size:.7rem;font-weight:600">(' + formatScore(r.score) + ')</span>';
                    bestHtml += '</div>';
                    if (r.tournament) bestHtml += '<div style="font-size:.65rem;color:var(--muted);margin-top:.15rem">' + r.tournament + (r.round ? ' ‚Ä¢ ' + r.round : '') + '</div>';
                    bestHtml += '</div>';
                });
                bestHtml += '</div>';
            } else {
                bestHtml = '<div style="color:var(--muted)">-</div>';
            }
            safeHTML('simBestStreak', bestHtml);
            
            // Ann√©es (style Playground)
            var yearlyStats = {};
            bets.forEach(function(b) {
                var y = b.date.substring(0, 4);
                if (!yearlyStats[y]) yearlyStats[y] = { bets: 0, profit: 0 };
                yearlyStats[y].bets++;
                yearlyStats[y].profit += b.won ? (b.odds - 1) * flatStake : -flatStake;
            });
            var yearsHtml = '';
            Object.keys(yearlyStats).sort().forEach(function(y) {
                var s = yearlyStats[y];
                yearsHtml += '<div class="year ' + (s.profit >= 0 ? 'pos' : 'neg') + '"><b>' + y + '</b><span>' + s.bets + 'p ‚Ä¢ ' + (s.profit >= 0 ? '+' : '') + s.profit.toFixed(0) + '‚Ç¨</span></div>';
            });
            safeHTML('simYears', yearsHtml);
            
            // Historique des paris
            safeText('simHistoryCount', '(' + bets.length + ' paris)');
            window.simBetsCache = { bets: bets, flatStake: flatStake, bankroll: bankroll, years: Object.keys(yearlyStats).sort() };
            window.simHistoryPage = 1;
            try {
                renderSimHistory();
            } catch(e) { console.error('renderSimHistory error:', e); }
            
            // D√©tail mensuel
            try {
                renderMonthlyDetail();
            } catch(e) { console.error('renderMonthlyDetail error:', e); }
            
            // Ajouter un r√©sum√© des donn√©es en haut
            var summaryHtml = '<div style="display:grid;grid-template-columns:repeat(5,1fr);gap:.5rem;margin-bottom:1rem;text-align:center">' +
                '<div style="background:var(--bg);padding:.75rem;border-radius:6px"><div style="font-size:1.2rem;font-weight:700">' + bets.length + '</div><div style="font-size:.7rem;color:var(--muted)">Paris simul√©s</div></div>' +
                '<div style="background:var(--bg);padding:.75rem;border-radius:6px"><div style="font-size:1.2rem;font-weight:700">' + winrate + '%</div><div style="font-size:.7rem;color:var(--muted)">Win Rate</div></div>' +
                '<div style="background:var(--bg);padding:.75rem;border-radius:6px"><div style="font-size:1.2rem;font-weight:700">' + avgOdds + '</div><div style="font-size:.7rem;color:var(--muted)">Cote moyenne</div></div>' +
                '<div style="background:var(--bg);padding:.75rem;border-radius:6px"><div style="font-size:1.2rem;font-weight:700">' + numYears + '</div><div style="font-size:.7rem;color:var(--muted)">Ann√©es</div></div>' +
                '<div style="background:var(--bg);padding:.75rem;border-radius:6px"><div style="font-size:1.2rem;font-weight:700">' + Math.round(bets.length / numYears) + '</div><div style="font-size:.7rem;color:var(--muted)">Paris/an</div></div>' +
                '</div>';
            
            // Tableau comparatif avec headers
            var tableHtml = summaryHtml;
            var strategies = [
                { name: 'üíµ Flat', param: flatStake + '‚Ç¨', data: flatSim, color: 'var(--blue)', 
                  desc: 'Mise fixe identique sur chaque pari', 
                  pros: ['Simple √† suivre', 'Risque contr√¥l√©', 'Id√©al pour d√©buter'],
                  cons: ['Ne profite pas des bonnes s√©ries', 'Pas d\'optimisation'] },
                { name: 'üìä % Bankroll', param: pctStake + '%', data: pctSim, color: 'var(--green)',
                  desc: 'Mise proportionnelle √† la bankroll actuelle',
                  pros: ['Croissance exponentielle possible', 'R√©duit les mises en drawdown', 'Prot√®ge le capital'],
                  cons: ['Mises variables', 'Croissance lente au d√©but'] },
                { name: 'üßÆ Kelly √∑' + kellyDiv, param: 'Fractionnel', data: kellySim, color: 'var(--purple)',
                  desc: 'Mise optimale bas√©e sur l\'edge statistique',
                  pros: ['Math√©matiquement optimal', 'Maximise la croissance', 'Adapt√© √† l\'edge'],
                  cons: ['Volatilit√© √©lev√©e', 'Drawdowns importants', 'Requiert edge pr√©cis'] }
            ];
            
            // Trouver la meilleure strat√©gie selon diff√©rents crit√®res
            var bestProfit = strategies.reduce(function(a, b) { return a.data.profit > b.data.profit ? a : b; });
            var bestSharpe = strategies.reduce(function(a, b) { return a.data.sharpe > b.data.sharpe ? a : b; });
            var lowestDD = strategies.reduce(function(a, b) { return a.data.maxDrawdown < b.data.maxDrawdown ? a : b; });
            
            // Table header
            tableHtml += '<table style="width:100%;border-collapse:collapse;margin-bottom:1rem">';
            tableHtml += '<thead><tr style="background:var(--bg);border-bottom:2px solid var(--border)">';
            tableHtml += '<th style="padding:.75rem;text-align:left;font-size:.75rem">Strat√©gie</th>';
            tableHtml += '<th style="padding:.75rem;text-align:right;font-size:.75rem">Profit</th>';
            tableHtml += '<th style="padding:.75rem;text-align:right;font-size:.75rem">ROI</th>';
            tableHtml += '<th style="padding:.75rem;text-align:right;font-size:.75rem">Max DD</th>';
            tableHtml += '<th style="padding:.75rem;text-align:right;font-size:.75rem">Bankroll finale</th>';
            tableHtml += '<th style="padding:.75rem;text-align:right;font-size:.75rem">Survie</th>';
            tableHtml += '<th style="padding:.75rem;text-align:right;font-size:.75rem">Sharpe</th>';
            tableHtml += '</tr></thead><tbody>';
            
            for (var i = 0; i < strategies.length; i++) {
                var s = strategies[i];
                var profitColor = s.data.profit >= 0 ? 'var(--green)' : 'var(--red)';
                var survived = s.data.finalBankroll >= 1;
                var survivalPct = (s.data.totalBets / bets.length * 100);
                var survivalColor = survived ? 'var(--green)' : 'var(--red)';
                var survivalText = survived ? '‚úÖ 100%' : 'üíÄ ' + survivalPct.toFixed(0) + '%';
                
                // Badges pour la meilleure strat√©gie selon crit√®re
                var badges = '';
                if (s === bestProfit) badges += '<span style="background:var(--green);color:#fff;font-size:.55rem;padding:1px 4px;border-radius:3px;margin-left:4px">MAX PROFIT</span>';
                if (s === bestSharpe) badges += '<span style="background:var(--blue);color:#fff;font-size:.55rem;padding:1px 4px;border-radius:3px;margin-left:4px">BEST SHARPE</span>';
                if (s === lowestDD) badges += '<span style="background:var(--purple);color:#fff;font-size:.55rem;padding:1px 4px;border-radius:3px;margin-left:4px">MIN DD</span>';
                
                tableHtml += '<tr style="border-bottom:1px solid var(--border)' + (!survived ? ';opacity:.6' : '') + '">' +
                    '<td style="padding:.75rem"><span style="font-weight:600">' + s.name + '</span> <span style="color:var(--muted);font-size:.8rem">(' + s.param + ')</span>' + badges + '</td>' +
                    '<td style="padding:.75rem;text-align:right;color:' + profitColor + ';font-weight:600">' + (s.data.profit >= 0 ? '+' : '') + formatMoney(s.data.profit) + '</td>' +
                    '<td style="padding:.75rem;text-align:right;color:' + profitColor + '">' + (s.data.roi >= 0 ? '+' : '') + s.data.roi.toFixed(1) + '%</td>' +
                    '<td style="padding:.75rem;text-align:right;color:var(--red)">-' + s.data.maxDrawdown.toFixed(1) + '%</td>' +
                    '<td style="padding:.75rem;text-align:right;font-weight:600">' + formatMoney(s.data.finalBankroll) + '</td>' +
                    '<td style="padding:.75rem;text-align:right;color:' + survivalColor + '">' + survivalText + '</td>' +
                    '<td style="padding:.75rem;text-align:right">' + s.data.sharpe.toFixed(2) + '</td>' +
                    '</tr>';
            }
            tableHtml += '</tbody></table>';
            
            // D√©tails de chaque strat√©gie
            tableHtml += '<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:1rem;margin-top:1rem">';
            for (var i = 0; i < strategies.length; i++) {
                var s = strategies[i];
                var borderColor = s === bestSharpe ? s.color : 'var(--border)';
                var isRecommended = s === bestSharpe;
                
                tableHtml += '<div style="background:var(--bg);border-radius:8px;padding:1rem;border:2px solid ' + borderColor + '">';
                tableHtml += '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:.5rem">';
                tableHtml += '<div style="font-weight:700;color:' + s.color + '">' + s.name + '</div>';
                if (isRecommended) tableHtml += '<span style="background:var(--blue);color:#fff;font-size:.6rem;padding:2px 6px;border-radius:4px">RECOMMAND√â</span>';
                tableHtml += '</div>';
                tableHtml += '<div style="font-size:.75rem;color:var(--muted);margin-bottom:.75rem">' + s.desc + '</div>';
                
                // Stats cl√©s
                tableHtml += '<div style="display:grid;grid-template-columns:1fr 1fr;gap:.5rem;margin-bottom:.75rem">';
                tableHtml += '<div style="background:var(--card);padding:.5rem;border-radius:4px;text-align:center">';
                tableHtml += '<div style="font-size:1rem;font-weight:700;color:' + (s.data.profit >= 0 ? 'var(--green)' : 'var(--red)') + '">' + (s.data.profit >= 0 ? '+' : '') + formatMoney(s.data.profit) + '</div>';
                tableHtml += '<div style="font-size:.6rem;color:var(--muted)">Profit</div></div>';
                tableHtml += '<div style="background:var(--card);padding:.5rem;border-radius:4px;text-align:center">';
                tableHtml += '<div style="font-size:1rem;font-weight:700;color:var(--red)">-' + s.data.maxDrawdown.toFixed(0) + '%</div>';
                tableHtml += '<div style="font-size:.6rem;color:var(--muted)">Max DD</div></div>';
                tableHtml += '</div>';
                
                // Pros
                tableHtml += '<div style="font-size:.65rem;margin-bottom:.4rem"><span style="color:var(--green)">‚úÖ Avantages</span></div>';
                tableHtml += '<ul style="font-size:.7rem;margin:0 0 .5rem 1rem;padding:0;color:var(--muted)">';
                for (var p = 0; p < s.pros.length; p++) {
                    tableHtml += '<li>' + s.pros[p] + '</li>';
                }
                tableHtml += '</ul>';
                
                // Cons
                tableHtml += '<div style="font-size:.65rem;margin-bottom:.4rem"><span style="color:var(--red)">‚ö†Ô∏è Inconv√©nients</span></div>';
                tableHtml += '<ul style="font-size:.7rem;margin:0 0 0 1rem;padding:0;color:var(--muted)">';
                for (var c = 0; c < s.cons.length; c++) {
                    tableHtml += '<li>' + s.cons[c] + '</li>';
                }
                tableHtml += '</ul>';
                tableHtml += '</div>';
            }
            tableHtml += '</div>';
            
            // Recommandation globale
            var profitPerUnit = flatSim.profit / flatStake;
            var riskLevel = flatSim.maxDrawdown < 25 ? 'Faible' : flatSim.maxDrawdown < 40 ? 'Mod√©r√©' : '√âlev√©';
            var riskColor = flatSim.maxDrawdown < 25 ? 'var(--green)' : flatSim.maxDrawdown < 40 ? 'var(--yellow)' : 'var(--red)';
            
            tableHtml += '<div style="background:linear-gradient(135deg,rgba(77,159,255,.1),rgba(139,92,246,.1));border:1px solid var(--blue);border-radius:8px;padding:1rem;margin-top:1rem">';
            tableHtml += '<div style="font-weight:700;margin-bottom:.5rem">üí° Recommandation</div>';
            tableHtml += '<div style="font-size:.85rem">';
            
            if (bestSharpe.name.includes('Flat')) {
                tableHtml += 'La strat√©gie <b>Flat</b> offre le meilleur ratio rendement/risque (Sharpe: ' + bestSharpe.data.sharpe.toFixed(2) + '). ';
                tableHtml += 'Simple et efficace, c\'est le choix recommand√© pour une gestion saine.';
            } else if (bestSharpe.name.includes('%')) {
                tableHtml += 'La strat√©gie <b>% Bankroll</b> offre le meilleur ratio rendement/risque (Sharpe: ' + bestSharpe.data.sharpe.toFixed(2) + '). ';
                tableHtml += 'Elle prot√®ge le capital en r√©duisant les mises pendant les drawdowns.';
            } else {
                tableHtml += 'La strat√©gie <b>Kelly</b> offre le meilleur ratio rendement/risque mais avec une volatilit√© √©lev√©e. ';
                tableHtml += 'Recommand√©e uniquement pour les profils agressifs.';
            }
            
            tableHtml += '</div>';
            tableHtml += '<div style="display:flex;gap:1rem;margin-top:.75rem;font-size:.75rem">';
            tableHtml += '<div>üéØ Profit/unit√©: <b>' + profitPerUnit.toFixed(1) + '</b></div>';
            tableHtml += '<div>‚ö° Risque: <b style="color:' + riskColor + '">' + riskLevel + '</b></div>';
            tableHtml += '<div>üìä Sharpe optimal: <b>' + bestSharpe.data.sharpe.toFixed(2) + '</b></div>';
            tableHtml += '</div>';
            tableHtml += '</div>';
            
            safeHTML('simCompareTable', tableHtml);
            
            // Afficher le r√©cap des coefficients si mode non-uniforme
            if (currentStakeMode !== 'uniform') {
                var coefHtml = '<div style="margin-top:1rem;padding:1rem;background:var(--bg);border-radius:8px;border:1px solid var(--border)">';
                coefHtml += '<div style="font-size:.85rem;font-weight:600;margin-bottom:.75rem">üéöÔ∏è Coefficients de mise appliqu√©s</div>';
                coefHtml += '<div style="display:flex;flex-wrap:wrap;gap:.5rem">';
                
                // Grouper les bets par niche pour afficher les coefs
                var nicheStats = {};
                for (var b = 0; b < bets.length; b++) {
                    var bet = bets[b];
                    if (!nicheStats[bet.nicheId]) {
                        var coef = 1.0;
                        if (bet.nicheObj && bet.nicheObj.stakeCoef) {
                            coef = bet.nicheObj.stakeCoef;
                        }
                        nicheStats[bet.nicheId] = {
                            name: bet.niche,
                            circuit: bet.circuit,
                            coef: coef,
                            bets: 0
                        };
                    }
                    nicheStats[bet.nicheId].bets++;
                }
                
                for (var nid in nicheStats) {
                    var ns = nicheStats[nid];
                    var coefColor = ns.coef > 1 ? 'var(--green)' : ns.coef < 1 ? 'var(--yellow)' : 'var(--text)';
                    var circuitIcon = ns.circuit === 'ATP' ? 'üü¢' : 'ü©∑';
                    var miseExemple = Math.round(flatStake * ns.coef);
                    coefHtml += '<div style="background:var(--card);border:1px solid var(--border);border-radius:6px;padding:.5rem .75rem;font-size:.75rem">';
                    coefHtml += '<div style="font-weight:600">' + circuitIcon + ' ' + ns.name + '</div>';
                    coefHtml += '<div style="color:' + coefColor + ';font-weight:700">√ó' + ns.coef.toFixed(2) + ' ‚Üí ' + miseExemple + '‚Ç¨</div>';
                    coefHtml += '<div style="color:var(--muted);font-size:.65rem">' + ns.bets + ' paris</div>';
                    coefHtml += '</div>';
                }
                
                coefHtml += '</div>';
                coefHtml += '<div style="font-size:.7rem;color:var(--muted);margin-top:.5rem">Mode: ‚úèÔ∏è Mise personnalis√©e</div>';
                coefHtml += '</div>';
                
                document.getElementById('simCompareTable').innerHTML += coefHtml;
            }
            
            // Fonction pour √©chantillonner les donn√©es (max 100 points)
            function sampleData(results, maxPoints) {
                if (results.length <= maxPoints) return results;
                var step = Math.ceil(results.length / maxPoints);
                var sampled = [];
                for (var i = 0; i < results.length; i += step) {
                    sampled.push(results[i]);
                }
                // Toujours inclure le dernier point
                if (sampled[sampled.length - 1] !== results[results.length - 1]) {
                    sampled.push(results[results.length - 1]);
                }
                return sampled;
            }
            
            // √âchantillonner les donn√©es pour le graphique
            var maxPoints = 150;
            var flatSampled = sampleData(flatSim.results, maxPoints);
            var pctSampled = sampleData(pctSim.results, maxPoints);
            var kellySampled = sampleData(kellySim.results, maxPoints);
            
            // Cr√©er le graphique d'√©volution du profit
            renderSimProfitChart(bets, flatStake, bankroll);
            
            // Trouver la meilleure strat√©gie
            var allStrats = [
                { name: 'Flat', data: flatSim, emoji: 'üíµ', color: 'var(--blue)' },
                { name: '% Bankroll', data: pctSim, emoji: 'üìä', color: 'var(--green)' },
                { name: 'Kelly', data: kellySim, emoji: 'üßÆ', color: 'var(--purple)' }
            ].filter(function(s) { return s.data.finalBankroll > 0; });
            
            allStrats.sort(function(a, b) { return b.data.profit - a.data.profit; });
            
            // R√©sum√© visuel
            var bestStrat = allStrats[0];
            var summaryHtml2 = '<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:1rem">';
            
            if (bestStrat) {
                summaryHtml2 += '<div style="background:linear-gradient(135deg,' + bestStrat.color + '22, transparent);border:2px solid ' + bestStrat.color + ';border-radius:12px;padding:1.25rem;text-align:center">' +
                    '<div style="font-size:.8rem;color:var(--muted);margin-bottom:.5rem">üèÜ Meilleure strat√©gie</div>' +
                    '<div style="font-size:1.5rem;font-weight:700;color:' + bestStrat.color + '">' + bestStrat.emoji + ' ' + bestStrat.name + '</div>' +
                    '<div style="font-size:1.1rem;color:var(--green);margin-top:.5rem">+' + formatMoney(bestStrat.data.profit) + '</div>' +
                    '</div>';
            }
            
            summaryHtml2 += '<div style="background:var(--bg);border-radius:12px;padding:1.25rem;text-align:center">' +
                '<div style="font-size:.8rem;color:var(--muted);margin-bottom:.5rem">üìä ROI moyen</div>' +
                '<div style="font-size:1.5rem;font-weight:700;color:var(--green)">+' + ((flatSim.roi + pctSim.roi + kellySim.roi) / 3).toFixed(1) + '%</div>' +
                '<div style="font-size:.8rem;color:var(--muted);margin-top:.5rem">' + bets.length + ' paris sur ' + numYears + ' ans</div>' +
                '</div>';
            
            // Analyse du risque
            var safestStrat = allStrats.slice().sort(function(a, b) { return a.data.maxDrawdown - b.data.maxDrawdown; })[0];
            summaryHtml2 += '<div style="background:var(--bg);border-radius:12px;padding:1.25rem;text-align:center">' +
                '<div style="font-size:.8rem;color:var(--muted);margin-bottom:.5rem">üõ°Ô∏è Plus s√ªre (DD min)</div>' +
                '<div style="font-size:1.5rem;font-weight:700;color:' + (safestStrat ? safestStrat.color : 'var(--muted)') + '">' + (safestStrat ? safestStrat.emoji + ' ' + safestStrat.name : '-') + '</div>' +
                '<div style="font-size:.8rem;color:var(--yellow);margin-top:.5rem">DD max: -' + (safestStrat ? safestStrat.data.maxDrawdown.toFixed(1) : '?') + '%</div>' +
                '</div>';
            
            summaryHtml2 += '</div>';
            safeHTML('simSummary', summaryHtml2);
            
            // Analyse du drawdown - VERSION AM√âLIOR√âE
            var ddHtml = '';
            
            // D'abord expliquer ce qu'est le drawdown
            ddHtml += '<div style="background:var(--bg);border-radius:8px;padding:1rem;margin-bottom:1rem;border-left:4px solid var(--blue)">';
            ddHtml += '<div style="font-weight:600;margin-bottom:.5rem">üí° Qu\'est-ce que le drawdown ?</div>';
            ddHtml += '<div style="font-size:.85rem;color:var(--muted)">';
            ddHtml += 'Le drawdown est la <b>perte temporaire maximale</b> entre un pic de ta bankroll et son point le plus bas. ';
            ddHtml += 'C\'est le <b>pire moment</b> que tu vas traverser avant que √ßa remonte. ';
            ddHtml += 'M√™me si la strat√©gie est rentable, tu dois pouvoir supporter cette chute sans paniquer.';
            ddHtml += '</div></div>';
            
            var stratList = [
                { name: 'Flat', data: flatSim, color: 'var(--blue)', stake: flatStake + '‚Ç¨ fixe' },
                { name: '% Bankroll', data: pctSim, color: 'var(--green)', stake: pctStake + '% variable' },
                { name: 'Kelly', data: kellySim, color: 'var(--purple)', stake: 'Kelly √∑' + kellyDiv }
            ];
            
            ddHtml += '<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:1rem">';
            
            for (var i = 0; i < stratList.length; i++) {
                var strat = stratList[i];
                var ddPct = strat.data.maxDrawdown;
                var ddLevel = ddPct < 25 ? 'safe' : ddPct < 40 ? 'warning' : 'danger';
                var ddColor = ddLevel === 'safe' ? 'var(--green)' : ddLevel === 'warning' ? 'var(--yellow)' : 'var(--red)';
                var ddIcon = ddLevel === 'safe' ? '‚úÖ' : ddLevel === 'warning' ? '‚ö†Ô∏è' : 'üö®';
                
                // Ce que √ßa veut dire pour toi
                var explicationPerte;
                var peakBR = strat.data.peakBankroll || bankroll;
                var ddAbsolute = strat.data.maxDrawdownAbs || (peakBR * ddPct / 100);
                var troughBR = peakBR - ddAbsolute;
                
                if (strat.name === 'Flat') {
                    // Pour Flat : montrer la perte absolue depuis le peak
                    explicationPerte = 'Peak atteint: <b>' + formatMoney(peakBR) + '</b>, puis chute √† <b>' + formatMoney(troughBR) + '</b>';
                    explicationPerte += '<br>Perte temporaire: <b style="color:var(--red)">' + formatMoney(ddAbsolute) + '</b>';
                } else {
                    // Pour % et Kelly : la BR a grandi avant le drawdown
                    var profitAtTrough = troughBR - bankroll;
                    
                    if (profitAtTrough > 0) {
                        explicationPerte = 'Peak √† <b>' + formatMoney(peakBR) + '</b>, chute √† <b>' + formatMoney(troughBR) + '</b>';
                        explicationPerte += '<br>‚Üí Toujours en <b style="color:var(--green)">profit de +' + formatMoney(profitAtTrough) + '</b>';
                    } else {
                        explicationPerte = 'Peak √† <b>' + formatMoney(peakBR) + '</b>, chute √† <b style="color:var(--red)">' + formatMoney(troughBR) + '</b>';
                        explicationPerte += '<br>‚Üí <b style="color:var(--red)">Perte de ' + formatMoney(Math.abs(profitAtTrough)) + '</b> sur ton capital initial';
                    }
                }
                
                // Combien de mises perdantes d'affil√©e √ßa repr√©sente (approximatif)
                var misesEquivalent = Math.round(ddAbsolute / flatStake);
                
                // Conseil selon le niveau
                var conseil;
                if (ddLevel === 'safe') {
                    conseil = 'üëç Confortable - Facile √† supporter psychologiquement';
                } else if (ddLevel === 'warning') {
                    conseil = 'üò∞ Stressant - Tu vas douter de ta strat√©gie';
                } else {
                    conseil = 'üÜò Tr√®s difficile - Risque d\'abandonner au pire moment';
                }
                
                ddHtml += '<div style="background:var(--bg);border-radius:8px;padding:1rem;border:2px solid ' + (ddLevel === 'safe' ? ddColor : 'var(--border)') + '">';
                ddHtml += '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:.75rem">';
                ddHtml += '<div style="font-weight:700;color:' + strat.color + '">' + strat.name + '</div>';
                ddHtml += '<div style="font-size:.7rem;color:var(--muted)">' + strat.stake + '</div>';
                ddHtml += '</div>';
                
                // Le chiffre principal
                ddHtml += '<div style="text-align:center;margin-bottom:.75rem">';
                ddHtml += '<div style="font-size:2rem;font-weight:700;color:' + ddColor + '">' + ddIcon + ' -' + ddPct.toFixed(0) + '%</div>';
                ddHtml += '<div style="font-size:.75rem;color:var(--muted)">Drawdown maximum</div>';
                ddHtml += '</div>';
                
                // Barre visuelle
                ddHtml += '<div style="height:8px;background:var(--card);border-radius:4px;overflow:hidden;margin-bottom:.75rem">';
                ddHtml += '<div style="height:100%;width:' + Math.min(ddPct, 100) + '%;background:linear-gradient(90deg,' + ddColor + ',' + (ddLevel === 'danger' ? 'var(--red)' : ddColor) + ')"></div>';
                ddHtml += '</div>';
                
                // Ce que √ßa veut dire pour toi
                ddHtml += '<div style="background:var(--card);border-radius:6px;padding:.75rem;margin-bottom:.5rem">';
                ddHtml += '<div style="font-size:.7rem;color:var(--muted);margin-bottom:.25rem">üí∞ CE QUE √áA VEUT DIRE</div>';
                ddHtml += '<div style="font-size:.85rem">' + explicationPerte + '</div>';
                ddHtml += '<div style="font-size:.75rem;color:var(--muted);margin-top:.25rem">‚âà ' + misesEquivalent + ' mises flat perdues d\'affil√©e</div>';
                ddHtml += '</div>';
                
                // Conseil
                ddHtml += '<div style="font-size:.75rem;color:' + ddColor + '">' + conseil + '</div>';
                
                ddHtml += '</div>';
            }
            
            ddHtml += '</div>';
            
            // Plus longue s√©rie perdante
            var maxLosing = 0, curLosing = 0;
            for (var i = 0; i < bets.length; i++) {
                if (!bets[i].won) {
                    curLosing++;
                    if (curLosing > maxLosing) maxLosing = curLosing;
                } else {
                    curLosing = 0;
                }
            }
            
            var seriePerteFlat = maxLosing * flatStake;
            var seriePertePct = (1 - Math.pow(1 - pctStake/100, maxLosing)) * 100;
            
            ddHtml += '<div style="margin-top:1rem;background:var(--bg);border-radius:8px;padding:1rem">';
            ddHtml += '<div style="font-weight:600;margin-bottom:.75rem">üî• Pire s√©rie perdante historique : ' + maxLosing + ' paris d\'affil√©e</div>';
            ddHtml += '<div style="display:grid;grid-template-columns:repeat(2,1fr);gap:1rem">';
            ddHtml += '<div style="background:var(--card);padding:.75rem;border-radius:6px">';
            ddHtml += '<div style="font-size:.75rem;color:var(--muted)">Impact en Flat (' + flatStake + '‚Ç¨)</div>';
            ddHtml += '<div style="font-size:1.2rem;font-weight:700;color:var(--red)">-' + formatMoney(seriePerteFlat) + '</div>';
            ddHtml += '<div style="font-size:.7rem;color:var(--muted)">' + maxLosing + ' √ó ' + flatStake + '‚Ç¨</div>';
            ddHtml += '</div>';
            ddHtml += '<div style="background:var(--card);padding:.75rem;border-radius:6px">';
            ddHtml += '<div style="font-size:.75rem;color:var(--muted)">Impact en % BR (' + pctStake + '%)</div>';
            ddHtml += '<div style="font-size:1.2rem;font-weight:700;color:var(--red)">-' + seriePertePct.toFixed(1) + '%</div>';
            ddHtml += '<div style="font-size:.7rem;color:var(--muted)">de ta bankroll √† ce moment</div>';
            ddHtml += '</div>';
            ddHtml += '</div>';
            ddHtml += '</div>';
            
            // Recommandation finale
            var bestDD = stratList.reduce(function(a, b) { return a.data.maxDrawdown < b.data.maxDrawdown ? a : b; });
            ddHtml += '<div style="margin-top:1rem;padding:1rem;background:linear-gradient(135deg,rgba(34,197,94,.1),rgba(34,197,94,.05));border:1px solid var(--green);border-radius:8px">';
            ddHtml += '<div style="font-weight:600;color:var(--green);margin-bottom:.5rem">üí° Recommandation</div>';
            ddHtml += '<div style="font-size:.85rem">';
            if (bestDD.data.maxDrawdown < 25) {
                ddHtml += 'La strat√©gie <b>' + bestDD.name + '</b> a le drawdown le plus faible (-' + bestDD.data.maxDrawdown.toFixed(0) + '%). ';
                ddHtml += 'C\'est un niveau <b>confortable</b> pour la plupart des parieurs.';
            } else if (bestDD.data.maxDrawdown < 40) {
                ddHtml += 'M√™me la meilleure strat√©gie (<b>' + bestDD.name + '</b>) a un drawdown de -' + bestDD.data.maxDrawdown.toFixed(0) + '%. ';
                ddHtml += 'C\'est <b>g√©rable</b> mais il faut s\'y pr√©parer mentalement.';
            } else {
                ddHtml += '‚ö†Ô∏è Toutes les strat√©gies ont un drawdown √©lev√©. ';
                ddHtml += 'Consid√®re <b>r√©duire ta mise</b> ou augmenter ta bankroll pour mieux absorber les pertes.';
            }
            ddHtml += '</div></div>';
            
            safeHTML('drawdownAnalysis', ddHtml);
            
            // Graphique de drawdown am√©lior√©
            try {
                renderDrawdownChart(flatSim, pctSim, kellySim, bankroll);
            } catch(e) { console.error('renderDrawdownChart error:', e); }
            
            try {
                renderDrawdownZones(flatSim, bankroll);
            } catch(e) { console.error('renderDrawdownZones error:', e); }
            
            // Moments difficiles (analyse psychologique)
            try {
                analyzeRoughPeriods(flatSim.results, bankroll, flatStake);
            } catch(e) { console.error('analyzeRoughPeriods error:', e); }
            
            // S√©ries remarquables
            try {
                renderStreaksAnalysis(bets, flatStake, bankroll);
            } catch(e) { console.error('renderStreaksAnalysis error:', e); }
            
            // Performance ann√©e par ann√©e
            try {
                renderYearlyBreakdown(bets, flatStake, pctStake);
            } catch(e) { console.error('renderYearlyBreakdown error:', e); }
            
            console.log('Simulation complete');
        }
        
        function renderDrawdownChart(flatSim, pctSim, kellySim, initialBankroll) {
            if (drawdownChart) drawdownChart.destroy();
            
            // Calculer le drawdown pour la strat√©gie Flat
            var ddSeries = [];
            var peak = initialBankroll;
            var results = flatSim.results;
            var maxDD = 0;
            var maxDDIdx = 0;
            
            for (var i = 0; i < results.length; i++) {
                var r = results[i];
                if (r.bankroll > peak) peak = r.bankroll;
                var dd = peak > 0 ? ((peak - r.bankroll) / peak * 100) : 0;
                if (dd > maxDD) { maxDD = dd; maxDDIdx = i; }
                ddSeries.push({
                    betNum: i + 1,
                    dd: dd,
                    date: r.date || '',
                    bankroll: r.bankroll
                });
            }
            
            // √âchantillonner √† 50 points max pour un graphique compact
            var maxPoints = 50;
            var sampled = ddSeries;
            if (ddSeries.length > maxPoints) {
                var step = Math.ceil(ddSeries.length / maxPoints);
                sampled = [];
                for (var i = 0; i < ddSeries.length; i += step) {
                    sampled.push(ddSeries[i]);
                }
                // Toujours inclure le dernier point
                if (sampled[sampled.length - 1] !== ddSeries[ddSeries.length - 1]) {
                    sampled.push(ddSeries[ddSeries.length - 1]);
                }
            }
            
            var ctx = document.getElementById('drawdownChart').getContext('2d');
            
            // Cr√©er un gradient rouge
            var gradient = ctx.createLinearGradient(0, 0, 0, 150);
            gradient.addColorStop(0, 'rgba(239, 68, 68, 0.8)');
            gradient.addColorStop(1, 'rgba(239, 68, 68, 0.1)');
            
            drawdownChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: sampled.map(function(d, i) { return i; }),
                    datasets: [{
                        label: 'Drawdown',
                        data: sampled.map(function(d) { return -d.dd; }),
                        borderColor: 'rgba(239, 68, 68, 1)',
                        backgroundColor: gradient,
                        fill: true,
                        tension: 0.3,
                        pointRadius: 0,
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                title: function(items) {
                                    var idx = items[0].dataIndex;
                                    var d = sampled[idx];
                                    return d.date ? d.date.substring(0, 10) : 'Pari #' + d.betNum;
                                },
                                label: function(context) {
                                    var d = sampled[context.dataIndex];
                                    return 'Drawdown: -' + d.dd.toFixed(1) + '% | BR: ' + d.bankroll.toFixed(0) + '‚Ç¨';
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            max: 0,
                            min: Math.min(-40, -maxDD * 1.2),
                            grid: { color: 'rgba(255,255,255,0.05)' },
                            ticks: {
                                color: 'rgba(255,255,255,0.5)',
                                callback: function(v) { return Math.abs(v).toFixed(0) + '%'; },
                                stepSize: 10
                            }
                        },
                        x: {
                            display: false
                        }
                    }
                }
            });
            
            // Afficher le r√©sum√© du drawdown max
            var ddInfo = document.getElementById('drawdownInfo');
            if (ddInfo) {
                var maxDDDate = ddSeries[maxDDIdx] ? ddSeries[maxDDIdx].date : '';
                ddInfo.innerHTML = '<div style="display:flex;gap:1.5rem;justify-content:center;padding:.5rem;font-size:.85rem">' +
                    '<span>üìâ Max DD: <b style="color:var(--red)">-' + maxDD.toFixed(1) + '%</b></span>' +
                    '<span>üìÖ ' + (maxDDDate ? maxDDDate.substring(0, 10) : 'Pari #' + (maxDDIdx + 1)) + '</span>' +
                    '<span>üí∞ ' + (ddSeries[maxDDIdx] ? ddSeries[maxDDIdx].bankroll.toFixed(0) : '?') + '‚Ç¨</span>' +
                    '</div>';
            }
        }
        
        // NOUVEAU: Zones de drawdown simplifi√©es
        function renderDrawdownZones(flatSim, initialBankroll) {
            var results = flatSim.results;
            if (!results || results.length === 0) return;
            
            // Trouver les p√©riodes de drawdown > 10%
            var zones = [];
            var peak = initialBankroll;
            var inDrawdown = false;
            var zoneStart = null;
            var zoneMaxDD = 0;
            
            for (var i = 0; i < results.length; i++) {
                var r = results[i];
                if (r.bankroll > peak) peak = r.bankroll;
                var dd = peak > 0 ? ((peak - r.bankroll) / peak * 100) : 0;
                
                if (dd >= 10 && !inDrawdown) {
                    inDrawdown = true;
                    zoneStart = { idx: i, date: r.date };
                    zoneMaxDD = dd;
                } else if (dd >= 10 && inDrawdown) {
                    if (dd > zoneMaxDD) zoneMaxDD = dd;
                } else if (dd < 5 && inDrawdown) {
                    inDrawdown = false;
                    zones.push({
                        start: zoneStart.date,
                        end: r.date,
                        startIdx: zoneStart.idx,
                        endIdx: i,
                        maxDD: zoneMaxDD,
                        duration: i - zoneStart.idx
                    });
                }
            }
            
            // Fermer zone ouverte
            if (inDrawdown && zoneStart) {
                var lastR = results[results.length - 1];
                zones.push({
                    start: zoneStart.date,
                    end: lastR.date,
                    startIdx: zoneStart.idx,
                    endIdx: results.length - 1,
                    maxDD: zoneMaxDD,
                    duration: results.length - 1 - zoneStart.idx
                });
            }
            
            if (zones.length === 0) {
                safeHTML('drawdownZones', '<div style="color:var(--green);font-size:.85rem">‚úÖ Aucune p√©riode de drawdown > 10% d√©tect√©e</div>');
                return;
            }
            
            // Trier par s√©v√©rit√©
            zones.sort(function(a, b) { return b.maxDD - a.maxDD; });
            
            var html = '<div style="display:flex;flex-wrap:wrap;gap:.5rem">';
            for (var i = 0; i < Math.min(zones.length, 5); i++) {
                var z = zones[i];
                var severity = z.maxDD >= 40 ? 'var(--red)' : z.maxDD >= 25 ? 'var(--orange)' : 'var(--yellow)';
                html += '<div style="background:' + severity + '22;border:1px solid ' + severity + ';border-radius:6px;padding:.5rem .75rem;font-size:.75rem">' +
                    '<div style="font-weight:600;color:' + severity + '">-' + z.maxDD.toFixed(1) + '%</div>' +
                    '<div style="color:var(--muted)">' + z.start.substring(0,7) + ' ‚Üí ' + z.end.substring(0,7) + '</div>' +
                    '<div style="font-size:.65rem;color:var(--muted)">' + z.duration + ' paris</div>' +
                    '</div>';
            }
            html += '</div>';
            
            safeHTML('drawdownZones', html);
        }
        
        // NOUVEAU: Analyse des s√©ries win/loss
        function renderStreaksAnalysis(bets, flatStake, bankroll) {
            // Trouver toutes les s√©ries (seuil abaiss√© √† 2+)
            var winStreaks = [];
            var lossStreaks = [];
            var currentStreak = { type: null, count: 0, startIdx: 0, profit: 0 };
            
            for (var i = 0; i < bets.length; i++) {
                var bet = bets[i];
                // Calculer la mise r√©elle avec coefficient
                var stakeCoef = 1.0;
                if (currentStakeMode === 'custom' && bet.nicheObj && bet.nicheObj.stakeCoef) {
                    stakeCoef = bet.nicheObj.stakeCoef;
                }
                var actualStake = flatStake * stakeCoef;
                var pnl = bet.won ? actualStake * (bet.odds - 1) : -actualStake;
                
                if ((bet.won && currentStreak.type === 'win') || (!bet.won && currentStreak.type === 'loss')) {
                    currentStreak.count++;
                    currentStreak.profit += pnl;
                } else {
                    // Sauvegarder la s√©rie pr√©c√©dente (seuil: 2+ pour les gains, 2+ pour les pertes)
                    if (currentStreak.count >= 2) {
                        if (currentStreak.type === 'win') {
                            winStreaks.push({...currentStreak, endIdx: i - 1});
                        } else if (currentStreak.type === 'loss') {
                            lossStreaks.push({...currentStreak, endIdx: i - 1});
                        }
                    }
                    // Nouvelle s√©rie
                    currentStreak = {
                        type: bet.won ? 'win' : 'loss',
                        count: 1,
                        startIdx: i,
                        profit: pnl
                    };
                }
            }
            // Derni√®re s√©rie
            if (currentStreak.count >= 2) {
                if (currentStreak.type === 'win') {
                    winStreaks.push({...currentStreak, endIdx: bets.length - 1});
                } else {
                    lossStreaks.push({...currentStreak, endIdx: bets.length - 1});
                }
            }
            
            // Trier par longueur
            winStreaks.sort(function(a, b) { return b.count - a.count; });
            lossStreaks.sort(function(a, b) { return b.count - a.count; });
            
            var html = '<div style="display:grid;grid-template-columns:1fr 1fr;gap:1rem">';
            
            // S√©ries gagnantes
            html += '<div style="background:rgba(34,197,94,.1);border:1px solid var(--green);border-radius:8px;padding:1rem">' +
                '<div style="font-weight:600;color:var(--green);margin-bottom:.75rem">üî• Top S√©ries Gagnantes</div>';
            
            if (winStreaks.length === 0) {
                html += '<div style="color:var(--muted);font-size:.85rem">Aucune s√©rie de 2+ wins</div>';
            } else {
                for (var i = 0; i < Math.min(winStreaks.length, 5); i++) {
                    var s = winStreaks[i];
                    var startBet = bets[s.startIdx];
                    var endBet = bets[s.endIdx];
                    html += '<div style="display:flex;justify-content:space-between;align-items:center;padding:.5rem;background:var(--card);border-radius:6px;margin-bottom:.5rem">' +
                        '<div><div style="font-weight:600;color:var(--green)">' + s.count + ' wins üéØ</div>' +
                        '<div style="font-size:.7rem;color:var(--muted)">' + (startBet.date || '').substring(5) + ' ‚Üí ' + (endBet.date || '').substring(5) + '</div></div>' +
                        '<div style="font-weight:700;color:var(--green);font-size:1.1rem">+' + s.profit.toFixed(0) + '‚Ç¨</div>' +
                        '</div>';
                }
            }
            html += '</div>';
            
            // S√©ries perdantes
            html += '<div style="background:rgba(239,68,68,.1);border:1px solid var(--red);border-radius:8px;padding:1rem">' +
                '<div style="font-weight:600;color:var(--red);margin-bottom:.75rem">üíÄ Top S√©ries Perdantes</div>';
            
            if (lossStreaks.length === 0) {
                html += '<div style="color:var(--muted);font-size:.85rem">Aucune s√©rie de 2+ losses</div>';
            } else {
                for (var i = 0; i < Math.min(lossStreaks.length, 5); i++) {
                    var s = lossStreaks[i];
                    var startBet = bets[s.startIdx];
                    var endBet = bets[s.endIdx];
                    var impactPct = (Math.abs(s.profit) / bankroll * 100).toFixed(1);
                    html += '<div style="display:flex;justify-content:space-between;align-items:center;padding:.5rem;background:var(--card);border-radius:6px;margin-bottom:.5rem">' +
                        '<div><div style="font-weight:600;color:var(--red)">' + s.count + ' losses üò∞</div>' +
                        '<div style="font-size:.7rem;color:var(--muted)">' + (startBet.date || '').substring(5) + ' ‚Üí ' + (endBet.date || '').substring(5) + '</div></div>' +
                        '<div style="text-align:right"><div style="font-weight:700;color:var(--red);font-size:1.1rem">' + s.profit.toFixed(0) + '‚Ç¨</div>' +
                        '<div style="font-size:.65rem;color:var(--yellow)">-' + impactPct + '% BR</div></div>' +
                        '</div>';
                }
            }
            html += '</div>';
            
            html += '</div>';
            
            // Statistiques d√©taill√©es
            var maxWin = winStreaks.length > 0 ? winStreaks[0].count : 0;
            var maxLoss = lossStreaks.length > 0 ? lossStreaks[0].count : 0;
            var worstImpact = lossStreaks.length > 0 ? lossStreaks[0].profit : 0;
            var totalLossStreaks = lossStreaks.length;
            var avgLossStreak = totalLossStreaks > 0 ? (lossStreaks.reduce(function(a,b){ return a + b.count; }, 0) / totalLossStreaks).toFixed(1) : 0;
            
            html += '<div style="margin-top:1rem;padding:1rem;background:var(--bg);border-radius:8px">' +
                '<div style="display:flex;justify-content:space-around;text-align:center;flex-wrap:wrap;gap:.5rem">' +
                '<div><div style="font-size:1.5rem;font-weight:700;color:var(--green)">' + maxWin + '</div><div style="font-size:.7rem;color:var(--muted)">Max Win Streak</div></div>' +
                '<div><div style="font-size:1.5rem;font-weight:700;color:var(--red)">' + maxLoss + '</div><div style="font-size:.7rem;color:var(--muted)">Max Loss Streak</div></div>' +
                '<div><div style="font-size:1.5rem;font-weight:700;color:var(--red)">' + worstImpact.toFixed(0) + '‚Ç¨</div><div style="font-size:.7rem;color:var(--muted)">Pire impact</div></div>' +
                '<div><div style="font-size:1.5rem;font-weight:700;color:var(--yellow)">' + totalLossStreaks + '</div><div style="font-size:.7rem;color:var(--muted)">S√©ries n√©gatives</div></div>' +
                '<div><div style="font-size:1.5rem;font-weight:700;color:var(--blue)">' + avgLossStreak + '</div><div style="font-size:.7rem;color:var(--muted)">Moy. s√©rie neg.</div></div>' +
                '</div></div>';
            
            safeHTML('streaksAnalysis', html);
        }
        
        // NOUVEAU: Historique des paris
        function renderSimHistory() {
            if (!window.simBetsCache) return;
            
            var bets = window.simBetsCache.bets;
            var flatStake = window.simBetsCache.flatStake;
            var bankroll = window.simBetsCache.bankroll;
            var filterEl = document.getElementById('simHistoryFilter');
            var sortEl = document.getElementById('simHistorySort');
            var filter = (filterEl && filterEl.value) ? filterEl.value.toLowerCase() : '';
            var sort = (sortEl && sortEl.value) ? sortEl.value : 'date-desc';
            
            // Filtrer
            var filtered = bets;
            if (filter) {
                filtered = bets.filter(function(b) {
                    return (b.player && b.player.toLowerCase().indexOf(filter) >= 0) ||
                           (b.opponent && b.opponent.toLowerCase().indexOf(filter) >= 0) ||
                           (b.tournament && b.tournament.toLowerCase().indexOf(filter) >= 0) ||
                           (b.surface && b.surface.toLowerCase().indexOf(filter) >= 0) ||
                           (b.niche && b.niche.toLowerCase().indexOf(filter) >= 0);
                });
            }
            
            // Ajouter P/L √† chaque pari
            filtered = filtered.map(function(b, idx) {
                var pnl = b.won ? flatStake * (b.odds - 1) : -flatStake;
                return {...b, pnl: pnl, originalIdx: idx};
            });
            
            // Trier
            switch(sort) {
                case 'date-asc':
                    filtered.sort(function(a, b) { return a.date.localeCompare(b.date); });
                    break;
                case 'profit-desc':
                    filtered.sort(function(a, b) { return b.pnl - a.pnl; });
                    break;
                case 'profit-asc':
                    filtered.sort(function(a, b) { return a.pnl - b.pnl; });
                    break;
                case 'odds-desc':
                    filtered.sort(function(a, b) { return b.odds - a.odds; });
                    break;
                default: // date-desc
                    filtered.sort(function(a, b) { return b.date.localeCompare(a.date); });
            }
            
            // Pagination
            var page = window.simHistoryPage || 1;
            var perPage = 100;
            var totalPages = Math.ceil(filtered.length / perPage);
            var start = (page - 1) * perPage;
            var displayBets = filtered.slice(start, start + perPage);
            
            var html = '<div style="margin-bottom:.5rem;font-size:.75rem;color:var(--muted)">' + filtered.length + ' paris trouv√©s</div>';
            
            html += '<div style="max-height:500px;overflow-y:auto">';
            
            for (var i = 0; i < displayBets.length; i++) {
                var b = displayBets[i];
                var resultIcon = b.won ? '‚úÖ' : '‚ùå';
                var pnlColor = b.pnl >= 0 ? 'var(--green)' : 'var(--red)';
                var pnlText = (b.pnl >= 0 ? '+' : '') + b.pnl.toFixed(0) + '‚Ç¨';
                var circuitBadge = b.circuit === 'ATP' ? 'üü¢' : 'ü©∑';
                var bgColor = b.won ? 'rgba(34,197,94,.05)' : 'rgba(239,68,68,.05)';
                var highlightColor = b.won ? 'rgba(34,197,94,.2)' : 'rgba(239,68,68,.2)';
                
                html += '<div style="padding:.5rem;font-size:.75rem;border-bottom:1px solid var(--border);background:' + bgColor + '">';
                html += '<div style="display:flex;justify-content:space-between;align-items:center">';
                html += '<span style="color:var(--muted);font-size:.65rem">' + b.date + ' ' + circuitBadge + '</span>';
                html += '<span style="color:' + pnlColor + ';font-weight:600">' + pnlText + '</span>';
                html += '</div>';
                html += '<div style="margin-top:.25rem">';
                html += '<span>' + resultIcon + '</span> ';
                html += '<span style="background:' + highlightColor + ';padding:.1rem .3rem;border-radius:3px;font-weight:700">' + (b.player || '?') + '</span>';
                html += ' <span style="color:var(--blue);font-size:.7rem">@' + b.odds.toFixed(2) + '</span>';
                html += ' <span style="color:var(--muted)">vs</span> ';
                html += '<span>' + (b.opponent || '?') + '</span>';
                html += ' <span style="color:var(--muted);font-size:.7rem">@' + (b.opponentOdds ? b.opponentOdds.toFixed(2) : '-') + '</span>';
                if (b.score) html += ' <span style="color:var(--text);font-size:.7rem;font-weight:600">(' + formatScore(b.score) + ')</span>';
                html += '</div>';
                html += '<div style="font-size:.65rem;color:var(--muted);margin-top:.15rem">' + (b.tournament || '-') + (b.round ? ' ‚Ä¢ ' + b.round : '') + (b.surface ? ' ‚Ä¢ ' + b.surface : '') + '</div>';
                html += '</div>';
            }
            
            html += '</div>';
            
            // Pagination
            if (totalPages > 1) {
                html += '<div style="display:flex;justify-content:center;gap:.5rem;padding:.75rem;align-items:center">';
                html += '<button onclick="window.simHistoryPage=1;renderSimHistory()" style="padding:.3rem .5rem;background:var(--bg);border:1px solid var(--border);border-radius:4px;cursor:pointer;color:var(--text)" ' + (page === 1 ? 'disabled' : '') + '>‚èÆ</button>';
                html += '<button onclick="window.simHistoryPage=Math.max(1,window.simHistoryPage-1);renderSimHistory()" style="padding:.3rem .5rem;background:var(--bg);border:1px solid var(--border);border-radius:4px;cursor:pointer;color:var(--text)" ' + (page === 1 ? 'disabled' : '') + '>‚óÄ</button>';
                html += '<span style="font-size:.8rem;color:var(--muted)">Page ' + page + ' / ' + totalPages + '</span>';
                html += '<button onclick="window.simHistoryPage=Math.min(' + totalPages + ',window.simHistoryPage+1);renderSimHistory()" style="padding:.3rem .5rem;background:var(--bg);border:1px solid var(--border);border-radius:4px;cursor:pointer;color:var(--text)" ' + (page === totalPages ? 'disabled' : '') + '>‚ñ∂</button>';
                html += '<button onclick="window.simHistoryPage=' + totalPages + ';renderSimHistory()" style="padding:.3rem .5rem;background:var(--bg);border:1px solid var(--border);border-radius:4px;cursor:pointer;color:var(--text)" ' + (page === totalPages ? 'disabled' : '') + '>‚è≠</button>';
                html += '</div>';
            }
            
            if (filtered.length === 0) {
                html = '<div style="padding:2rem;text-align:center;color:var(--muted)">Aucun pari trouv√©</div>';
            }
            
            safeHTML('simHistoryList', html);
        }
        
        // D√©tail mensuel des gains
        var currentMonthlyYear = null;
        
        function renderMonthlyDetail(year) {
            if (!window.simBetsCache) return;
            
            var bets = window.simBetsCache.bets;
            var flatStake = window.simBetsCache.flatStake;
            var years = window.simBetsCache.years || [];
            
            if (years.length === 0) {
                var yearSet = {};
                bets.forEach(function(b) {
                    var y = b.date.substring(0, 4);
                    yearSet[y] = true;
                });
                years = Object.keys(yearSet).sort();
                window.simBetsCache.years = years;
            }
            
            // S√©lecteur d'ann√©es
            var selectorEl = document.getElementById('monthlyYearSelector');
            if (selectorEl) {
                var selectorHtml = '';
                years.forEach(function(y) {
                    var isActive = (year === y) || (!year && y === years[years.length - 1]);
                    selectorHtml += '<button onclick="renderMonthlyDetail(\'' + y + '\')" style="padding:.25rem .5rem;font-size:.7rem;border:1px solid ' + (isActive ? 'var(--blue)' : 'var(--border)') + ';background:' + (isActive ? 'var(--blue)' : 'transparent') + ';color:' + (isActive ? '#000' : 'var(--muted)') + ';border-radius:4px;cursor:pointer;white-space:nowrap">' + y + '</button>';
                });
                selectorEl.innerHTML = selectorHtml;
            }
            
            // Ann√©e √† afficher
            var selectedYear = year || years[years.length - 1];
            currentMonthlyYear = selectedYear;
            
            // Calculer les stats par mois
            var monthlyStats = {};
            var monthNames = ['Jan', 'F√©v', 'Mar', 'Avr', 'Mai', 'Jun', 'Jul', 'Ao√ª', 'Sep', 'Oct', 'Nov', 'D√©c'];
            
            // Initialiser tous les mois
            for (var m = 0; m < 12; m++) {
                monthlyStats[m] = { bets: 0, wins: 0, profit: 0, staked: 0 };
            }
            
            // Remplir avec les donn√©es - AVEC coefficients de mise si mode custom
            bets.forEach(function(b) {
                if (b.date.substring(0, 4) !== selectedYear) return;
                var month = parseInt(b.date.substring(5, 7), 10) - 1;
                if (month >= 0 && month < 12) {
                    // Calculer la mise r√©elle avec coefficient
                    var stakeCoef = 1.0;
                    if (currentStakeMode === 'custom' && b.nicheObj && b.nicheObj.stakeCoef) {
                        stakeCoef = b.nicheObj.stakeCoef;
                    }
                    var actualStake = flatStake * stakeCoef;
                    
                    monthlyStats[month].bets++;
                    monthlyStats[month].staked += actualStake;
                    if (b.won) {
                        monthlyStats[month].wins++;
                        monthlyStats[month].profit += actualStake * (b.odds - 1);
                    } else {
                        monthlyStats[month].profit -= actualStake;
                    }
                }
            });
            
            // Calculer les totaux
            var totalBets = 0, totalWins = 0, totalProfit = 0, totalStaked = 0;
            for (var m = 0; m < 12; m++) {
                totalBets += monthlyStats[m].bets;
                totalWins += monthlyStats[m].wins;
                totalProfit += monthlyStats[m].profit;
                totalStaked += monthlyStats[m].staked;
            }
            
            // G√©n√©rer le tableau
            var tableEl = document.getElementById('monthlyDetailTable');
            if (!tableEl) return;
            
            // D√©terminer le mode d'affichage (‚Ç¨ ou Unit√©s)
            var displayUnits = (monthlyDisplayMode === 'units');
            var profitLabel = displayUnits ? 'Profit (u)' : 'Profit';
            
            var html = '<table style="width:100%;font-size:.75rem;border-collapse:collapse">';
            html += '<thead><tr style="background:var(--bg)">';
            html += '<th style="padding:.4rem;text-align:left;border-bottom:1px solid var(--border);font-weight:600">Mois</th>';
            html += '<th style="padding:.4rem;text-align:center;border-bottom:1px solid var(--border)">Paris</th>';
            html += '<th style="padding:.4rem;text-align:center;border-bottom:1px solid var(--border)">W/L</th>';
            html += '<th style="padding:.4rem;text-align:center;border-bottom:1px solid var(--border)">WR</th>';
            html += '<th style="padding:.4rem;text-align:right;border-bottom:1px solid var(--border)">' + profitLabel + '</th>';
            html += '<th style="padding:.4rem;text-align:right;border-bottom:1px solid var(--border)">ROI</th>';
            html += '</tr></thead><tbody>';
            
            for (var m = 0; m < 12; m++) {
                var s = monthlyStats[m];
                var wr = s.bets > 0 ? (s.wins / s.bets * 100).toFixed(0) : '-';
                var roi = s.staked > 0 ? (s.profit / s.staked * 100).toFixed(1) : '-';
                var profitColor = s.profit >= 0 ? 'var(--green)' : 'var(--red)';
                var rowBg = s.bets === 0 ? 'rgba(128,128,128,.05)' : (s.profit >= 0 ? 'rgba(34,197,94,.05)' : 'rgba(239,68,68,.05)');
                
                // Profit en ‚Ç¨ ou en unit√©s
                var profitDisplay;
                if (s.bets === 0) {
                    profitDisplay = '-';
                } else if (displayUnits) {
                    var profitUnits = s.profit / flatStake;
                    profitDisplay = (profitUnits >= 0 ? '+' : '') + profitUnits.toFixed(2) + 'u';
                } else {
                    profitDisplay = (s.profit >= 0 ? '+' : '') + s.profit.toFixed(0) + '‚Ç¨';
                }
                
                html += '<tr style="background:' + rowBg + '">';
                html += '<td style="padding:.4rem;border-bottom:1px solid var(--border);font-weight:600">' + monthNames[m] + '</td>';
                html += '<td style="padding:.4rem;text-align:center;border-bottom:1px solid var(--border)">' + (s.bets || '-') + '</td>';
                html += '<td style="padding:.4rem;text-align:center;border-bottom:1px solid var(--border);font-size:.65rem">' + (s.bets > 0 ? s.wins + '/' + (s.bets - s.wins) : '-') + '</td>';
                html += '<td style="padding:.4rem;text-align:center;border-bottom:1px solid var(--border)">' + (wr !== '-' ? wr + '%' : '-') + '</td>';
                html += '<td style="padding:.4rem;text-align:right;border-bottom:1px solid var(--border);color:' + profitColor + ';font-weight:600">' + profitDisplay + '</td>';
                html += '<td style="padding:.4rem;text-align:right;border-bottom:1px solid var(--border);color:' + profitColor + '">' + (roi !== '-' ? (parseFloat(roi) >= 0 ? '+' : '') + roi + '%' : '-') + '</td>';
                html += '</tr>';
            }
            
            // Ligne total
            var totalWR = totalBets > 0 ? (totalWins / totalBets * 100).toFixed(0) : '-';
            var totalROI = totalStaked > 0 ? (totalProfit / totalStaked * 100).toFixed(1) : '-';
            var totalProfitColor = totalProfit >= 0 ? 'var(--green)' : 'var(--red)';
            
            // Total profit en ‚Ç¨ ou unit√©s
            var totalProfitDisplay;
            if (displayUnits) {
                var totalProfitUnits = totalProfit / flatStake;
                totalProfitDisplay = (totalProfitUnits >= 0 ? '+' : '') + totalProfitUnits.toFixed(2) + 'u';
            } else {
                totalProfitDisplay = (totalProfit >= 0 ? '+' : '') + totalProfit.toFixed(0) + '‚Ç¨';
            }
            
            html += '<tr style="background:var(--bg);font-weight:700">';
            html += '<td style="padding:.5rem;border-top:2px solid var(--border)">TOTAL ' + selectedYear + '</td>';
            html += '<td style="padding:.5rem;text-align:center;border-top:2px solid var(--border)">' + totalBets + '</td>';
            html += '<td style="padding:.5rem;text-align:center;border-top:2px solid var(--border);font-size:.65rem">' + totalWins + '/' + (totalBets - totalWins) + '</td>';
            html += '<td style="padding:.5rem;text-align:center;border-top:2px solid var(--border)">' + totalWR + '%</td>';
            html += '<td style="padding:.5rem;text-align:right;border-top:2px solid var(--border);color:' + totalProfitColor + '">' + totalProfitDisplay + '</td>';
            html += '<td style="padding:.5rem;text-align:right;border-top:2px solid var(--border);color:' + totalProfitColor + '">' + (parseFloat(totalROI) >= 0 ? '+' : '') + totalROI + '%</td>';
            html += '</tr>';
            
            html += '</tbody></table>';
            
            // Indicateur du mode d'affichage
            html += '<div style="font-size:.65rem;color:var(--muted);margin-top:.5rem;text-align:right">';
            if (displayUnits) {
                html += '1 unit√© = ' + flatStake + '‚Ç¨ (mise de base)';
            }
            html += '</div>';
            
            tableEl.innerHTML = html;
        }
        
        // Listener pour le filtre de l'historique
        document.addEventListener('DOMContentLoaded', function() {
            var filterInput = document.getElementById('simHistoryFilter');
            if (filterInput) {
                var debounceTimer;
                filterInput.addEventListener('input', function() {
                    clearTimeout(debounceTimer);
                    debounceTimer = setTimeout(renderSimHistory, 300);
                });
            }
        });
        
        function runOptimizer() {
            var bets = getSimulationBets();
            if (bets.length < 20) {
                alert('Pas assez de donn√©es pour l\'optimisation (minimum 20 paris). Charge les CSV d\'abord.');
                return;
            }
            
            var bankroll = parseFloat(document.getElementById('cfgBankroll').value) || 5000;
            
            // Cacher les autres r√©sultats et afficher l'optimiseur
            safeDisplay('simResults', false);
            safeDisplay('stressResults', false);
            safeDisplay('multiBankrollResults', false);
            safeDisplay('whatIfResults', false);
            safeDisplay('optimizerResults', true);
            
            // Tester diff√©rentes mises flat
            var flatTests = [];
            var flatStakes = [25, 50, 75, 100, 125, 150, 175, 200, 250, 300, 400, 500];
            
            for (var i = 0; i < flatStakes.length; i++) {
                var stake = flatStakes[i];
                var sim = simulateStrategy(bets, bankroll, 'flat', { flatStake: stake });
                flatTests.push({
                    stake: stake,
                    profit: sim.profit,
                    roi: sim.roi,
                    maxDD: sim.maxDrawdown,
                    survived: sim.finalBankroll >= 1,
                    finalBR: sim.finalBankroll,
                    sharpe: sim.sharpe
                });
            }
            
            // Tester diff√©rents % bankroll
            var pctTests = [];
            var pctStakes = [1, 1.5, 2, 2.5, 3, 3.5, 4, 5, 6, 7, 8, 10];
            
            for (var i = 0; i < pctStakes.length; i++) {
                var pct = pctStakes[i];
                var sim = simulateStrategy(bets, bankroll, 'percent', { pctStake: pct });
                pctTests.push({
                    pct: pct,
                    profit: sim.profit,
                    roi: sim.roi,
                    maxDD: sim.maxDrawdown,
                    survived: sim.finalBankroll >= 1,
                    finalBR: sim.finalBankroll,
                    sharpe: sim.sharpe
                });
            }
            
            // Trouver les optimaux selon diff√©rents crit√®res
            var survivedFlat = flatTests.filter(function(t) { return t.survived; });
            var survivedPct = pctTests.filter(function(t) { return t.survived; });
            
            // Optimal profit (parmi ceux qui survivent)
            var bestProfitFlat = survivedFlat.length > 0 ? survivedFlat.reduce(function(a, b) { return a.profit > b.profit ? a : b; }) : null;
            var bestProfitPct = survivedPct.length > 0 ? survivedPct.reduce(function(a, b) { return a.profit > b.profit ? a : b; }) : null;
            
            // Optimal Sharpe (meilleur ratio risque/rendement)
            var bestSharpeFlat = survivedFlat.length > 0 ? survivedFlat.reduce(function(a, b) { return a.sharpe > b.sharpe ? a : b; }) : null;
            var bestSharpePct = survivedPct.length > 0 ? survivedPct.reduce(function(a, b) { return a.sharpe > b.sharpe ? a : b; }) : null;
            
            // Safe (drawdown < 40% et survie)
            var safeFlat = survivedFlat.filter(function(t) { return t.maxDD < 40; });
            var safePct = survivedPct.filter(function(t) { return t.maxDD < 40; });
            var bestSafeFlat = safeFlat.length > 0 ? safeFlat.reduce(function(a, b) { return a.profit > b.profit ? a : b; }) : null;
            var bestSafePct = safePct.length > 0 ? safePct.reduce(function(a, b) { return a.profit > b.profit ? a : b; }) : null;
            
            // Construire le HTML
            var html = '';
            
            // Recommandations principales
            html += '<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:1rem;margin-bottom:1.5rem">';
            
            // Safe
            html += '<div style="background:linear-gradient(135deg,rgba(34,197,94,.15),transparent);border:2px solid var(--green);border-radius:12px;padding:1.25rem;text-align:center">' +
                '<div style="font-size:.75rem;color:var(--muted);margin-bottom:.5rem">üõ°Ô∏è SAFE (DD < 40%)</div>';
            if (bestSafeFlat) {
                html += '<div style="font-size:1.8rem;font-weight:700;color:var(--green)">' + bestSafeFlat.stake + '‚Ç¨</div>' +
                    '<div style="font-size:.85rem;color:var(--muted)">Flat</div>' +
                    '<div style="font-size:.8rem;margin-top:.5rem">DD: -' + bestSafeFlat.maxDD.toFixed(0) + '% | +' + formatMoney(bestSafeFlat.profit) + '</div>';
            } else {
                html += '<div style="color:var(--red)">Aucune config safe</div>';
            }
            html += '</div>';
            
            // Best Sharpe
            html += '<div style="background:linear-gradient(135deg,rgba(77,159,255,.15),transparent);border:2px solid var(--blue);border-radius:12px;padding:1.25rem;text-align:center">' +
                '<div style="font-size:.75rem;color:var(--muted);margin-bottom:.5rem">‚öñÔ∏è √âQUILIBR√â (Sharpe)</div>';
            if (bestSharpeFlat) {
                html += '<div style="font-size:1.8rem;font-weight:700;color:var(--blue)">' + bestSharpeFlat.stake + '‚Ç¨</div>' +
                    '<div style="font-size:.85rem;color:var(--muted)">Flat</div>' +
                    '<div style="font-size:.8rem;margin-top:.5rem">Sharpe: ' + bestSharpeFlat.sharpe.toFixed(2) + ' | +' + formatMoney(bestSharpeFlat.profit) + '</div>';
            } else {
                html += '<div style="color:var(--red)">Aucune config</div>';
            }
            html += '</div>';
            
            // Max Profit
            html += '<div style="background:linear-gradient(135deg,rgba(249,115,22,.15),transparent);border:2px solid var(--orange);border-radius:12px;padding:1.25rem;text-align:center">' +
                '<div style="font-size:.75rem;color:var(--muted);margin-bottom:.5rem">üî• MAX PROFIT</div>';
            if (bestProfitFlat) {
                html += '<div style="font-size:1.8rem;font-weight:700;color:var(--orange)">' + bestProfitFlat.stake + '‚Ç¨</div>' +
                    '<div style="font-size:.85rem;color:var(--muted)">Flat</div>' +
                    '<div style="font-size:.8rem;margin-top:.5rem">DD: -' + bestProfitFlat.maxDD.toFixed(0) + '% | +' + formatMoney(bestProfitFlat.profit) + '</div>';
            } else {
                html += '<div style="color:var(--red)">Aucune config</div>';
            }
            html += '</div>';
            
            html += '</div>';
            
            // Tableau Flat
            html += '<div style="margin-bottom:1.5rem">' +
                '<div style="font-weight:600;margin-bottom:.5rem;color:var(--blue)">üíµ Analyse Mise Flat</div>' +
                '<div style="overflow-x:auto"><table style="width:100%;border-collapse:collapse;font-size:.8rem">' +
                '<thead><tr style="border-bottom:2px solid var(--border);background:var(--bg)">' +
                '<th style="padding:.5rem;text-align:left">Mise</th>' +
                '<th style="padding:.5rem;text-align:right">Profit</th>' +
                '<th style="padding:.5rem;text-align:right">ROI</th>' +
                '<th style="padding:.5rem;text-align:right">Max DD</th>' +
                '<th style="padding:.5rem;text-align:right">Sharpe</th>' +
                '<th style="padding:.5rem;text-align:center">Survie</th>' +
                '<th style="padding:.5rem;text-align:center">Verdict</th>' +
                '</tr></thead><tbody>';
            
            for (var i = 0; i < flatTests.length; i++) {
                var t = flatTests[i];
                var verdict = '';
                var rowStyle = '';
                
                if (!t.survived) {
                    verdict = 'üíÄ';
                    rowStyle = 'opacity:.5;';
                } else if (t.maxDD > 60) {
                    verdict = '‚ö†Ô∏è Risqu√©';
                } else if (t.maxDD > 40) {
                    verdict = 'üòê Ok';
                } else if (t.maxDD <= 40 && t.profit > 0) {
                    verdict = '‚úÖ Bon';
                }
                
                if (bestSafeFlat && t.stake === bestSafeFlat.stake) {
                    rowStyle += 'background:rgba(34,197,94,.1);';
                    verdict = 'üèÜ SAFE';
                }
                if (bestSharpeFlat && t.stake === bestSharpeFlat.stake) {
                    verdict = '‚≠ê BEST';
                }
                
                html += '<tr style="border-bottom:1px solid var(--border);' + rowStyle + '">' +
                    '<td style="padding:.5rem;font-weight:600">' + t.stake + '‚Ç¨</td>' +
                    '<td style="padding:.5rem;text-align:right;color:' + (t.profit >= 0 ? 'var(--green)' : 'var(--red)') + '">' + formatMoney(t.profit) + '</td>' +
                    '<td style="padding:.5rem;text-align:right">' + t.roi.toFixed(1) + '%</td>' +
                    '<td style="padding:.5rem;text-align:right;color:' + (t.maxDD > 50 ? 'var(--red)' : t.maxDD > 30 ? 'var(--yellow)' : 'var(--green)') + '">-' + t.maxDD.toFixed(0) + '%</td>' +
                    '<td style="padding:.5rem;text-align:right">' + t.sharpe.toFixed(2) + '</td>' +
                    '<td style="padding:.5rem;text-align:center">' + (t.survived ? '‚úÖ' : 'üíÄ') + '</td>' +
                    '<td style="padding:.5rem;text-align:center">' + verdict + '</td>' +
                    '</tr>';
            }
            html += '</tbody></table></div></div>';
            
            // Tableau % Bankroll
            html += '<div style="margin-bottom:1.5rem">' +
                '<div style="font-weight:600;margin-bottom:.5rem;color:var(--green)">üìä Analyse % Bankroll</div>' +
                '<div style="overflow-x:auto"><table style="width:100%;border-collapse:collapse;font-size:.8rem">' +
                '<thead><tr style="border-bottom:2px solid var(--border);background:var(--bg)">' +
                '<th style="padding:.5rem;text-align:left">%</th>' +
                '<th style="padding:.5rem;text-align:right">Profit</th>' +
                '<th style="padding:.5rem;text-align:right">ROI</th>' +
                '<th style="padding:.5rem;text-align:right">Max DD</th>' +
                '<th style="padding:.5rem;text-align:right">Sharpe</th>' +
                '<th style="padding:.5rem;text-align:center">Survie</th>' +
                '<th style="padding:.5rem;text-align:center">Verdict</th>' +
                '</tr></thead><tbody>';
            
            for (var i = 0; i < pctTests.length; i++) {
                var t = pctTests[i];
                var verdict = '';
                var rowStyle = '';
                
                if (!t.survived) {
                    verdict = 'üíÄ';
                    rowStyle = 'opacity:.5;';
                } else if (t.maxDD > 60) {
                    verdict = '‚ö†Ô∏è Risqu√©';
                } else if (t.maxDD > 40) {
                    verdict = 'üòê Ok';
                } else {
                    verdict = '‚úÖ Bon';
                }
                
                if (bestSafePct && t.pct === bestSafePct.pct) {
                    rowStyle += 'background:rgba(34,197,94,.1);';
                    verdict = 'üèÜ SAFE';
                }
                if (bestSharpePct && t.pct === bestSharpePct.pct) {
                    verdict = '‚≠ê BEST';
                }
                
                html += '<tr style="border-bottom:1px solid var(--border);' + rowStyle + '">' +
                    '<td style="padding:.5rem;font-weight:600">' + t.pct + '%</td>' +
                    '<td style="padding:.5rem;text-align:right;color:' + (t.profit >= 0 ? 'var(--green)' : 'var(--red)') + '">' + formatMoney(t.profit) + '</td>' +
                    '<td style="padding:.5rem;text-align:right">' + t.roi.toFixed(1) + '%</td>' +
                    '<td style="padding:.5rem;text-align:right;color:' + (t.maxDD > 50 ? 'var(--red)' : t.maxDD > 30 ? 'var(--yellow)' : 'var(--green)') + '">-' + t.maxDD.toFixed(0) + '%</td>' +
                    '<td style="padding:.5rem;text-align:right">' + t.sharpe.toFixed(2) + '</td>' +
                    '<td style="padding:.5rem;text-align:center">' + (t.survived ? '‚úÖ' : 'üíÄ') + '</td>' +
                    '<td style="padding:.5rem;text-align:center">' + verdict + '</td>' +
                    '</tr>';
            }
            html += '</tbody></table></div></div>';
            
            // Recommandation finale
            var recFlat = bestSafeFlat || bestSharpeFlat || survivedFlat[0];
            var recPct = bestSafePct || bestSharpePct || survivedPct[0];
            
            html += '<div style="background:var(--bg);border-radius:12px;padding:1.25rem;border-left:4px solid var(--green)">' +
                '<div style="font-weight:700;font-size:1rem;margin-bottom:.75rem">üí° Recommandation pour ta bankroll de ' + formatMoney(bankroll) + '</div>' +
                '<div style="display:grid;grid-template-columns:1fr 1fr;gap:1rem">';
            
            if (recFlat) {
                html += '<div>' +
                    '<div style="font-size:.85rem;color:var(--muted)">Mise Flat recommand√©e :</div>' +
                    '<div style="font-size:1.5rem;font-weight:700;color:var(--blue)">' + recFlat.stake + '‚Ç¨</div>' +
                    '<div style="font-size:.75rem;color:var(--muted)">DD attendu: -' + recFlat.maxDD.toFixed(0) + '% | Profit historique: +' + formatMoney(recFlat.profit) + '</div>' +
                    '</div>';
            }
            
            if (recPct) {
                html += '<div>' +
                    '<div style="font-size:.85rem;color:var(--muted)">% Bankroll recommand√© :</div>' +
                    '<div style="font-size:1.5rem;font-weight:700;color:var(--green)">' + recPct.pct + '%</div>' +
                    '<div style="font-size:.75rem;color:var(--muted)">DD attendu: -' + recPct.maxDD.toFixed(0) + '% | Profit historique: +' + formatMoney(recPct.profit) + '</div>' +
                    '</div>';
            }
            
            html += '</div></div>';
            
            // Bouton pour appliquer
            html += '<div style="margin-top:1rem;display:flex;gap:.5rem">';
            if (recFlat) {
                html += '<button onclick="document.getElementById(\'cfgStake\').value=' + recFlat.stake + ';runSimulation()" style="background:var(--blue);color:#fff;border:none;padding:.75rem 1rem;border-radius:6px;cursor:pointer;font-size:.85rem">Appliquer Flat ' + recFlat.stake + '‚Ç¨ et simuler</button>';
            }
            if (recPct) {
                html += '<button onclick="document.getElementById(\'cfgPctStake\').value=' + recPct.pct + ';runSimulation()" style="background:var(--green);color:#000;border:none;padding:.75rem 1rem;border-radius:6px;cursor:pointer;font-size:.85rem">Appliquer ' + recPct.pct + '% et simuler</button>';
            }
            html += '</div>';
            
            safeHTML('optimizerContent', html);
        }
        
        function renderKellyTable(bets) {
            // Grouper par niche
            var nicheStats = {};
            for (var i = 0; i < bets.length; i++) {
                var bet = bets[i];
                if (!nicheStats[bet.niche]) {
                    nicheStats[bet.niche] = { wins: 0, total: 0, odds: [] };
                }
                nicheStats[bet.niche].total++;
                if (bet.won) nicheStats[bet.niche].wins++;
                nicheStats[bet.niche].odds.push(bet.odds);
            }
            
            var html = '<table style="width:100%;border-collapse:collapse;font-size:.85rem">' +
                '<thead><tr style="border-bottom:2px solid var(--border)">' +
                '<th style="text-align:left;padding:.5rem">Niche</th>' +
                '<th style="text-align:right;padding:.5rem">Paris</th>' +
                '<th style="text-align:right;padding:.5rem">Win%</th>' +
                '<th style="text-align:right;padding:.5rem">Cote moy.</th>' +
                '<th style="text-align:right;padding:.5rem">EV</th>' +
                '<th style="text-align:right;padding:.5rem">Kelly%</th>' +
                '<th style="text-align:right;padding:.5rem">Mise √∑4</th>' +
                '</tr></thead><tbody>';
            
            var bankroll = parseFloat(document.getElementById('cfgBankroll').value) || 5000;
            var kellyDivEl = document.getElementById('simKellyDiv');
            var kellyDiv = kellyDivEl ? parseFloat(kellyDivEl.value) || 4 : 4;
            
            // Convertir en array et trier par Kelly
            var nichesArray = [];
            for (var niche in nicheStats) {
                var s = nicheStats[niche];
                var winrate = s.wins / s.total;
                var avgOdds = s.odds.reduce(function(a, b) { return a + b; }, 0) / s.odds.length;
                var kelly = (winrate * avgOdds - 1) / (avgOdds - 1);
                var ev = (winrate * avgOdds - 1) * 100;
                nichesArray.push({
                    name: niche,
                    total: s.total,
                    winrate: winrate,
                    avgOdds: avgOdds,
                    kelly: kelly,
                    ev: ev
                });
            }
            nichesArray.sort(function(a, b) { return b.kelly - a.kelly; });
            
            for (var i = 0; i < nichesArray.length; i++) {
                var n = nichesArray[i];
                var kelly = Math.max(0, n.kelly);
                var adjKelly = kelly / kellyDiv;
                var recStake = bankroll * adjKelly;
                
                var kellyColor = kelly > 0.1 ? 'var(--green)' : kelly > 0.05 ? 'var(--yellow)' : kelly > 0 ? 'var(--orange)' : 'var(--red)';
                var evColor = n.ev > 10 ? 'var(--green)' : n.ev > 0 ? 'var(--yellow)' : 'var(--red)';
                
                html += '<tr style="border-bottom:1px solid var(--border)">' +
                    '<td style="padding:.5rem;font-size:.8rem">' + n.name + '</td>' +
                    '<td style="padding:.5rem;text-align:right">' + n.total + '</td>' +
                    '<td style="padding:.5rem;text-align:right">' + (n.winrate * 100).toFixed(1) + '%</td>' +
                    '<td style="padding:.5rem;text-align:right">' + n.avgOdds.toFixed(2) + '</td>' +
                    '<td style="padding:.5rem;text-align:right;color:' + evColor + '">' + (n.ev >= 0 ? '+' : '') + n.ev.toFixed(1) + '%</td>' +
                    '<td style="padding:.5rem;text-align:right;color:' + kellyColor + ';font-weight:600">' + (kelly * 100).toFixed(1) + '%</td>' +
                    '<td style="padding:.5rem;text-align:right;font-weight:600">' + recStake.toFixed(0) + '‚Ç¨</td>' +
                    '</tr>';
            }
            
            html += '</tbody></table>';
            safeHTML('kellyTable', html);
        }
        
        function renderYearlyBreakdown(bets, flatStake, pctStake) {
            // Grouper les paris par ann√©e
            var yearlyData = {};
            for (var i = 0; i < bets.length; i++) {
                var year = bets[i].date.substring(0, 4);
                if (!yearlyData[year]) {
                    yearlyData[year] = [];
                }
                yearlyData[year].push(bets[i]);
            }
            
            var years = Object.keys(yearlyData).sort();
            var bankroll = parseFloat(document.getElementById('cfgBankroll').value) || 5000;
            
            // D√©terminer le mode d'affichage
            var displayUnits = (yearlyDisplayMode === 'units');
            var profitHeader = displayUnits ? 'P/L (u)' : 'P/L Flat';
            
            // Calculer les stats pour chaque ann√©e (en flat pour simplifier)
            var html = '<div style="overflow-x:auto"><table style="width:100%;border-collapse:collapse;font-size:.8rem">' +
                '<thead><tr style="border-bottom:2px solid var(--border)">' +
                '<th style="text-align:left;padding:.5rem">Ann√©e</th>' +
                '<th style="text-align:right;padding:.5rem">Paris</th>' +
                '<th style="text-align:right;padding:.5rem">W</th>' +
                '<th style="text-align:right;padding:.5rem">L</th>' +
                '<th style="text-align:right;padding:.5rem">Win%</th>' +
                '<th style="text-align:right;padding:.5rem">Cote moy</th>' +
                '<th style="text-align:right;padding:.5rem">' + profitHeader + '</th>' +
                '<th style="text-align:right;padding:.5rem">ROI</th>' +
                '<th style="text-align:center;padding:.5rem">Tendance</th>' +
                '</tr></thead><tbody>';
            
            var profitableYears = 0;
            var totalProfit = 0;
            var totalStaked = 0;
            
            for (var i = 0; i < years.length; i++) {
                var year = years[i];
                var yearBets = yearlyData[year];
                var wins = yearBets.filter(function(b) { return b.won; }).length;
                var losses = yearBets.length - wins;
                var winrate = wins / yearBets.length;
                var avgOdds = yearBets.reduce(function(a, b) { return a + b.odds; }, 0) / yearBets.length;
                
                // Calculer P/L flat AVEC coefficients de mise
                var yearProfit = 0;
                var yearStaked = 0;
                for (var j = 0; j < yearBets.length; j++) {
                    var bet = yearBets[j];
                    var stakeCoef = 1.0;
                    if (currentStakeMode === 'custom' && bet.nicheObj && bet.nicheObj.stakeCoef) {
                        stakeCoef = bet.nicheObj.stakeCoef;
                    }
                    var actualStake = flatStake * stakeCoef;
                    yearStaked += actualStake;
                    yearProfit += bet.won ? actualStake * (bet.odds - 1) : -actualStake;
                }
                var yearROI = yearStaked > 0 ? (yearProfit / yearStaked * 100) : 0;
                totalProfit += yearProfit;
                totalStaked += yearStaked;
                
                if (yearProfit > 0) profitableYears++;
                
                var profitColor = yearProfit >= 0 ? 'var(--green)' : 'var(--red)';
                var trendBars = '';
                var barCount = Math.min(Math.abs(Math.round(yearROI / 10)), 5);
                for (var b = 0; b < barCount; b++) {
                    trendBars += yearProfit >= 0 ? 'üü©' : 'üü•';
                }
                if (barCount === 0) trendBars = '‚ûñ';
                
                // Profit en ‚Ç¨ ou unit√©s
                var profitDisplay;
                if (displayUnits) {
                    var profitUnits = yearProfit / flatStake;
                    profitDisplay = (profitUnits >= 0 ? '+' : '') + profitUnits.toFixed(1) + 'u';
                } else {
                    profitDisplay = (yearProfit >= 0 ? '+' : '') + yearProfit.toFixed(0) + '‚Ç¨';
                }
                
                html += '<tr style="border-bottom:1px solid var(--border)">' +
                    '<td style="padding:.5rem;font-weight:600">' + year + '</td>' +
                    '<td style="padding:.5rem;text-align:right">' + yearBets.length + '</td>' +
                    '<td style="padding:.5rem;text-align:right;color:var(--green)">' + wins + '</td>' +
                    '<td style="padding:.5rem;text-align:right;color:var(--red)">' + losses + '</td>' +
                    '<td style="padding:.5rem;text-align:right">' + (winrate * 100).toFixed(0) + '%</td>' +
                    '<td style="padding:.5rem;text-align:right">' + avgOdds.toFixed(2) + '</td>' +
                    '<td style="padding:.5rem;text-align:right;color:' + profitColor + ';font-weight:600">' + profitDisplay + '</td>' +
                    '<td style="padding:.5rem;text-align:right;color:' + profitColor + '">' + (yearROI >= 0 ? '+' : '') + yearROI.toFixed(0) + '%</td>' +
                    '<td style="padding:.5rem;text-align:center">' + trendBars + '</td>' +
                    '</tr>';
            }
            
            html += '</tbody></table></div>';
            
            // R√©sum√©
            var consistencyPct = (profitableYears / years.length * 100).toFixed(0);
            var consistencyColor = consistencyPct >= 70 ? 'var(--green)' : consistencyPct >= 50 ? 'var(--yellow)' : 'var(--red)';
            
            // Profit total en ‚Ç¨ ou unit√©s
            var totalProfitDisplay;
            var avgProfitDisplay;
            if (displayUnits) {
                var totalUnits = totalProfit / flatStake;
                var avgUnits = totalUnits / years.length;
                totalProfitDisplay = (totalUnits >= 0 ? '+' : '') + totalUnits.toFixed(1) + 'u';
                avgProfitDisplay = '+' + avgUnits.toFixed(1) + 'u';
            } else {
                totalProfitDisplay = (totalProfit >= 0 ? '+' : '') + totalProfit.toFixed(0) + '‚Ç¨';
                avgProfitDisplay = '+' + (totalProfit / years.length).toFixed(0) + '‚Ç¨';
            }
            
            html += '<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:1rem;margin-top:1rem">' +
                '<div style="background:var(--bg);padding:1rem;border-radius:8px;text-align:center">' +
                '<div style="font-size:.75rem;color:var(--muted)">Ann√©es rentables</div>' +
                '<div style="font-size:1.5rem;font-weight:700;color:' + consistencyColor + '">' + profitableYears + '/' + years.length + '</div>' +
                '<div style="font-size:.7rem;color:var(--muted)">' + consistencyPct + '% de r√©gularit√©</div>' +
                '</div>' +
                '<div style="background:var(--bg);padding:1rem;border-radius:8px;text-align:center">' +
                '<div style="font-size:.75rem;color:var(--muted)">Profit total' + (displayUnits ? '' : ' (flat)') + '</div>' +
                '<div style="font-size:1.5rem;font-weight:700;color:' + (totalProfit >= 0 ? 'var(--green)' : 'var(--red)') + '">' + totalProfitDisplay + '</div>' +
                '</div>' +
                '<div style="background:var(--bg);padding:1rem;border-radius:8px;text-align:center">' +
                '<div style="font-size:.75rem;color:var(--muted)">Profit moyen/an</div>' +
                '<div style="font-size:1.5rem;font-weight:700;color:var(--green)">' + avgProfitDisplay + '</div>' +
                '</div>' +
                '</div>';
            
            // Indicateur du mode d'affichage
            if (displayUnits) {
                html += '<div style="font-size:.65rem;color:var(--muted);margin-top:.5rem;text-align:right">1 unit√© = ' + flatStake + '‚Ç¨ (mise de base)</div>';
            }
            
            // Warning si pas assez r√©gulier
            if (consistencyPct < 60) {
                html += '<div style="margin-top:1rem;padding:1rem;background:rgba(239,68,68,.1);border:1px solid var(--red);border-radius:8px">' +
                    '<div style="font-weight:600;color:var(--red)">‚ö†Ô∏è Attention : R√©gularit√© faible</div>' +
                    '<div style="font-size:.85rem;color:var(--muted);margin-top:.5rem">Moins de 60% d\'ann√©es rentables. La strat√©gie pourrait √™tre trop d√©pendante de quelques bonnes ann√©es exceptionnelles.</div>' +
                    '</div>';
            } else if (consistencyPct >= 80) {
                html += '<div style="margin-top:1rem;padding:1rem;background:rgba(34,197,94,.1);border:1px solid var(--green);border-radius:8px">' +
                    '<div style="font-weight:600;color:var(--green)">‚úÖ Excellente r√©gularit√©</div>' +
                    '<div style="font-size:.85rem;color:var(--muted);margin-top:.5rem">Plus de 80% d\'ann√©es rentables. La strat√©gie est stable et fiable sur le long terme.</div>' +
                    '</div>';
            }
            
            safeHTML('yearlyBreakdown', html);
        }
        
        // Variable globale pour l'ann√©e s√©lectionn√©e dans les moments difficiles
        var roughPeriodsSelectedYear = 'all';
        
        // Analyse des moments difficiles - p√©riodes de souffrance psychologique
        function analyzeRoughPeriods(results, initialBankroll, flatStake, selectedYear) {
            var container = document.getElementById('roughPeriodsAnalysis');
            if (!container) return;
            
            if (!results || results.length < 10) {
                container.innerHTML = '<div style="color:var(--muted)">Pas assez de donn√©es pour analyser les moments difficiles.</div>';
                return;
            }
            
            // Stocker les donn√©es pour les callbacks
            window.lastRoughPeriodsData = { results: results, bankroll: initialBankroll, flatStake: flatStake };
            
            // Collecter les ann√©es disponibles
            var yearsSet = {};
            for (var i = 0; i < results.length; i++) {
                if (results[i].date) {
                    yearsSet[results[i].date.substring(0, 4)] = true;
                }
            }
            var availableYears = Object.keys(yearsSet).sort();
            
            // G√©rer l'ann√©e s√©lectionn√©e
            if (selectedYear !== undefined) {
                roughPeriodsSelectedYear = selectedYear;
            }
            var filterYear = roughPeriodsSelectedYear;
            
            var html = '';
            
            // S√©lecteur d'ann√©es
            html += '<div style="display:flex;gap:.25rem;margin-bottom:1rem;flex-wrap:wrap">';
            html += '<button onclick="analyzeRoughPeriods(window.lastRoughPeriodsData.results, window.lastRoughPeriodsData.bankroll, window.lastRoughPeriodsData.flatStake, \'all\')" style="padding:.3rem .6rem;font-size:.7rem;border:1px solid ' + (filterYear === 'all' ? 'var(--blue)' : 'var(--border)') + ';background:' + (filterYear === 'all' ? 'var(--blue)' : 'transparent') + ';color:' + (filterYear === 'all' ? '#fff' : 'var(--muted)') + ';border-radius:4px;cursor:pointer">Tout</button>';
            for (var yi = 0; yi < availableYears.length; yi++) {
                var yr = availableYears[yi];
                var isActive = filterYear === yr;
                html += '<button onclick="analyzeRoughPeriods(window.lastRoughPeriodsData.results, window.lastRoughPeriodsData.bankroll, window.lastRoughPeriodsData.flatStake, \'' + yr + '\')" style="padding:.3rem .6rem;font-size:.7rem;border:1px solid ' + (isActive ? 'var(--blue)' : 'var(--border)') + ';background:' + (isActive ? 'var(--blue)' : 'transparent') + ';color:' + (isActive ? '#fff' : 'var(--muted)') + ';border-radius:4px;cursor:pointer">' + yr + '</button>';
            }
            html += '</div>';
            
            // Filtrer les r√©sultats par ann√©e si n√©cessaire
            var filteredResults = results;
            var startBankroll = initialBankroll;
            
            if (filterYear !== 'all') {
                // Trouver la bankroll au d√©but de l'ann√©e
                var foundStart = false;
                for (var i = 0; i < results.length; i++) {
                    if (results[i].date && results[i].date.substring(0, 4) === filterYear) {
                        startBankroll = i > 0 ? results[i - 1].bankroll : initialBankroll;
                        foundStart = true;
                        break;
                    }
                }
                
                if (!foundStart) {
                    html += '<div style="color:var(--muted)">Aucune donn√©e pour ' + filterYear + '.</div>';
                    container.innerHTML = html;
                    return;
                }
                
                // Filtrer pour n'avoir que cette ann√©e
                filteredResults = results.filter(function(r) {
                    return r.date && r.date.substring(0, 4) === filterYear;
                });
            }
            
            // Indicateur de strat√©gie
            html += '<div style="font-size:.75rem;color:var(--muted);margin-bottom:.75rem;padding:.5rem;background:var(--bg);border-radius:4px">';
            html += 'üíµ Calcul bas√© sur <b>mise Flat ' + flatStake + '‚Ç¨</b>';
            if (filterYear !== 'all') {
                html += ' ‚Ä¢ Bankroll d√©but ' + filterYear + ': <b>' + formatMoney(startBankroll) + '</b>';
            }
            html += '</div>';
            
            // 1. Identifier TOUTES les vall√©es (seuils bas pour ne rien rater)
            var valleys = [];
            var peak = startBankroll;
            var peakIdx = 0;
            var peakDate = filteredResults[0] ? filteredResults[0].date : '';
            var valleyMin = startBankroll;
            var valleyMinIdx = 0;
            
            // On track TOUJOURS le minimum depuis le dernier peak
            for (var i = 0; i < filteredResults.length; i++) {
                var r = filteredResults[i];
                var br = r.bankroll;
                
                if (br > peak) {
                    // Nouveau peak - on ferme la vall√©e pr√©c√©dente si significative
                    var depth = peak > 0 ? (peak - valleyMin) / peak * 100 : 0;
                    var nbParis = valleyMinIdx - peakIdx;
                    
                    // Enregistrer si: >3% de depth OU >15 paris de descente
                    if (depth > 3 || nbParis > 15) {
                        valleys.push({
                            peakValue: peak,
                            peakDate: peakDate,
                            peakIdx: peakIdx,
                            minValue: valleyMin,
                            minIdx: valleyMinIdx,
                            minDate: filteredResults[valleyMinIdx] ? filteredResults[valleyMinIdx].date : '',
                            recoveryIdx: i,
                            recoveryDate: r.date,
                            depth: depth,
                            depthAbs: peak - valleyMin,
                            nbParis: nbParis,
                            ongoing: false
                        });
                    }
                    
                    // Reset pour la prochaine vall√©e
                    peak = br;
                    peakIdx = i;
                    peakDate = r.date;
                    valleyMin = br;
                    valleyMinIdx = i;
                } else {
                    // On descend - tracker le minimum
                    if (br < valleyMin) {
                        valleyMin = br;
                        valleyMinIdx = i;
                    }
                }
            }
            
            // Vall√©e en cours (pas encore r√©cup√©r√©e)
            var finalDepth = peak > 0 ? (peak - valleyMin) / peak * 100 : 0;
            var finalNbParis = valleyMinIdx - peakIdx;
            if (finalDepth > 3 || finalNbParis > 15) {
                valleys.push({
                    peakValue: peak,
                    peakDate: peakDate,
                    peakIdx: peakIdx,
                    minValue: valleyMin,
                    minIdx: valleyMinIdx,
                    minDate: filteredResults[valleyMinIdx] ? filteredResults[valleyMinIdx].date : '',
                    recoveryIdx: null,
                    recoveryDate: null,
                    depth: finalDepth,
                    depthAbs: peak - valleyMin,
                    nbParis: finalNbParis,
                    ongoing: true
                });
            }
            
            // 2. Filtrer pour garder les vall√©es vraiment significatives
            // Crit√®res: >5% depth OU >20 paris OU >=150‚Ç¨ de perte absolue
            var significantValleys = valleys.filter(function(v) { 
                return v.depth > 5 || v.nbParis > 20 || v.depthAbs >= 150;
            });
            
            // Trier par ordre CHRONOLOGIQUE (date du peak)
            significantValleys.sort(function(a, b) { 
                if (!a.peakDate || a.peakDate === 'start') return -1;
                if (!b.peakDate || b.peakDate === 'start') return 1;
                return a.peakDate.localeCompare(b.peakDate);
            });
            
            if (significantValleys.length === 0) {
                html += '<div style="background:rgba(34,197,94,.1);border:1px solid var(--green);border-radius:8px;padding:1rem;text-align:center">';
                html += '<div style="font-size:1.5rem;margin-bottom:.5rem">üòé</div>';
                html += '<div style="font-weight:600;color:var(--green)">Parcours tranquille' + (filterYear !== 'all' ? ' en ' + filterYear : '') + ' !</div>';
                html += '<div style="font-size:.85rem;color:var(--muted);margin-top:.5rem">Pas de p√©riode vraiment difficile d√©tect√©e.</div>';
                html += '</div>';
            } else {
                html += '<div style="font-size:.85rem;color:var(--muted);margin-bottom:1rem">';
                html += 'Les moments o√π tu aurais dout√©. Ce sont des <b>p√©riodes de gal√®re</b> o√π ta bankroll fondait, peu importe les victoires ponctuelles.';
                html += '</div>';
                
                for (var v = 0; v < Math.min(significantValleys.length, 5); v++) {
                    var valley = significantValleys[v];
                    
                    // Calculer les stats de la p√©riode (du peak au point bas)
                    // IMPORTANT: ignorer les entr√©es avec won=null (comme "start")
                    var wins = 0, losses = 0;
                    for (var p = valley.peakIdx + 1; p <= valley.minIdx; p++) {
                        if (filteredResults[p] && filteredResults[p].won === true) wins++;
                        else if (filteredResults[p] && filteredResults[p].won === false) losses++;
                        // won=null ‚Üí ignor√© (c'est le "start" ou une entr√©e invalide)
                    }
                    var totalBets = wins + losses;
                    var winrate = totalBets > 0 ? (wins / totalBets * 100).toFixed(0) : 0;
                    
                    // Calculer la dur√©e en jours (du peak au point bas)
                    var peakDateStr = valley.peakDate || '';
                    var minDateStr = valley.minDate || '';
                    var durationDays = 1;
                    if (peakDateStr && minDateStr && peakDateStr !== 'start' && minDateStr !== 'start') {
                        var peakDateObj = new Date(peakDateStr);
                        var minDateObj = new Date(minDateStr);
                        durationDays = Math.max(1, Math.round((minDateObj - peakDateObj) / (1000 * 60 * 60 * 24)));
                    }
                    
                    // Couleur selon la gravit√©
                    var severityColor = valley.depth > 25 ? 'var(--red)' : valley.depth > 15 ? 'var(--yellow)' : 'var(--blue)';
                    var severityEmoji = valley.depth > 25 ? 'üÜò' : valley.depth > 15 ? 'üò∞' : 'üòï';
                    
                    // Passage en n√©gatif ? (par rapport au d√©but de la p√©riode analys√©e)
                    var wentNegative = valley.minValue < startBankroll;
                    
                    html += '<div style="background:var(--bg);border-radius:8px;padding:1rem;margin-bottom:1rem;border-left:4px solid ' + severityColor + '">';
                    
                    // Header
                    html += '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:.75rem">';
                    html += '<div style="font-weight:700;font-size:1rem">' + severityEmoji + ' P√©riode #' + (v + 1) + '</div>';
                    html += '<div style="font-size:.75rem;color:var(--muted)">' + formatDateFr(valley.peakDate) + ' ‚Üí ' + formatDateFr(valley.minDate) + '</div>';
                    html += '</div>';
                    
                    // Le r√©cit
                    html += '<div style="background:var(--card);border-radius:6px;padding:.75rem;margin-bottom:.75rem">';
                    html += '<div style="font-size:.85rem;line-height:1.6">';
                    
                    // Calculer les unit√©s
                    var peakUnits = (valley.peakValue - initialBankroll) / flatStake;
                    var lossUnits = valley.depthAbs / flatStake;
                    
                    html += 'üìà Tu √©tais √† <b style="color:var(--green)">' + formatMoney(valley.peakValue) + '</b>';
                    if (valley.peakValue > startBankroll) {
                        html += ' <span style="color:var(--green)">(+' + formatMoney(valley.peakValue - startBankroll) + ' = +' + ((valley.peakValue - startBankroll) / flatStake).toFixed(1) + 'u)</span>';
                    }
                    html += '.<br>';
                    
                    html += 'üìâ Sur <b>' + totalBets + ' paris</b> (~' + durationDays + 'j) : ';
                    html += '<span style="color:var(--green)">' + wins + 'W</span> / <span style="color:var(--red)">' + losses + 'L</span> (' + winrate + '%).<br>';
                    html += '‚Üí Bankroll tomb√©e √† <b style="color:' + severityColor + '">' + formatMoney(valley.minValue) + '</b>';
                    html += ' <span style="color:var(--red)">(-' + valley.depth.toFixed(0) + '% = -' + lossUnits.toFixed(1) + 'u)</span>';
                    
                    if (wentNegative) {
                        var negativeUnits = (startBankroll - valley.minValue) / flatStake;
                        html += '<br>‚ö†Ô∏è <b style="color:var(--red)">Passage en n√©gatif</b> de ' + negativeUnits.toFixed(1) + 'u vs d√©but p√©riode !';
                    }
                    
                    if (valley.ongoing) {
                        html += '<br>‚è≥ <b>Toujours en cours</b> ‚Äî pas encore remont√© au peak.';
                    } else {
                        var recoveryDays = Math.round((new Date(valley.recoveryDate) - minDateObj) / (1000 * 60 * 60 * 24));
                        html += '<br>‚úÖ R√©cup√©r√© le ' + formatDateFr(valley.recoveryDate) + ' (+' + recoveryDays + 'j).';
                    }
                    
                    html += '</div></div>';
                    
                    // Stats compactes - avec unit√©s
                    html += '<div style="display:grid;grid-template-columns:repeat(5,1fr);gap:.5rem;font-size:.7rem;text-align:center">';
                    html += '<div style="background:var(--card);padding:.4rem;border-radius:4px"><div style="font-weight:700;color:' + severityColor + '">-' + valley.depth.toFixed(0) + '%</div><div style="color:var(--muted)">Chute</div></div>';
                    html += '<div style="background:var(--card);padding:.4rem;border-radius:4px"><div style="font-weight:700;color:var(--red)">-' + lossUnits.toFixed(1) + 'u</div><div style="color:var(--muted)">Perte</div></div>';
                    html += '<div style="background:var(--card);padding:.4rem;border-radius:4px"><div style="font-weight:700">' + totalBets + '</div><div style="color:var(--muted)">Paris</div></div>';
                    html += '<div style="background:var(--card);padding:.4rem;border-radius:4px"><div style="font-weight:700">' + durationDays + 'j</div><div style="color:var(--muted)">Dur√©e</div></div>';
                    html += '<div style="background:var(--card);padding:.4rem;border-radius:4px"><div style="font-weight:700">' + winrate + '%</div><div style="color:var(--muted)">WR</div></div>';
                    html += '</div>';
                    
                    html += '</div>';
                }
                
                // R√©sum√©
                // Trouver la pire vall√©e (plus profonde)
                var worstValley = significantValleys.reduce(function(worst, v) {
                    return v.depth > worst.depth ? v : worst;
                }, significantValleys[0]);
                
                var totalDifficultDays = significantValleys.reduce(function(sum, v) {
                    if (!v.minDate || !v.peakDate || v.minDate === 'start' || v.peakDate === 'start') return sum + 1;
                    var days = Math.round((new Date(v.minDate) - new Date(v.peakDate)) / (1000 * 60 * 60 * 24));
                    return sum + Math.max(1, days);
                }, 0);
                
                html += '<div style="background:linear-gradient(135deg,rgba(234,179,8,.1),rgba(234,179,8,.05));border:1px solid var(--yellow);border-radius:8px;padding:1rem;margin-top:.5rem">';
                html += '<div style="font-weight:600;color:var(--yellow);margin-bottom:.5rem">üí° Bilan' + (filterYear !== 'all' ? ' ' + filterYear : '') + '</div>';
                html += '<div style="font-size:.85rem">';
                html += '<b>' + significantValleys.length + '</b> p√©riode(s) difficile(s), <b>~' + totalDifficultDays + 'j</b> de gal√®re. ';
                html += 'Pire : <b>-' + worstValley.depth.toFixed(0) + '%</b>.<br>';
                
                if (worstValley.depth > 25) {
                    html += '‚ö†Ô∏è Chutes >25% = discipline mentale obligatoire.';
                } else if (worstValley.depth > 15) {
                    html += 'üò∞ Chutes 15-25% = √©prouvant mais g√©rable.';
                } else {
                    html += 'üëç Chutes <15% = confortable si disciplin√©.';
                }
                html += '</div></div>';
            }
            
            container.innerHTML = html;
        }
        
        // Helper pour formater les dates en fran√ßais
        function formatDateFr(dateStr) {
            if (!dateStr) return '?';
            var months = ['jan', 'f√©v', 'mar', 'avr', 'mai', 'jun', 'jul', 'ao√ª', 'sep', 'oct', 'nov', 'd√©c'];
            var parts = dateStr.split('-');
            if (parts.length >= 3) {
                return parseInt(parts[2]) + ' ' + months[parseInt(parts[1]) - 1] + ' ' + parts[0];
            }
            return dateStr;
        }
        
        // Helper pour cacher tous les r√©sultats avanc√©s
        function hideAllAdvancedResults() {
            ['monteCarloDrawdownResults', 'monteCarloVarianceResults', 'riskOfRuinResults', 'monteCarloResults'].forEach(function(id) {
                var el = document.getElementById(id);
                if (el) el.style.display = 'none';
            });
        }
        
        // ============================================
        // MONTE CARLO DRAWDOWN (ordre al√©atoire)
        // M√™mes paris, ordre diff√©rent ‚Üí m√™me profit, drawdown diff√©rent
        // ============================================
        function runMonteCarloDrawdown() {
            var bets = getSimulationBets();
            if (bets.length < 20) {
                alert('Pas assez de paris (minimum 20).\n\nParis trouv√©s: ' + bets.length);
                return;
            }
            
            var bankroll = parseFloat(document.getElementById('cfgBankroll').value) || 5000;
            var flatStake = parseFloat(document.getElementById('cfgStake').value) || 150;
            var pctStake = parseFloat(document.getElementById('cfgPctStake').value) || 3;
            
            console.log('MC Drawdown:', { bankroll, flatStake, pctStake, bets: bets.length });
            
            var numSims = 10000;
            
            // Fisher-Yates shuffle
            function shuffle(array) {
                var shuffled = array.slice();
                for (var i = shuffled.length - 1; i > 0; i--) {
                    var j = Math.floor(Math.random() * (i + 1));
                    var temp = shuffled[i];
                    shuffled[i] = shuffled[j];
                    shuffled[j] = temp;
                }
                return shuffled;
            }
            
            // Simuler avec un ordre donn√© et une strat√©gie
            function simWithOrder(orderedBets, strategy) {
                var current = bankroll;
                var peak = bankroll;
                var maxDD = 0;
                
                for (var i = 0; i < orderedBets.length; i++) {
                    var bet = orderedBets[i];
                    var stake;
                    
                    // Coefficient de la niche SEULEMENT en mode custom
                    var stakeCoef = 1.0;
                    if (currentStakeMode === 'custom' && bet.nicheObj && bet.nicheObj.stakeCoef) {
                        stakeCoef = bet.nicheObj.stakeCoef;
                    }
                    
                    if (strategy === 'flat') {
                        stake = flatStake * stakeCoef;
                    } else {
                        // Percent
                        stake = current * (pctStake / 100) * stakeCoef;
                    }
                    
                    stake = Math.min(stake, current);
                    if (stake < 1) break;
                    
                    if (bet.won) {
                        current += stake * (bet.odds - 1);
                    } else {
                        current -= stake;
                    }
                    
                    if (current > peak) peak = current;
                    var dd = peak > 0 ? (peak - current) / peak * 100 : 0;
                    if (dd > maxDD) maxDD = dd;
                    
                    if (current < 1) break;
                }
                
                return { maxDD: maxDD, survived: current >= 1, finalBankroll: current };
            }
            
            // Calculer profit r√©el pour chaque strat√©gie
            function calcRealProfit(strategy) {
                var current = bankroll;
                for (var i = 0; i < bets.length; i++) {
                    var bet = bets[i];
                    var stake;
                    
                    // Coefficient de la niche SEULEMENT en mode custom
                    var stakeCoef = 1.0;
                    if (currentStakeMode === 'custom' && bet.nicheObj && bet.nicheObj.stakeCoef) {
                        stakeCoef = bet.nicheObj.stakeCoef;
                    }
                    
                    if (strategy === 'flat') {
                        stake = flatStake * stakeCoef;
                    } else {
                        stake = current * (pctStake / 100) * stakeCoef;
                    }
                    stake = Math.min(stake, current);
                    if (stake < 1) break;
                    current += bet.won ? stake * (bet.odds - 1) : -stake;
                    if (current < 1) break;
                }
                return current - bankroll;
            }
            
            var strategies = [
                { id: 'flat', name: 'Flat ' + flatStake + '‚Ç¨', color: 'var(--blue)' },
                { id: 'pct', name: pctStake + '% BR', color: 'var(--green)' }
            ];
            
            var allResults = {};
            
            // Lancer les simulations pour chaque strat√©gie
            for (var s = 0; s < strategies.length; s++) {
                var strat = strategies[s];
                var results = [];
                var realResult = simWithOrder(bets, strat.id);
                
                for (var sim = 0; sim < numSims; sim++) {
                    results.push(simWithOrder(shuffle(bets), strat.id));
                }
                
                // Analyser
                var drawdowns = results.map(function(r) { return r.maxDD; }).sort(function(a, b) { return a - b; });
                var survivalCount = results.filter(function(r) { return r.survived; }).length;
                
                // Percentile du drawdown r√©el
                var realDDRank = 0;
                for (var i = 0; i < drawdowns.length; i++) {
                    if (drawdowns[i] <= realResult.maxDD) realDDRank = i;
                }
                
                allResults[strat.id] = {
                    realDD: realResult.maxDD,
                    realProfit: calcRealProfit(strat.id),
                    medianDD: drawdowns[Math.floor(drawdowns.length / 2)],
                    p5DD: drawdowns[Math.floor(drawdowns.length * 0.05)],
                    p95DD: drawdowns[Math.floor(drawdowns.length * 0.95)],
                    minDD: drawdowns[0],
                    maxDD: drawdowns[drawdowns.length - 1],
                    survivalRate: survivalCount / numSims * 100,
                    percentile: realDDRank / numSims * 100
                };
            }
            
            // Affichage
            hideAllAdvancedResults();
            safeDisplay('monteCarloDrawdownResults', true);
            
            var html = '';
            
            // Info
            html += '<div style="background:rgba(139,92,246,.1);border:1px solid var(--purple);border-radius:8px;padding:1rem;margin-bottom:1.5rem">';
            html += '<div style="font-size:.85rem">';
            html += 'üìä <b>' + numSims.toLocaleString() + ' simulations</b> √ó 3 strat√©gies avec tes <b>' + bets.length + ' vrais paris</b> dans des ordres al√©atoires.<br>';
            html += 'üí° Le profit final est identique pour chaque strat√©gie (m√™mes paris), seul le <b>drawdown</b> varie selon l\'ordre.';
            html += '</div></div>';
            
            // Comparaison des 3 strat√©gies
            html += '<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:1rem;margin-bottom:1.5rem">';
            
            for (var s = 0; s < strategies.length; s++) {
                var strat = strategies[s];
                var r = allResults[strat.id];
                
                html += '<div style="background:var(--bg);border-radius:8px;padding:1rem;border-top:3px solid ' + strat.color + '">';
                html += '<div style="font-weight:600;color:' + strat.color + ';margin-bottom:.75rem;text-align:center">' + strat.name + '</div>';
                
                html += '<div style="display:grid;grid-template-columns:1fr 1fr;gap:.5rem;font-size:.8rem">';
                
                // Calculer le DD en euros
                var realDDEuros = r.realDD / 100 * bankroll;
                var medianDDEuros = r.medianDD / 100 * bankroll;
                var p95DDEuros = r.p95DD / 100 * bankroll;
                
                html += '<div style="text-align:center;padding:.5rem;background:var(--card);border-radius:4px">';
                html += '<div style="font-size:1.2rem;font-weight:700;color:' + (r.realProfit >= 0 ? 'var(--green)' : 'var(--red)') + '">' + formatMoney(r.realProfit) + '</div>';
                html += '<div style="font-size:.65rem;color:var(--muted)">Profit</div>';
                html += '</div>';
                
                html += '<div style="text-align:center;padding:.5rem;background:var(--card);border-radius:4px">';
                html += '<div style="font-size:1.2rem;font-weight:700;color:var(--red)">-' + formatMoney(realDDEuros) + '</div>';
                html += '<div style="font-size:.65rem;color:var(--muted)">Ton DD r√©el</div>';
                html += '</div>';
                
                html += '<div style="text-align:center;padding:.5rem;background:var(--card);border-radius:4px">';
                html += '<div style="font-size:1.2rem;font-weight:700">-' + formatMoney(medianDDEuros) + '</div>';
                html += '<div style="font-size:.65rem;color:var(--muted)">DD m√©dian</div>';
                html += '</div>';
                
                html += '<div style="text-align:center;padding:.5rem;background:var(--card);border-radius:4px">';
                html += '<div style="font-size:1.2rem;font-weight:700;color:var(--red)">-' + formatMoney(p95DDEuros) + '</div>';
                html += '<div style="font-size:.65rem;color:var(--muted)">Pire 5%</div>';
                html += '</div>';
                
                html += '</div>';
                
                // Interpr√©tation
                var luckText, luckColor;
                if (r.percentile <= 25) {
                    luckText = 'üçÄ Chanceux';
                    luckColor = 'var(--green)';
                } else if (r.percentile <= 50) {
                    luckText = '‚úÖ Normal';
                    luckColor = 'var(--blue)';
                } else if (r.percentile <= 75) {
                    luckText = 'üòê Malchance';
                    luckColor = 'var(--yellow)';
                } else {
                    luckText = 'üíÄ Tr√®s malchanceux';
                    luckColor = 'var(--red)';
                }
                
                html += '<div style="margin-top:.75rem;text-align:center;padding:.5rem;background:var(--card);border-radius:4px">';
                html += '<span style="color:' + luckColor + ';font-weight:600">' + luckText + '</span>';
                html += '<span style="color:var(--muted);font-size:.75rem"> (P' + r.percentile.toFixed(0) + ')</span>';
                html += '</div>';
                
                if (r.survivalRate < 100) {
                    html += '<div style="margin-top:.5rem;text-align:center;font-size:.75rem;color:var(--red)">‚ö†Ô∏è Survie: ' + r.survivalRate.toFixed(1) + '%</div>';
                }
                
                html += '</div>';
            }
            
            html += '</div>';
            
            // Tableau d√©taill√©
            html += '<details style="margin-top:1rem"><summary style="cursor:pointer;font-size:.85rem;font-weight:600">üìä Distribution d√©taill√©e</summary>';
            html += '<table style="width:100%;border-collapse:collapse;font-size:.75rem;margin-top:.5rem">';
            html += '<thead><tr style="border-bottom:2px solid var(--border)">';
            html += '<th style="text-align:left;padding:.4rem">Strat√©gie</th>';
            html += '<th style="text-align:right;padding:.4rem">Min DD</th>';
            html += '<th style="text-align:right;padding:.4rem">P5</th>';
            html += '<th style="text-align:right;padding:.4rem">M√©diane</th>';
            html += '<th style="text-align:right;padding:.4rem">P95</th>';
            html += '<th style="text-align:right;padding:.4rem">Max DD</th>';
            html += '</tr></thead><tbody>';
            
            for (var s = 0; s < strategies.length; s++) {
                var strat = strategies[s];
                var r = allResults[strat.id];
                html += '<tr style="border-bottom:1px solid var(--border)">';
                html += '<td style="padding:.4rem;color:' + strat.color + '">' + strat.name + '</td>';
                html += '<td style="padding:.4rem;text-align:right;color:var(--green)">-' + formatMoney(r.minDD / 100 * bankroll) + '</td>';
                html += '<td style="padding:.4rem;text-align:right">-' + formatMoney(r.p5DD / 100 * bankroll) + '</td>';
                html += '<td style="padding:.4rem;text-align:right">-' + formatMoney(r.medianDD / 100 * bankroll) + '</td>';
                html += '<td style="padding:.4rem;text-align:right">-' + formatMoney(r.p95DD / 100 * bankroll) + '</td>';
                html += '<td style="padding:.4rem;text-align:right;color:var(--red)">-' + formatMoney(r.maxDD / 100 * bankroll) + '</td>';
                html += '</tr>';
            }
            
            html += '</tbody></table></details>';
            
            safeHTML('mcDrawdownContent', html);
            console.log('MC Drawdown complete');
        }
        
        // ============================================
        // MONTE CARLO VARIANCE (r√©sultats al√©atoires)
        // Paris fictifs bas√©s sur winrate/cote ‚Üí profit variable
        // ============================================
        function runMonteCarloVariance() {
            var bets = getSimulationBets();
            if (bets.length < 20) {
                alert('Pas assez de paris (minimum 20).\n\nParis trouv√©s: ' + bets.length);
                return;
            }
            
            var bankroll = parseFloat(document.getElementById('cfgBankroll').value) || 5000;
            var flatStake = parseFloat(document.getElementById('cfgStake').value) || 150;
            
            // Stats r√©elles
            var wins = bets.filter(function(b) { return b.won; }).length;
            var realWinrate = wins / bets.length;
            var avgOdds = bets.reduce(function(a, b) { return a + b.odds; }, 0) / bets.length;
            var realProfit = 0;
            for (var i = 0; i < bets.length; i++) {
                realProfit += bets[i].won ? flatStake * (bets[i].odds - 1) : -flatStake;
            }
            
            console.log('MC Variance:', { bankroll, flatStake, realWinrate, avgOdds, bets: bets.length });
            
            var numSims = 10000;
            var results = [];
            
            // Simuler avec variance
            function simWithVariance() {
                var current = bankroll;
                var peak = bankroll;
                var maxDD = 0;
                var simWins = 0;
                
                // Calculer le coefficient moyen SEULEMENT en mode custom
                var avgCoef = 1.0;
                if (currentStakeMode === 'custom') {
                    var coefSum = 0;
                    var coefCount = 0;
                    for (var j = 0; j < bets.length; j++) {
                        var c = (bets[j].nicheObj && bets[j].nicheObj.stakeCoef) ? bets[j].nicheObj.stakeCoef : 1.0;
                        coefSum += c;
                        coefCount++;
                    }
                    if (coefCount > 0) avgCoef = coefSum / coefCount;
                }
                
                for (var i = 0; i < bets.length; i++) {
                    var stake = Math.min(flatStake * avgCoef, current);
                    if (stake < 1) break;
                    
                    var won = Math.random() < realWinrate;
                    if (won) {
                        simWins++;
                        current += stake * (avgOdds - 1);
                    } else {
                        current -= stake;
                    }
                    
                    if (current > peak) peak = current;
                    var dd = peak > 0 ? (peak - current) / peak * 100 : 0;
                    if (dd > maxDD) maxDD = dd;
                    
                    if (current < 1) break;
                }
                
                return {
                    profit: current - bankroll,
                    maxDD: maxDD,
                    survived: current >= 1,
                    winrate: simWins / bets.length * 100
                };
            }
            
            // Lancer les simulations
            for (var s = 0; s < numSims; s++) {
                results.push(simWithVariance());
            }
            
            // Analyser
            results.sort(function(a, b) { return a.profit - b.profit; });
            
            var profits = results.map(function(r) { return r.profit; });
            var survivalCount = results.filter(function(r) { return r.survived; }).length;
            var survivalRate = survivalCount / numSims * 100;
            var profitableCount = results.filter(function(r) { return r.profit > 0; }).length;
            var profitProbability = profitableCount / numSims * 100;
            
            var avgProfit = profits.reduce(function(a, b) { return a + b; }, 0) / profits.length;
            var median = results[Math.floor(results.length / 2)];
            var p5 = results[Math.floor(results.length * 0.05)];
            var p25 = results[Math.floor(results.length * 0.25)];
            var p75 = results[Math.floor(results.length * 0.75)];
            var p95 = results[Math.floor(results.length * 0.95)];
            
            // Percentile du r√©sultat r√©el
            var realRank = 0;
            for (var i = 0; i < results.length; i++) {
                if (results[i].profit <= realProfit) realRank = i;
            }
            var realPercentile = (realRank / numSims * 100);
            
            // Affichage
            hideAllAdvancedResults();
            safeDisplay('monteCarloVarianceResults', true);
            
            var html = '';
            
            // Info
            html += '<div style="background:rgba(236,72,153,.1);border:1px solid var(--pink);border-radius:8px;padding:1rem;margin-bottom:1.5rem">';
            html += '<div style="font-size:.85rem">';
            html += 'üé∞ <b>' + numSims.toLocaleString() + ' sc√©narios fictifs</b> bas√©s sur ton winrate de <b>' + (realWinrate * 100).toFixed(1) + '%</b> et cote moyenne de <b>' + avgOdds.toFixed(2) + '</b>.<br>';
            html += '‚ö†Ô∏è Ce sont des paris <b>imaginaires</b>, pas tes vrais r√©sultats.';
            html += '</div></div>';
            
            // Stats principales
            html += '<div style="display:grid;grid-template-columns:repeat(4,1fr);gap:1rem;margin-bottom:1.5rem">';
            
            html += '<div style="text-align:center;padding:1rem;background:var(--bg);border-radius:8px">';
            html += '<div style="font-size:1.8rem;font-weight:700;color:' + (profitProbability >= 60 ? 'var(--green)' : 'var(--red)') + '">' + profitProbability.toFixed(0) + '%</div>';
            html += '<div style="font-size:.75rem;color:var(--muted)">Chance de profit</div>';
            html += '</div>';
            
            html += '<div style="text-align:center;padding:1rem;background:var(--bg);border-radius:8px">';
            html += '<div style="font-size:1.8rem;font-weight:700;color:' + (avgProfit >= 0 ? 'var(--green)' : 'var(--red)') + '">' + formatMoney(avgProfit) + '</div>';
            html += '<div style="font-size:.75rem;color:var(--muted)">Profit moyen</div>';
            html += '</div>';
            
            html += '<div style="text-align:center;padding:1rem;background:var(--bg);border-radius:8px">';
            html += '<div style="font-size:1.8rem;font-weight:700;color:' + (survivalRate >= 95 ? 'var(--green)' : 'var(--red)') + '">' + survivalRate.toFixed(1) + '%</div>';
            html += '<div style="font-size:.75rem;color:var(--muted)">Taux de survie</div>';
            html += '</div>';
            
            html += '<div style="text-align:center;padding:1rem;background:var(--bg);border-radius:8px;border:2px solid var(--blue)">';
            html += '<div style="font-size:1.8rem;font-weight:700;color:' + (realProfit >= 0 ? 'var(--green)' : 'var(--red)') + '">' + formatMoney(realProfit) + '</div>';
            html += '<div style="font-size:.75rem;color:var(--muted)">TON profit r√©el</div>';
            html += '</div>';
            
            html += '</div>';
            
            // Interpr√©tation
            var luckText, luckColor;
            if (realPercentile >= 75) {
                luckText = 'üçÄ Chanceux ! Ton r√©sultat est meilleur que ' + realPercentile.toFixed(0) + '% des sc√©narios possibles.';
                luckColor = 'var(--green)';
            } else if (realPercentile >= 50) {
                luckText = '‚úÖ Normal. Ton r√©sultat est dans la moyenne attendue.';
                luckColor = 'var(--blue)';
            } else if (realPercentile >= 25) {
                luckText = 'üòê L√©g√®rement malchanceux. Tu aurais pu faire mieux.';
                luckColor = 'var(--yellow)';
            } else {
                luckText = 'üíÄ Malchanceux ! Tu as eu un des pires r√©sultats possibles.';
                luckColor = 'var(--red)';
            }
            
            html += '<div style="background:var(--bg);border-radius:8px;padding:1rem;margin-bottom:1rem">';
            html += '<div style="font-weight:600;color:' + luckColor + '">' + luckText + '</div>';
            html += '</div>';
            
            // Distribution
            html += '<div style="font-size:.85rem;font-weight:600;margin-bottom:.5rem">Distribution des profits</div>';
            html += '<table style="width:100%;border-collapse:collapse;font-size:.8rem">';
            html += '<tr style="border-bottom:1px solid var(--border)"><td style="padding:.4rem">üî¥ Pire 5%</td><td style="text-align:right;color:var(--red)">' + formatMoney(p5.profit) + '</td><td style="text-align:right;color:var(--muted)">' + p5.winrate.toFixed(0) + '% WR</td></tr>';
            html += '<tr style="border-bottom:1px solid var(--border)"><td style="padding:.4rem">üü† 25e percentile</td><td style="text-align:right">' + formatMoney(p25.profit) + '</td><td style="text-align:right;color:var(--muted)">' + p25.winrate.toFixed(0) + '% WR</td></tr>';
            html += '<tr style="border-bottom:1px solid var(--border)"><td style="padding:.4rem">üü° M√©diane</td><td style="text-align:right">' + formatMoney(median.profit) + '</td><td style="text-align:right;color:var(--muted)">' + median.winrate.toFixed(0) + '% WR</td></tr>';
            html += '<tr style="border-bottom:1px solid var(--border)"><td style="padding:.4rem">üü¢ 75e percentile</td><td style="text-align:right">' + formatMoney(p75.profit) + '</td><td style="text-align:right;color:var(--muted)">' + p75.winrate.toFixed(0) + '% WR</td></tr>';
            html += '<tr><td style="padding:.4rem">üèÜ Meilleur 5%</td><td style="text-align:right;color:var(--green)">' + formatMoney(p95.profit) + '</td><td style="text-align:right;color:var(--muted)">' + p95.winrate.toFixed(0) + '% WR</td></tr>';
            html += '</table>';
            
            safeHTML('mcVarianceContent', html);
            console.log('MC Variance complete');
        }
        
        // ============================================
        // RISK OF RUIN (formule math√©matique)
        // Probabilit√© exacte de perdre toute la bankroll
        // ============================================
        function showRiskOfRuin() {
            var bets = getSimulationBets();
            if (bets.length < 10) {
                alert('Pas assez de paris (minimum 10).\n\nParis trouv√©s: ' + bets.length);
                return;
            }
            
            var bankroll = parseFloat(document.getElementById('cfgBankroll').value) || 5000;
            var flatStake = parseFloat(document.getElementById('cfgStake').value) || 150;
            var pctStake = parseFloat(document.getElementById('cfgPctStake').value) || 3;
            
            // Stats r√©elles
            var wins = bets.filter(function(b) { return b.won; }).length;
            var winrate = wins / bets.length;
            var avgOdds = bets.reduce(function(a, b) { return a + b.odds; }, 0) / bets.length;
            
            // Edge = EV par unit√© mis√©e
            var edge = winrate * avgOdds - 1;
            
            // Nombre d'unit√©s dans la bankroll
            var units = bankroll / flatStake;
            var unitsPct = 100 / pctStake;
            
            // Formule de Risk of Ruin (pour flat betting)
            // RoR = ((1-p)/p)^n o√π p = prob de gagner une unit√©, n = nombre d'unit√©s
            // Version simplifi√©e pour edge betting:
            // RoR = ((1 - edge) / (1 + edge)) ^ units
            
            var rorFlat, rorPct;
            if (edge <= 0) {
                rorFlat = 1; // 100% de ruine si pas d'edge
                rorPct = 1;
            } else {
                var q = (1 - edge) / (1 + edge);
                rorFlat = Math.pow(q, units);
                rorPct = Math.pow(q, unitsPct);
            }
            
            // Version plus pr√©cise avec Kelly
            // Formule: RoR = (1 - f/f*)^(B/S) o√π f* = Kelly optimal
            var kellyOptimal = edge > 0 ? edge / (avgOdds - 1) : 0;
            var kellyFrac = kellyOptimal / 4; // Quarter Kelly
            var rorKelly = edge > 0 ? Math.pow(1 - kellyFrac / kellyOptimal, units) : 1;
            
            // Affichage
            hideAllAdvancedResults();
            safeDisplay('riskOfRuinResults', true);
            
            var html = '';
            
            // Info sur les donn√©es
            html += '<div style="background:rgba(245,158,11,.1);border:1px solid var(--orange);border-radius:8px;padding:1rem;margin-bottom:1.5rem">';
            html += '<div style="font-size:.85rem">';
            html += 'üìä Bas√© sur <b>' + bets.length + ' paris</b> : Winrate <b>' + (winrate * 100).toFixed(1) + '%</b>, Cote moyenne <b>' + avgOdds.toFixed(2) + '</b><br>';
            html += 'üí∞ Bankroll <b>' + bankroll.toLocaleString() + '‚Ç¨</b> = <b>' + units.toFixed(0) + ' unit√©s</b> de ' + flatStake + '‚Ç¨';
            html += '</div></div>';
            
            // Edge
            var edgeColor = edge > 0.05 ? 'var(--green)' : edge > 0 ? 'var(--yellow)' : 'var(--red)';
            html += '<div style="text-align:center;padding:1.5rem;background:var(--bg);border-radius:8px;margin-bottom:1.5rem">';
            html += '<div style="font-size:.85rem;color:var(--muted);margin-bottom:.5rem">TON EDGE (EV par pari)</div>';
            html += '<div style="font-size:3rem;font-weight:700;color:' + edgeColor + '">' + (edge >= 0 ? '+' : '') + (edge * 100).toFixed(2) + '%</div>';
            html += '<div style="font-size:.85rem;color:var(--muted);margin-top:.5rem">';
            if (edge > 0.05) {
                html += '‚úÖ Excellent ! Edge significatif.';
            } else if (edge > 0) {
                html += '‚ö†Ô∏è Edge faible. Attention √† la variance.';
            } else {
                html += 'üö® Pas d\'edge ! Tu vas perdre √† long terme.';
            }
            html += '</div></div>';
            
            // Risk of Ruin par strat√©gie
            html += '<div style="font-size:.85rem;font-weight:600;margin-bottom:.75rem">üíÄ Probabilit√© de Ruine par Strat√©gie</div>';
            html += '<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:1rem;margin-bottom:1.5rem">';
            
            // Flat
            var rorFlatPct = rorFlat * 100;
            var rorFlatColor = rorFlatPct < 1 ? 'var(--green)' : rorFlatPct < 5 ? 'var(--yellow)' : 'var(--red)';
            html += '<div style="text-align:center;padding:1rem;background:var(--bg);border-radius:8px;border-top:3px solid var(--blue)">';
            html += '<div style="font-size:.75rem;color:var(--blue);margin-bottom:.5rem">üíµ FLAT ' + flatStake + '‚Ç¨</div>';
            html += '<div style="font-size:2rem;font-weight:700;color:' + rorFlatColor + '">' + (rorFlatPct < 0.01 ? '<0.01' : rorFlatPct.toFixed(2)) + '%</div>';
            html += '<div style="font-size:.7rem;color:var(--muted)">' + units.toFixed(0) + ' unit√©s</div>';
            html += '</div>';
            
            // % Bankroll
            var rorPctPct = rorPct * 100;
            var rorPctColor = rorPctPct < 1 ? 'var(--green)' : rorPctPct < 5 ? 'var(--yellow)' : 'var(--red)';
            html += '<div style="text-align:center;padding:1rem;background:var(--bg);border-radius:8px;border-top:3px solid var(--green)">';
            html += '<div style="font-size:.75rem;color:var(--green);margin-bottom:.5rem">üìä ' + pctStake + '% BR</div>';
            html += '<div style="font-size:2rem;font-weight:700;color:' + rorPctColor + '">' + (rorPctPct < 0.01 ? '<0.01' : rorPctPct.toFixed(2)) + '%</div>';
            html += '<div style="font-size:.7rem;color:var(--muted)">' + unitsPct.toFixed(0) + ' unit√©s equiv.</div>';
            html += '</div>';
            
            // Kelly
            var rorKellyPct = rorKelly * 100;
            var rorKellyColor = rorKellyPct < 1 ? 'var(--green)' : rorKellyPct < 5 ? 'var(--yellow)' : 'var(--red)';
            html += '<div style="text-align:center;padding:1rem;background:var(--bg);border-radius:8px;border-top:3px solid var(--purple)">';
            html += '<div style="font-size:.75rem;color:var(--purple);margin-bottom:.5rem">üßÆ KELLY √∑4</div>';
            html += '<div style="font-size:2rem;font-weight:700;color:' + rorKellyColor + '">' + (rorKellyPct < 0.01 ? '<0.01' : rorKellyPct.toFixed(2)) + '%</div>';
            html += '<div style="font-size:.7rem;color:var(--muted)">Kelly optimal: ' + (kellyOptimal * 100).toFixed(1) + '%</div>';
            html += '</div>';
            
            html += '</div>';
            
            // Recommandations
            html += '<div style="background:var(--bg);border-radius:8px;padding:1rem">';
            html += '<div style="font-weight:600;margin-bottom:.5rem">üìã Recommandations</div>';
            html += '<ul style="margin:0;padding-left:1.2rem;font-size:.85rem;color:var(--muted)">';
            
            if (edge <= 0) {
                html += '<li style="color:var(--red)">üö® <b>STOP</b> ‚Äî Tu n\'as pas d\'edge. Ne mise pas.</li>';
            } else {
                if (rorFlatPct > 5) {
                    html += '<li>R√©duis ta mise flat ou augmente ta bankroll</li>';
                }
                if (rorFlatPct < 0.1 && edge > 0.03) {
                    html += '<li style="color:var(--green)">‚úÖ Risk of Ruin tr√®s faible, tu peux augmenter l√©g√®rement tes mises</li>';
                }
                html += '<li>Kelly optimal sugg√®re une mise de <b>' + (kellyOptimal * bankroll).toFixed(0) + '‚Ç¨</b> (full Kelly, risqu√©)</li>';
                html += '<li>Quarter Kelly (√∑4) sugg√®re <b>' + (kellyOptimal * bankroll / 4).toFixed(0) + '‚Ç¨</b> (recommand√©)</li>';
            }
            
            html += '</ul></div>';
            
            safeHTML('rorContent', html);
            console.log('Risk of Ruin complete');
        }
        
        // Garder l'ancienne fonction pour compatibilit√© (redirige vers MC Variance)
        function runMonteCarloSim() {
            runMonteCarloVariance();
        }
        
        function runStressTest() {
            var bets = getSimulationBets();
            if (bets.length < 10) {
                alert('Pas assez de donn√©es pour le stress test.');
                return;
            }
            
            var bankroll = parseFloat(document.getElementById('cfgBankroll').value) || 5000;
            var flatStake = parseFloat(document.getElementById('cfgStake').value) || 250;
            
            safeDisplay('simResults', false);
            safeDisplay('stressResults', true);
            safeDisplay('multiBankrollResults', false);
            safeDisplay('whatIfResults', false);
            
            // Trouver la plus longue s√©rie perdante dans l'historique
            var maxLosingStreak = 0;
            var currentStreak = 0;
            for (var i = 0; i < bets.length; i++) {
                if (!bets[i].won) {
                    currentStreak++;
                    if (currentStreak > maxLosingStreak) maxLosingStreak = currentStreak;
                } else {
                    currentStreak = 0;
                }
            }
            
            // Simuler diff√©rents sc√©narios catastrophes
            var scenarios = [
                { name: 'S√©rie perdante historique (' + maxLosingStreak + ' pertes)', losses: maxLosingStreak },
                { name: '10 pertes cons√©cutives', losses: 10 },
                { name: '15 pertes cons√©cutives', losses: 15 },
                { name: '20 pertes cons√©cutives', losses: 20 }
            ];
            
            var html = '<div style="display:grid;gap:1rem">';
            
            for (var i = 0; i < scenarios.length; i++) {
                var scenario = scenarios[i];
                
                // Impact flat
                var flatLoss = scenario.losses * flatStake;
                var flatRemaining = bankroll - flatLoss;
                var flatSurvived = flatRemaining > 0;
                
                // Impact % bankroll (diminution progressive)
                var pctStake = parseFloat(document.getElementById('cfgPctStake').value) || 5;
                var pctRemaining = bankroll;
                for (var j = 0; j < scenario.losses; j++) {
                    pctRemaining -= pctRemaining * pctStake / 100;
                }
                
                var statusColor = flatSurvived ? 'var(--green)' : 'var(--red)';
                var statusIcon = flatSurvived ? '‚úÖ' : 'üíÄ';
                
                html += '<div style="background:var(--bg);border:1px solid var(--border);border-radius:8px;padding:1rem">' +
                    '<div style="font-weight:600;margin-bottom:.5rem">' + statusIcon + ' ' + scenario.name + '</div>' +
                    '<div style="display:grid;grid-template-columns:1fr 1fr;gap:1rem;font-size:.85rem">' +
                    '<div>' +
                    '<div style="color:var(--muted)">Flat (' + flatStake + '‚Ç¨)</div>' +
                    '<div style="font-size:1.2rem;font-weight:700;color:' + (flatSurvived ? 'var(--yellow)' : 'var(--red)') + '">' + flatRemaining.toFixed(0) + '‚Ç¨</div>' +
                    '<div style="font-size:.75rem;color:var(--red)">-' + flatLoss.toFixed(0) + '‚Ç¨ (-' + (flatLoss/bankroll*100).toFixed(0) + '%)</div>' +
                    '</div>' +
                    '<div>' +
                    '<div style="color:var(--muted)">% Bankroll (' + pctStake + '%)</div>' +
                    '<div style="font-size:1.2rem;font-weight:700;color:var(--green)">' + pctRemaining.toFixed(0) + '‚Ç¨</div>' +
                    '<div style="font-size:.75rem;color:var(--red)">-' + (bankroll - pctRemaining).toFixed(0) + '‚Ç¨ (-' + ((bankroll - pctRemaining)/bankroll*100).toFixed(0) + '%)</div>' +
                    '</div>' +
                    '</div>' +
                    '</div>';
            }
            
            // Recommandation
            var safeStake = bankroll / 20; // R√®gle des 20x
            html += '<div style="background:rgba(34,197,94,.1);border:1px solid var(--green);border-radius:8px;padding:1rem;margin-top:.5rem">' +
                '<div style="font-weight:600;color:var(--green);margin-bottom:.5rem">üí° Recommandation</div>' +
                '<div style="font-size:.9rem">Pour survivre √† 20 pertes cons√©cutives avec une mise flat, ta mise devrait √™tre de <b>' + safeStake.toFixed(0) + '‚Ç¨</b> maximum (bankroll √∑ 20).</div>' +
                '<div style="font-size:.85rem;color:var(--muted);margin-top:.5rem">Ou utilise une strat√©gie % Bankroll pour une meilleure r√©silience.</div>' +
                '</div>';
            
            html += '</div>';
            safeHTML('stressContent', html);
        }
        

        // ==================== MULTI-BANKROLL SIMULATION ====================
        function runMultiBankrollSim() {
            var bets = getSimulationBets();
            if (bets.length < 20) {
                alert('Pas assez de donn√©es pour la simulation Multi-Bankroll (minimum 20 paris).');
                return;
            }
            
            var baseBankroll = parseFloat(document.getElementById('cfgBankroll').value) || 5000;
            var baseStake = parseFloat(document.getElementById('cfgStake').value) || 250;
            var numSims = 2000; // 2000 simulations par bankroll
            
            // Tester plusieurs bankrolls (50% √† 300% de la bankroll de base)
            var bankrollMultipliers = [0.5, 0.75, 1, 1.25, 1.5, 2, 2.5, 3];
            var bankrolls = bankrollMultipliers.map(function(m) { return Math.round(baseBankroll * m); });
            
            // Masquer les autres r√©sultats
            safeDisplay('simResults', false);
            safeDisplay('stressResults', false);
            safeDisplay('optimizerResults', false);
            safeDisplay('whatIfResults', false);
            safeDisplay('multiBankrollResults', true);
            
            // R√©sultats pour chaque bankroll
            var results = [];
            var allTrajectories = {};
            
            for (var b = 0; b < bankrolls.length; b++) {
                var bankroll = bankrolls[b];
                var stake = baseStake; // Mise fixe
                
                var finalBankrolls = [];
                var maxDrawdowns = [];
                var bankruptcies = 0;
                var trajectories = [];
                
                for (var sim = 0; sim < numSims; sim++) {
                    var simBankroll = bankroll;
                    var peak = bankroll;
                    var maxDD = 0;
                    var trajectory = sim < 3 ? [bankroll] : null; // Garder 3 trajectoires par bankroll
                    
                    var shuffled = bets.slice().sort(function() { return Math.random() - 0.5; });
                    
                    for (var i = 0; i < shuffled.length; i++) {
                        var bet = shuffled[i];
                        var actualStake = Math.min(stake, simBankroll);
                        if (actualStake <= 0) break;
                        
                        var pnl = bet.won ? actualStake * (bet.odds - 1) : -actualStake;
                        simBankroll += pnl;
                        
                        if (simBankroll > peak) peak = simBankroll;
                        var dd = peak > 0 ? (peak - simBankroll) / peak * 100 : 0;
                        if (dd > maxDD) maxDD = dd;
                        
                        if (trajectory) trajectory.push(simBankroll);
                        
                        if (simBankroll <= 0) {
                            bankruptcies++;
                            break;
                        }
                    }
                    
                    finalBankrolls.push(simBankroll);
                    maxDrawdowns.push(maxDD);
                    if (trajectory) trajectories.push(trajectory);
                }
                
                // Calculer stats
                finalBankrolls.sort(function(a, b) { return a - b; });
                maxDrawdowns.sort(function(a, b) { return a - b; });
                
                var p5 = finalBankrolls[Math.floor(numSims * 0.05)];
                var p25 = finalBankrolls[Math.floor(numSims * 0.25)];
                var p50 = finalBankrolls[Math.floor(numSims * 0.50)];
                var p75 = finalBankrolls[Math.floor(numSims * 0.75)];
                var p95 = finalBankrolls[Math.floor(numSims * 0.95)];
                var avgDD = maxDrawdowns.reduce(function(a, b) { return a + b; }, 0) / numSims;
                
                results.push({
                    bankroll: bankroll,
                    multiplier: bankrollMultipliers[b],
                    stake: stake,
                    ruinRate: (bankruptcies / numSims * 100),
                    p5: p5,
                    p25: p25,
                    p50: p50,
                    p75: p75,
                    p95: p95,
                    roi: ((p50 - bankroll) / bankroll * 100),
                    avgDD: avgDD,
                    profitProb: (finalBankrolls.filter(function(f) { return f > bankroll; }).length / numSims * 100)
                });
                
                allTrajectories[bankroll] = trajectories;
            }
            
            // ===== RENDER COMPARISON TABLE =====
            var tableHtml = '<div style="overflow-x:auto"><table style="width:100%;border-collapse:collapse;font-size:.8rem">';
            tableHtml += '<thead><tr style="background:var(--bg)">' +
                '<th style="padding:.6rem;text-align:left;border-bottom:2px solid var(--border)">Bankroll</th>' +
                '<th style="padding:.6rem;text-align:center;border-bottom:2px solid var(--border)">Mise</th>' +
                '<th style="padding:.6rem;text-align:center;border-bottom:2px solid var(--border)">Ratio</th>' +
                '<th style="padding:.6rem;text-align:center;border-bottom:2px solid var(--border)">üíÄ Ruine</th>' +
                '<th style="padding:.6rem;text-align:center;border-bottom:2px solid var(--border)">üìâ DD moy</th>' +
                '<th style="padding:.6rem;text-align:center;border-bottom:2px solid var(--border)">üí∞ P(profit)</th>' +
                '<th style="padding:.6rem;text-align:center;border-bottom:2px solid var(--border)">M√©diane</th>' +
                '<th style="padding:.6rem;text-align:center;border-bottom:2px solid var(--border)">ROI m√©d.</th>' +
                '</tr></thead><tbody>';
            
            for (var i = 0; i < results.length; i++) {
                var r = results[i];
                var isBase = r.multiplier === 1;
                var isSafe = r.ruinRate < 1;
                var isRisky = r.ruinRate > 10;
                
                var rowBg = isBase ? 'rgba(77,159,255,.15)' : (isSafe ? 'rgba(34,197,94,.05)' : (isRisky ? 'rgba(239,68,68,.05)' : ''));
                var rowBorder = isBase ? 'border-left:3px solid var(--blue)' : '';
                
                tableHtml += '<tr style="background:' + rowBg + ';' + rowBorder + '">' +
                    '<td style="padding:.6rem;border-bottom:1px solid var(--border);font-weight:' + (isBase ? '700' : '400') + '">' + r.bankroll + '‚Ç¨' + (isBase ? ' ‚¨ÖÔ∏è' : '') + '</td>' +
                    '<td style="padding:.6rem;text-align:center;border-bottom:1px solid var(--border)">' + r.stake + '‚Ç¨</td>' +
                    '<td style="padding:.6rem;text-align:center;border-bottom:1px solid var(--border);color:var(--muted)">' + (r.bankroll / r.stake).toFixed(1) + 'x</td>' +
                    '<td style="padding:.6rem;text-align:center;border-bottom:1px solid var(--border);color:' + (r.ruinRate < 1 ? 'var(--green)' : r.ruinRate < 5 ? 'var(--yellow)' : 'var(--red)') + ';font-weight:600">' + r.ruinRate.toFixed(1) + '%</td>' +
                    '<td style="padding:.6rem;text-align:center;border-bottom:1px solid var(--border);color:var(--yellow)">-' + r.avgDD.toFixed(1) + '%</td>' +
                    '<td style="padding:.6rem;text-align:center;border-bottom:1px solid var(--border);color:var(--green)">' + r.profitProb.toFixed(0) + '%</td>' +
                    '<td style="padding:.6rem;text-align:center;border-bottom:1px solid var(--border);font-weight:600">' + r.p50.toFixed(0) + '‚Ç¨</td>' +
                    '<td style="padding:.6rem;text-align:center;border-bottom:1px solid var(--border);color:' + (r.roi >= 0 ? 'var(--green)' : 'var(--red)') + '">' + (r.roi >= 0 ? '+' : '') + r.roi.toFixed(1) + '%</td>' +
                    '</tr>';
            }
            
            tableHtml += '</tbody></table></div>';
            tableHtml += '<div style="font-size:.7rem;color:var(--muted);margin-top:.5rem">Ratio = Bankroll / Mise (r√®gle des 20x minimum recommand√©e)</div>';
            safeHTML('mbComparisonTable', tableHtml);
            
            // ===== RENDER RUIN CHART =====
            if (window.mbRuinChart) window.mbRuinChart.destroy();
            
            var ruinData = results.map(function(r) { return r.ruinRate; });
            var ruinColors = ruinData.map(function(v) { 
                return v < 1 ? 'rgba(34,197,94,0.8)' : v < 5 ? 'rgba(234,179,8,0.8)' : 'rgba(239,68,68,0.8)'; 
            });
            
            var ctxRuin = document.getElementById('mbRuinChart').getContext('2d');
            window.mbRuinChart = new Chart(ctxRuin, {
                type: 'bar',
                data: {
                    labels: bankrolls.map(function(b) { return b + '‚Ç¨'; }),
                    datasets: [{
                        label: 'Risque de ruine (%)',
                        data: ruinData,
                        backgroundColor: ruinColors,
                        borderWidth: 0
                    }]
                },
                options: {
                    responsive: true,
                    plugins: { 
                        legend: { display: false },
                        annotation: {
                            annotations: {
                                line1: {
                                    type: 'line',
                                    yMin: 1,
                                    yMax: 1,
                                    borderColor: 'rgba(34,197,94,0.5)',
                                    borderWidth: 2,
                                    borderDash: [5, 5],
                                    label: { display: true, content: '1% acceptable', position: 'end' }
                                },
                                line2: {
                                    type: 'line',
                                    yMin: 5,
                                    yMax: 5,
                                    borderColor: 'rgba(234,179,8,0.5)',
                                    borderWidth: 2,
                                    borderDash: [5, 5]
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: { display: true, text: 'Risque de ruine (%)', color: 'var(--muted)' },
                            grid: { color: 'rgba(255,255,255,0.05)' },
                            ticks: { color: 'var(--muted)' }
                        },
                        x: {
                            grid: { display: false },
                            ticks: { color: 'var(--muted)' }
                        }
                    }
                }
            });
            
            // ===== RENDER PROFIT CHART =====
            if (window.mbProfitChart) window.mbProfitChart.destroy();
            
            var ctxProfit = document.getElementById('mbProfitChart').getContext('2d');
            window.mbProfitChart = new Chart(ctxProfit, {
                type: 'bar',
                data: {
                    labels: bankrolls.map(function(b) { return b + '‚Ç¨'; }),
                    datasets: [
                        {
                            label: 'Worst (5%)',
                            data: results.map(function(r) { return r.p5 - r.bankroll; }),
                            backgroundColor: 'rgba(239,68,68,0.6)'
                        },
                        {
                            label: 'M√©diane (50%)',
                            data: results.map(function(r) { return r.p50 - r.bankroll; }),
                            backgroundColor: 'rgba(34,197,94,0.8)'
                        },
                        {
                            label: 'Best (95%)',
                            data: results.map(function(r) { return r.p95 - r.bankroll; }),
                            backgroundColor: 'rgba(168,85,247,0.6)'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    plugins: { 
                        legend: { 
                            display: true,
                            position: 'top',
                            labels: { color: 'var(--muted)', boxWidth: 12 }
                        }
                    },
                    scales: {
                        y: {
                            title: { display: true, text: 'Profit/Perte (‚Ç¨)', color: 'var(--muted)' },
                            grid: { color: 'rgba(255,255,255,0.05)' },
                            ticks: { color: 'var(--muted)' }
                        },
                        x: {
                            grid: { display: false },
                            ticks: { color: 'var(--muted)' }
                        }
                    }
                }
            });
            
            // ===== RENDER TRAJECTORIES CHART =====
            if (window.mbTrajectoriesChart) window.mbTrajectoriesChart.destroy();
            
            // Calculer la trajectoire m√©diane pour chaque bankroll
            var trajDatasets = [];
            var trajColors = ['#ef4444', '#f97316', '#eab308', '#22c55e', '#14b8a6', '#3b82f6', '#6366f1', '#a855f7'];
            
            // On prend la premi√®re trajectoire de chaque bankroll comme exemple
            for (var i = 0; i < bankrolls.length; i++) {
                var br = bankrolls[i];
                var traj = allTrajectories[br][0] || [];
                if (traj.length > 0) {
                    trajDatasets.push({
                        label: br + '‚Ç¨',
                        data: traj,
                        borderColor: trajColors[i],
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        pointRadius: 0,
                        tension: 0.1
                    });
                }
            }
            
            var maxLen = Math.max.apply(null, trajDatasets.map(function(d) { return d.data.length; }));
            var trajLabels = [];
            for (var i = 0; i < maxLen; i++) trajLabels.push(i);
            
            var ctxTraj = document.getElementById('mbTrajectoriesChart').getContext('2d');
            window.mbTrajectoriesChart = new Chart(ctxTraj, {
                type: 'line',
                data: {
                    labels: trajLabels,
                    datasets: trajDatasets
                },
                options: {
                    responsive: true,
                    plugins: { 
                        legend: { 
                            display: true,
                            position: 'right',
                            labels: { color: 'var(--muted)', boxWidth: 12, font: { size: 10 } }
                        }
                    },
                    scales: {
                        y: {
                            title: { display: true, text: 'Bankroll (‚Ç¨)', color: 'var(--muted)' },
                            grid: { color: 'rgba(255,255,255,0.05)' },
                            ticks: { color: 'var(--muted)' }
                        },
                        x: {
                            title: { display: true, text: 'Pari #', color: 'var(--muted)' },
                            grid: { display: false },
                            ticks: { color: 'var(--muted)' }
                        }
                    }
                }
            });
            
            // ===== RENDER RECOMMENDATION =====
            // Trouver la bankroll optimale (ruine < 1% avec meilleur ROI)
            var safeBankrolls = results.filter(function(r) { return r.ruinRate < 1; });
            var optimal = safeBankrolls.length > 0 ? 
                safeBankrolls.reduce(function(best, r) { return r.roi > best.roi ? r : best; }) : 
                results.reduce(function(best, r) { return r.ruinRate < best.ruinRate ? r : best; });
            
            var minSafe = results.find(function(r) { return r.ruinRate < 1; });
            
            var recHtml = '<div style="background:linear-gradient(135deg,rgba(34,197,94,.1),rgba(77,159,255,.1));padding:1.25rem;border-radius:8px;border:1px solid var(--green)">';
            recHtml += '<div style="font-weight:700;font-size:1.1rem;margin-bottom:.75rem">üéØ Recommandation</div>';
            
            if (minSafe) {
                recHtml += '<div style="display:grid;grid-template-columns:1fr 1fr;gap:1rem">';
                recHtml += '<div style="background:var(--card);padding:1rem;border-radius:6px">' +
                    '<div style="font-size:.75rem;color:var(--muted)">Bankroll minimum s√ªre</div>' +
                    '<div style="font-size:1.5rem;font-weight:700;color:var(--green)">' + minSafe.bankroll + '‚Ç¨</div>' +
                    '<div style="font-size:.7rem;color:var(--muted)">Ratio ' + (minSafe.bankroll / minSafe.stake).toFixed(0) + 'x ‚Ä¢ Ruine ' + minSafe.ruinRate.toFixed(2) + '%</div>' +
                    '</div>';
                recHtml += '<div style="background:var(--card);padding:1rem;border-radius:6px">' +
                    '<div style="font-size:.75rem;color:var(--muted)">Sweet spot (s√ªr + meilleur ROI)</div>' +
                    '<div style="font-size:1.5rem;font-weight:700;color:var(--blue)">' + optimal.bankroll + '‚Ç¨</div>' +
                    '<div style="font-size:.7rem;color:var(--muted)">ROI m√©dian ' + (optimal.roi >= 0 ? '+' : '') + optimal.roi.toFixed(1) + '% ‚Ä¢ DD moy -' + optimal.avgDD.toFixed(0) + '%</div>' +
                    '</div>';
                recHtml += '</div>';
                
                recHtml += '<div style="margin-top:1rem;font-size:.85rem;color:var(--muted)">' +
                    'üí° Avec une mise de <strong>' + baseStake + '‚Ç¨</strong>, tu devrais avoir au minimum <strong>' + minSafe.bankroll + '‚Ç¨</strong> de bankroll pour limiter le risque de ruine sous 1%.' +
                    '</div>';
            } else {
                recHtml += '<div style="color:var(--red);font-weight:600">‚ö†Ô∏è Aucune bankroll test√©e ne donne un risque de ruine acceptable (<1%)</div>';
                recHtml += '<div style="margin-top:.75rem;font-size:.85rem">Suggestions :</div>';
                recHtml += '<ul style="font-size:.85rem;margin-top:.5rem;padding-left:1.25rem">';
                recHtml += '<li>Augmenter ta bankroll au-del√† de ' + bankrolls[bankrolls.length - 1] + '‚Ç¨</li>';
                recHtml += '<li>R√©duire ta mise unitaire en dessous de ' + baseStake + '‚Ç¨</li>';
                recHtml += '</ul>';
            }
            
            recHtml += '</div>';
            safeHTML('mbRecommendation', recHtml);
        }

        // ==================== WHAT IF SIMULATION ====================
        function runWhatIfSim() {
            var bets = getSimulationBets();
            console.log('What If - Nombre de paris:', bets.length);
            
            if (bets.length < 20) {
                alert('Pas assez de donn√©es pour What If (minimum 20 paris).\n\n1. Charge tes fichiers CSV dans l\'onglet Labo\n2. Coche des niches dans le simulateur\n3. R√©essaie');
                return;
            }
            
            var bankroll = parseFloat(document.getElementById('cfgBankroll').value) || 5000;
            var flatStake = parseFloat(document.getElementById('cfgStake').value) || 250;
            
            // Masquer les autres r√©sultats
            safeDisplay('simResults', false);
            safeDisplay('stressResults', false);
            safeDisplay('optimizerResults', false);
            safeDisplay('multiBankrollResults', false);
            safeDisplay('whatIfResults', true);
            
            // Afficher un message de chargement
            safeHTML('wiStats', '<div style="text-align:center;padding:2rem;color:var(--muted)"><div style="font-size:2rem;margin-bottom:.5rem">‚è≥</div><div>Calcul de ' + bets.length + ' paris en cours...</div></div>');
            
            // Utiliser setTimeout pour permettre le rendu du message de chargement
            setTimeout(function() {
                // Trier les paris par date
                var sortedBets = bets.slice().sort(function(a, b) {
                    return new Date(a.date) - new Date(b.date);
                });
                
                console.log('Premier pari:', sortedBets[0]);
                console.log('Dernier pari:', sortedBets[sortedBets.length - 1]);
                
                // Trouver les ann√©es disponibles
                var years = [];
                var yearSet = {};
                for (var i = 0; i < sortedBets.length; i++) {
                    var year = new Date(sortedBets[i].date).getFullYear();
                    if (!isNaN(year) && !yearSet[year]) {
                        yearSet[year] = true;
                        years.push(year);
                    }
                }
                years.sort(function(a, b) { return a - b; });
                
                console.log('Ann√©es trouv√©es:', years);
                
                if (years.length === 0) {
                    safeHTML('wiStats', '<div style="color:var(--red);padding:1rem">Erreur: Impossible de parser les dates des paris.</div>');
                    return;
                }
                
                // Mettre √† jour le slider
                var slider = document.getElementById('wiDateSlider');
                slider.min = years[0];
                slider.max = years[years.length - 1];
                slider.value = years[0]; // Commencer √† la premi√®re ann√©e
                
                // Mettre √† jour les labels du slider
                safeText('wiSelectedDate', years[0]);
                
                // Calculer les r√©sultats pour chaque ann√©e de d√©part
                var resultsByYear = {};
                var drawdownsByYear = {};
            
            for (var y = 0; y < years.length; y++) {
                var startYear = years[y];
                var filteredBets = sortedBets.filter(function(b) {
                    return new Date(b.date).getFullYear() >= startYear;
                });
                
                if (filteredBets.length < 5) continue;
                
                // Simuler
                var simBankroll = bankroll;
                var peak = bankroll;
                var maxDD = 0;
                var trajectory = [bankroll];
                var labels = ['D√©but'];
                var monthlyDrawdowns = [];
                var currentMonth = '';
                var monthPeak = bankroll;
                var monthMinDD = 0;
                
                for (var i = 0; i < filteredBets.length; i++) {
                    var bet = filteredBets[i];
                    // Coefficient SEULEMENT en mode custom
                    var stakeCoef = 1.0;
                    if (currentStakeMode === 'custom' && bet.nicheObj && bet.nicheObj.stakeCoef) {
                        stakeCoef = bet.nicheObj.stakeCoef;
                    }
                    var stake = Math.min(flatStake * stakeCoef, simBankroll);
                    if (stake <= 0) break;
                    
                    var pnl = bet.won ? stake * (bet.odds - 1) : -stake;
                    simBankroll += pnl;
                    
                    if (simBankroll > peak) peak = simBankroll;
                    var dd = peak > 0 ? (peak - simBankroll) / peak * 100 : 0;
                    if (dd > maxDD) maxDD = dd;
                    
                    // Track monthly drawdowns
                    var month = bet.date.substring(0, 7);
                    if (month !== currentMonth) {
                        if (currentMonth && monthMinDD > 0) {
                            monthlyDrawdowns.push({ month: currentMonth, dd: monthMinDD });
                        }
                        currentMonth = month;
                        monthPeak = simBankroll;
                        monthMinDD = 0;
                    }
                    if (simBankroll > monthPeak) monthPeak = simBankroll;
                    var monthDD = monthPeak > 0 ? (monthPeak - simBankroll) / monthPeak * 100 : 0;
                    if (monthDD > monthMinDD) monthMinDD = monthDD;
                    
                    // Trajectory points (sample every ~5% of bets)
                    if (i % Math.max(1, Math.floor(filteredBets.length / 50)) === 0 || i === filteredBets.length - 1) {
                        trajectory.push(simBankroll);
                        labels.push(bet.date.substring(0, 7));
                    }
                }
                
                // Add last month
                if (currentMonth && monthMinDD > 0) {
                    monthlyDrawdowns.push({ month: currentMonth, dd: monthMinDD });
                }
                
                var profit = simBankroll - bankroll;
                var roi = (profit / (filteredBets.length * flatStake)) * 100;
                var wins = filteredBets.filter(function(b) { return b.won; }).length;
                
                resultsByYear[startYear] = {
                    finalBankroll: simBankroll,
                    profit: profit,
                    roi: roi,
                    maxDD: maxDD,
                    bets: filteredBets.length,
                    wins: wins,
                    winrate: (wins / filteredBets.length * 100),
                    trajectory: trajectory,
                    labels: labels,
                    years: years[years.length - 1] - startYear + 1
                };
                drawdownsByYear[startYear] = monthlyDrawdowns;
            }
            
            // Cache les r√©sultats
            wiCachedResults = {
                resultsByYear: resultsByYear,
                drawdownsByYear: drawdownsByYear,
                bankroll: bankroll,
                flatStake: flatStake,
                years: years
            };
            
            console.log('What If - R√©sultats calcul√©s pour', Object.keys(resultsByYear).length, 'ann√©es');
            
            // Afficher le graphique profit par ann√©e
            renderWhatIfProfitChart();
            
            // Afficher pour l'ann√©e s√©lectionn√©e
            updateWhatIfFromSlider();
            }, 50); // Fin du setTimeout
        }
        
        function updateWhatIfFromSlider() {
            if (!wiCachedResults) return;
            
            var selectedYear = parseInt(document.getElementById('wiDateSlider').value);
            safeText('wiSelectedDate', selectedYear);
            safeText('wiTrajectoryLabel', selectedYear);
            
            var result = wiCachedResults.resultsByYear[selectedYear];
            var bankroll = wiCachedResults.bankroll;
            var fullResult = wiCachedResults.resultsByYear[wiCachedResults.years[0]];
            
            if (!result) {
                safeHTML('wiStats', '<div style="color:var(--muted)">Pas assez de donn√©es pour cette ann√©e.</div>');
                return;
            }
            
            // Stats pour l'ann√©e s√©lectionn√©e
            var statsHtml = '<div style="display:grid;grid-template-columns:repeat(4,1fr);gap:.75rem">' +
                '<div style="background:var(--bg);padding:1rem;border-radius:8px;text-align:center">' +
                '<div style="font-size:.7rem;color:var(--muted)">Bankroll Finale</div>' +
                '<div style="font-size:1.4rem;font-weight:700;color:' + (result.profit >= 0 ? 'var(--green)' : 'var(--red)') + '">' + result.finalBankroll.toFixed(0) + '‚Ç¨</div>' +
                '<div style="font-size:.65rem;color:var(--muted)">' + (result.profit >= 0 ? '+' : '') + result.profit.toFixed(0) + '‚Ç¨</div>' +
                '</div>' +
                '<div style="background:var(--bg);padding:1rem;border-radius:8px;text-align:center">' +
                '<div style="font-size:.7rem;color:var(--muted)">ROI</div>' +
                '<div style="font-size:1.4rem;font-weight:700;color:' + (result.roi >= 0 ? 'var(--green)' : 'var(--red)') + '">' + (result.roi >= 0 ? '+' : '') + result.roi.toFixed(1) + '%</div>' +
                '<div style="font-size:.65rem;color:var(--muted)">' + result.bets + ' paris</div>' +
                '</div>' +
                '<div style="background:var(--bg);padding:1rem;border-radius:8px;text-align:center">' +
                '<div style="font-size:.7rem;color:var(--muted)">Max Drawdown</div>' +
                '<div style="font-size:1.4rem;font-weight:700;color:var(--yellow)">-' + result.maxDD.toFixed(1) + '%</div>' +
                '<div style="font-size:.65rem;color:var(--muted)">Pire p√©riode</div>' +
                '</div>' +
                '<div style="background:var(--bg);padding:1rem;border-radius:8px;text-align:center">' +
                '<div style="font-size:.7rem;color:var(--muted)">Dur√©e</div>' +
                '<div style="font-size:1.4rem;font-weight:700;color:var(--blue)">' + result.years + ' ans</div>' +
                '<div style="font-size:.65rem;color:var(--muted)">Winrate ' + result.winrate.toFixed(1) + '%</div>' +
                '</div>' +
                '</div>';
            safeHTML('wiStats', statsHtml);
            
            // Comparaison avec p√©riode compl√®te
            if (fullResult && selectedYear !== wiCachedResults.years[0]) {
                var diffProfit = result.profit - fullResult.profit;
                var diffROI = result.roi - fullResult.roi;
                var diffDD = result.maxDD - fullResult.maxDD;
                
                var compHtml = '<div style="background:linear-gradient(135deg,rgba(236,72,153,.1),rgba(236,72,153,.05));padding:1rem;border-radius:8px;border:1px solid var(--pink)">' +
                    '<div style="font-weight:600;margin-bottom:.75rem">üìä Comparaison avec la p√©riode compl√®te (' + wiCachedResults.years[0] + '-' + wiCachedResults.years[wiCachedResults.years.length-1] + ')</div>' +
                    '<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:1rem;font-size:.85rem">' +
                    '<div><span style="color:var(--muted)">Profit:</span> <span style="font-weight:600;color:' + (diffProfit >= 0 ? 'var(--green)' : 'var(--red)') + '">' + (diffProfit >= 0 ? '+' : '') + diffProfit.toFixed(0) + '‚Ç¨</span></div>' +
                    '<div><span style="color:var(--muted)">ROI:</span> <span style="font-weight:600;color:' + (diffROI >= 0 ? 'var(--green)' : 'var(--red)') + '">' + (diffROI >= 0 ? '+' : '') + diffROI.toFixed(1) + '%</span></div>' +
                    '<div><span style="color:var(--muted)">Max DD:</span> <span style="font-weight:600;color:' + (diffDD <= 0 ? 'var(--green)' : 'var(--red)') + '">' + (diffDD >= 0 ? '+' : '') + diffDD.toFixed(1) + '%</span></div>' +
                    '</div>';
                
                if (result.roi > fullResult.roi) {
                    compHtml += '<div style="margin-top:.75rem;font-size:.8rem;color:var(--green)">‚úÖ Commencer en ' + selectedYear + ' aurait √©t√© plus rentable!</div>';
                } else {
                    compHtml += '<div style="margin-top:.75rem;font-size:.8rem;color:var(--yellow)">‚ö†Ô∏è Tu aurais manqu√© ' + (fullResult.profit - result.profit).toFixed(0) + '‚Ç¨ de profit en commen√ßant plus tard.</div>';
                }
                compHtml += '</div>';
                safeHTML('wiComparison', compHtml);
            } else {
                safeHTML('wiComparison', '');
            }
            
            // Trajectoire pour l'ann√©e s√©lectionn√©e
            renderWhatIfTrajectory(result);
            
            // Calendrier des drawdowns
            renderDrawdownCalendar(selectedYear);
        }
        
        function renderWhatIfProfitChart() {
            if (!wiCachedResults) return;
            
            var years = wiCachedResults.years;
            var profits = [];
            var colors = [];
            var bankroll = wiCachedResults.bankroll;
            
            for (var i = 0; i < years.length; i++) {
                var r = wiCachedResults.resultsByYear[years[i]];
                if (r) {
                    profits.push(r.finalBankroll);
                    colors.push(r.profit >= 0 ? 'rgba(34, 197, 94, 0.7)' : 'rgba(239, 68, 68, 0.7)');
                } else {
                    profits.push(null);
                    colors.push('rgba(128, 128, 128, 0.5)');
                }
            }
            
            if (wiProfitByYearChart) wiProfitByYearChart.destroy();
            
            var ctx = document.getElementById('wiProfitByYearChart').getContext('2d');
            wiProfitByYearChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: years.map(function(y) { return 'Depuis ' + y; }),
                    datasets: [{
                        label: 'Bankroll finale',
                        data: profits,
                        backgroundColor: colors,
                        borderColor: colors.map(function(c) { return c.replace('0.7', '1'); }),
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(item) {
                                    var r = wiCachedResults.resultsByYear[years[item.dataIndex]];
                                    if (r) {
                                        return [
                                            'Bankroll: ' + r.finalBankroll.toFixed(0) + '‚Ç¨',
                                            'Profit: ' + (r.profit >= 0 ? '+' : '') + r.profit.toFixed(0) + '‚Ç¨',
                                            'ROI: ' + (r.roi >= 0 ? '+' : '') + r.roi.toFixed(1) + '%',
                                            'Paris: ' + r.bets
                                        ];
                                    }
                                    return '';
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: false,
                            title: { display: true, text: 'Bankroll finale (‚Ç¨)', color: 'rgba(255,255,255,0.7)' },
                            grid: { color: 'rgba(255,255,255,0.1)' },
                            ticks: { color: 'rgba(255,255,255,0.7)' }
                        },
                        x: {
                            grid: { color: 'rgba(255,255,255,0.1)' },
                            ticks: { color: 'rgba(255,255,255,0.7)' }
                        }
                    },
                    onClick: function(evt, elements) {
                        if (elements.length > 0) {
                            var idx = elements[0].index;
                            document.getElementById('wiDateSlider').value = years[idx];
                            updateWhatIfFromSlider();
                        }
                    }
                }
            });
            
            // Ajouter ligne de r√©f√©rence pour bankroll initiale
            wiProfitByYearChart.options.plugins.annotation = {
                annotations: {
                    line1: {
                        type: 'line',
                        yMin: bankroll,
                        yMax: bankroll,
                        borderColor: 'rgba(255, 255, 255, 0.5)',
                        borderWidth: 2,
                        borderDash: [5, 5]
                    }
                }
            };
        }
        
        function renderWhatIfTrajectory(result) {
            if (!result || !result.trajectory) return;
            
            if (wiTrajectoryChart) wiTrajectoryChart.destroy();
            
            var ctx = document.getElementById('wiTrajectoryChart').getContext('2d');
            wiTrajectoryChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: result.labels,
                    datasets: [{
                        label: 'Bankroll',
                        data: result.trajectory,
                        borderColor: 'rgba(236, 72, 153, 1)',
                        backgroundColor: 'rgba(236, 72, 153, 0.1)',
                        fill: true,
                        tension: 0.3,
                        pointRadius: 0,
                        pointHoverRadius: 4
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: { display: false }
                    },
                    scales: {
                        y: {
                            title: { display: true, text: 'Bankroll (‚Ç¨)', color: 'rgba(255,255,255,0.7)' },
                            grid: { color: 'rgba(255,255,255,0.1)' },
                            ticks: { color: 'rgba(255,255,255,0.7)' }
                        },
                        x: {
                            grid: { color: 'rgba(255,255,255,0.1)' },
                            ticks: { 
                                color: 'rgba(255,255,255,0.7)',
                                maxRotation: 45,
                                callback: function(val, idx) {
                                    return idx % 5 === 0 ? this.getLabelForValue(val) : '';
                                }
                            }
                        }
                    }
                }
            });
        }
        
        function renderDrawdownCalendar(startYear) {
            if (!wiCachedResults || !wiCachedResults.drawdownsByYear[startYear]) {
                safeHTML('wiDrawdownCalendar', '<div style="color:var(--muted);font-size:.85rem">Pas de drawdowns significatifs.</div>');
                return;
            }
            
            var drawdowns = wiCachedResults.drawdownsByYear[startYear];
            
            // Regrouper par ann√©e
            var byYear = {};
            for (var i = 0; i < drawdowns.length; i++) {
                var dd = drawdowns[i];
                var year = dd.month.substring(0, 4);
                if (!byYear[year]) byYear[year] = [];
                byYear[year].push(dd);
            }
            
            var html = '<div style="display:flex;flex-direction:column;gap:.5rem">';
            
            var yearKeys = Object.keys(byYear).sort();
            for (var y = 0; y < yearKeys.length; y++) {
                var year = yearKeys[y];
                var months = byYear[year];
                
                html += '<div style="display:flex;align-items:center;gap:.5rem">';
                html += '<div style="width:40px;font-size:.75rem;font-weight:600;color:var(--muted)">' + year + '</div>';
                html += '<div style="display:flex;gap:2px;flex:1">';
                
                // 12 mois
                for (var m = 1; m <= 12; m++) {
                    var monthStr = year + '-' + (m < 10 ? '0' : '') + m;
                    var monthDD = months.find(function(d) { return d.month === monthStr; });
                    
                    var color = 'rgba(255,255,255,0.1)';
                    var title = monthStr + ': Pas de donn√©es';
                    
                    if (monthDD) {
                        if (monthDD.dd >= 30) {
                            color = 'rgba(239, 68, 68, 0.9)';
                        } else if (monthDD.dd >= 20) {
                            color = 'rgba(239, 68, 68, 0.6)';
                        } else if (monthDD.dd >= 10) {
                            color = 'rgba(234, 179, 8, 0.7)';
                        } else if (monthDD.dd >= 5) {
                            color = 'rgba(234, 179, 8, 0.4)';
                        } else {
                            color = 'rgba(34, 197, 94, 0.3)';
                        }
                        title = monthStr + ': -' + monthDD.dd.toFixed(1) + '% drawdown';
                    }
                    
                    html += '<div style="flex:1;height:20px;background:' + color + ';border-radius:2px;cursor:help" title="' + title + '"></div>';
                }
                
                html += '</div></div>';
            }
            
            html += '</div>';
            
            // L√©gende
            html += '<div style="display:flex;gap:1rem;margin-top:1rem;font-size:.7rem;color:var(--muted);justify-content:center">' +
                '<div style="display:flex;align-items:center;gap:.25rem"><div style="width:12px;height:12px;background:rgba(34,197,94,.3);border-radius:2px"></div> <5%</div>' +
                '<div style="display:flex;align-items:center;gap:.25rem"><div style="width:12px;height:12px;background:rgba(234,179,8,.4);border-radius:2px"></div> 5-10%</div>' +
                '<div style="display:flex;align-items:center;gap:.25rem"><div style="width:12px;height:12px;background:rgba(234,179,8,.7);border-radius:2px"></div> 10-20%</div>' +
                '<div style="display:flex;align-items:center;gap:.25rem"><div style="width:12px;height:12px;background:rgba(239,68,68,.6);border-radius:2px"></div> 20-30%</div>' +
                '<div style="display:flex;align-items:center;gap:.25rem"><div style="width:12px;height:12px;background:rgba(239,68,68,.9);border-radius:2px"></div> >30%</div>' +
                '</div>';
            
            safeHTML('wiDrawdownCalendar', html);
            
            // Best timing analysis
            renderBestTiming();
        }
        
        function renderBestTiming() {
            if (!wiCachedResults) return;
            
            var years = wiCachedResults.years;
            var best = null;
            var bestROI = -Infinity;
            var worst = null;
            var worstROI = Infinity;
            
            for (var i = 0; i < years.length; i++) {
                var r = wiCachedResults.resultsByYear[years[i]];
                if (r) {
                    if (r.roi > bestROI) {
                        bestROI = r.roi;
                        best = { year: years[i], result: r };
                    }
                    if (r.roi < worstROI) {
                        worstROI = r.roi;
                        worst = { year: years[i], result: r };
                    }
                }
            }
            
            if (!best || !worst) return;
            
            var html = '<div style="background:linear-gradient(135deg,rgba(77,159,255,.1),rgba(168,85,247,.1));padding:1rem;border-radius:8px;border:1px solid var(--blue)">' +
                '<div style="font-weight:600;margin-bottom:.75rem">üéØ Analyse du Timing</div>' +
                '<div style="display:grid;grid-template-columns:1fr 1fr;gap:1rem">' +
                '<div style="background:var(--card);padding:.75rem;border-radius:6px;border-left:3px solid var(--green)">' +
                '<div style="font-size:.75rem;color:var(--green);font-weight:600">üèÜ MEILLEUR MOMENT</div>' +
                '<div style="font-size:1.2rem;font-weight:700;margin:.25rem 0">Commencer en ' + best.year + '</div>' +
                '<div style="font-size:.8rem;color:var(--muted)">ROI: +' + best.result.roi.toFixed(1) + '% | Profit: +' + best.result.profit.toFixed(0) + '‚Ç¨</div>' +
                '</div>' +
                '<div style="background:var(--card);padding:.75rem;border-radius:6px;border-left:3px solid var(--red)">' +
                '<div style="font-size:.75rem;color:var(--red);font-weight:600">üò¨ PIRE MOMENT</div>' +
                '<div style="font-size:1.2rem;font-weight:700;margin:.25rem 0">Commencer en ' + worst.year + '</div>' +
                '<div style="font-size:.8rem;color:var(--muted)">ROI: ' + (worst.result.roi >= 0 ? '+' : '') + worst.result.roi.toFixed(1) + '% | Profit: ' + (worst.result.profit >= 0 ? '+' : '') + worst.result.profit.toFixed(0) + '‚Ç¨</div>' +
                '</div>' +
                '</div>' +
                '<div style="margin-top:1rem;font-size:.85rem;color:var(--muted)">' +
                'üí° La diff√©rence de ROI entre le meilleur et le pire moment est de <strong>' + (bestROI - worstROI).toFixed(1) + '%</strong>. ' +
                'Cela montre l\'importance de la p√©riode d\'entr√©e et la variabilit√© des strat√©gies dans le temps.' +
                '</div>' +
                '</div>';
            
            safeHTML('wiBestTiming', html);
        }

        // ==================== INIT ====================
        function initV2() {
            checkWeekTournaments();
            updateStreaks();
            updateGoal();
            checkMilestones();
            renderStats();
            // initNotifications(); // TODO: a implementer
            renderActiveNiches();
            updateSimNicheSelect();
            // updateSimRecommendations(); // TODO: a implementer
            updateSimStats();
        }

        // ==================== LABO ====================
        var labMode = 'playground';
        var labChart2 = null;
        var labRes = [];
        
        // Navigation paris par paris pour le Playground
        var labNavData = {
            bets: [],
            profitData: [],
            currentIndex: 0
        };
        
        function labNavPrev() {
            if (labNavData.bets.length === 0) return;
            labNavData.currentIndex = Math.max(1, labNavData.currentIndex - 1);
            labNavUpdateDisplay();
            labNavHighlightPoint();
        }
        
        function labNavNext() {
            if (labNavData.bets.length === 0) return;
            labNavData.currentIndex = Math.min(labNavData.bets.length, labNavData.currentIndex + 1);
            labNavUpdateDisplay();
            labNavHighlightPoint();
        }
        
        function labNavGoTo(index) {
            if (labNavData.bets.length === 0) return;
            labNavData.currentIndex = Math.max(1, Math.min(labNavData.bets.length, index));
            labNavUpdateDisplay();
            labNavHighlightPoint();
        }
        
        function labNavUpdateDisplay() {
            var idx = labNavData.currentIndex;
            var total = labNavData.bets.length;
            
            safeText('labNavIndex', idx + ' / ' + total);
            
            var prevBtn = document.getElementById('labNavPrevBtn');
            var nextBtn = document.getElementById('labNavNextBtn');
            if (prevBtn) prevBtn.disabled = idx <= 1;
            if (nextBtn) nextBtn.disabled = idx >= total;
            
            if (idx > 0 && idx <= labNavData.bets.length) {
                var bet = labNavData.bets[idx - 1];
                if (!bet) return;
                
                // Utiliser cumProfit stock√© dans bet
                var profit = bet.cumProfit !== undefined ? bet.cumProfit : 0;
                
                var icon = bet.won ? '‚úÖ' : '‚ùå';
                var pnlColor = bet.pnl >= 0 ? 'var(--green)' : 'var(--red)';
                var profitColor = profit >= 0 ? 'var(--green)' : 'var(--red)';
                
                var html = '<div style="display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:.5rem">';
                html += '<div>';
                html += '<span style="font-weight:700">' + icon + ' ' + bet.betOn + '</span>';
                html += ' <span style="color:var(--blue)">@' + bet.odds.toFixed(2) + '</span>';
                html += ' <span style="color:var(--muted)">vs ' + bet.vs + '</span>';
                if (bet.score) html += ' <span style="font-family:\'JetBrains Mono\',monospace;font-size:.75rem">(' + formatScore(bet.score) + ')</span>';
                html += '</div>';
                html += '<div style="text-align:right">';
                html += '<span style="font-size:.75rem;color:var(--muted)">' + bet.tournament + ' ‚Ä¢ ' + bet.round + ' ‚Ä¢ ' + bet.date + '</span><br>';
                html += '<span style="font-weight:700;color:' + pnlColor + '">' + (bet.pnl >= 0 ? '+' : '') + bet.pnl.toFixed(2) + 'u</span>';
                html += ' ‚Üí <span style="font-weight:700;color:' + profitColor + '">Total: ' + (profit >= 0 ? '+' : '') + profit.toFixed(2) + 'u</span>';
                html += '</div>';
                html += '</div>';
                
                safeHTML('labNavDetail', html);
            }
        }
        
        function labNavHighlightPoint() {
            if (!labChart2) return;
            var idx = labNavData.currentIndex;
            labChart2.setActiveElements([{ datasetIndex: 0, index: idx }]);
            labChart2.tooltip.setActiveElements([{ datasetIndex: 0, index: idx }], {x: 0, y: 0});
            labChart2.update();
        }
        
        function labNavShow(bets, profitData) {
            labNavData.bets = bets || [];
            labNavData.profitData = profitData || [];
            labNavData.currentIndex = bets.length > 0 ? bets.length : 0;
            
            var navEl = document.getElementById('labChartNav');
            if (navEl) navEl.style.display = bets.length > 0 ? 'block' : 'none';
            
            if (bets.length > 0) labNavUpdateDisplay();
        }
        
        // Multi-selection arrays
        var labSelCats = [];
        var labSelSurfs = [];
        var labSelRounds = [];
        
        // Available options
        var LAB_CATS_ATP = ['Grand Slam', 'Masters 1000', 'ATP 500', 'ATP 250'];
        var LAB_CATS_WTA = ['Grand Slam', 'WTA 1000', 'WTA 500', 'WTA 250'];
        var LAB_SURFS = ['Hard', 'Clay', 'Grass'];
        var LAB_ROUNDS = ['F', 'SF', 'QF', 'R16', 'R32', 'R64', 'R128'];

        function setLabMode(m) {
            labMode = m;
            document.getElementById('labTabPlay').classList.toggle('active', m === 'playground');
            document.getElementById('labTabDet').classList.toggle('active', m === 'detector');
            var tabNiches = document.getElementById('labTabNiches');
            if (tabNiches) tabNiches.classList.toggle('active', m === 'niches');
            var tabPortfolio = document.getElementById('labTabPortfolio');
            if (tabPortfolio) tabPortfolio.classList.toggle('active', m === 'portfolio');
            var tabDatahub = document.getElementById('labTabDatahub');
            if (tabDatahub) tabDatahub.classList.toggle('active', m === 'datahub');

            document.getElementById('labPlayground').style.display = m === 'playground' ? 'block' : 'none';
            document.getElementById('labDetector').style.display = m === 'detector' ? 'block' : 'none';
            var nichesSection = document.getElementById('labNichesSection');
            if (nichesSection) nichesSection.style.display = m === 'niches' ? 'block' : 'none';
            var portfolioSection = document.getElementById('labPortfolio');
            if (portfolioSection) portfolioSection.style.display = m === 'portfolio' ? 'block' : 'none';
            var datahubSection = document.getElementById('labDatahub');
            if (datahubSection) datahubSection.style.display = m === 'datahub' ? 'block' : 'none';

            // Masquer le warning "no data" pour certains onglets
            if (m === 'niches') {
                safeDisplay('labNoData', false);
                renderNichesInLab();
                // Mettre √† jour le Moniteur YTD
                if (typeof updateYTDMonitor === 'function') {
                    updateYTDMonitor();
                }
            } else if (m === 'portfolio' || m === 'datahub') {
                safeDisplay('labNoData', false);
                if (m === 'datahub') {
                    initDatahubDate();
                    updateDatahubStats();
                }
            } else {
                checkLabData();
            }
        }
        
        function renderNichesInLab() {
            // Utiliser la fonction principale de rendu des niches
            // mais cibler le conteneur dans labNichesSection
            var container = document.querySelector('#labNichesSection #nichesListContainer');
            if (!container) {
                console.warn('nichesListContainer in labNichesSection not found');
                return;
            }
            
            // Appeler la logique principale mais avec ce conteneur sp√©cifique
            renderNichesListInContainer(container);
        }
        
        function renderNichesListInContainer(container) {
            var curYear = new Date().getFullYear();
            var hasData = btDataATP.length > 0 || btDataWTA.length > 0;
            
            // Collecter toutes les niches
            var niches = [];
            NICHES_ATP.forEach(function(n) { niches.push({ niche: n, circuit: 'atp', data: btDataATP }); });
            NICHES_WTA.forEach(function(n) { niches.push({ niche: n, circuit: 'wta', data: btDataWTA }); });
            
            if (niches.length === 0) {
                container.innerHTML = '<div style="text-align:center;padding:2rem;color:var(--muted)">Aucune niche configur√©e. Va dans le D√©tecteur pour en trouver !</div>';
                return;
            }
            
            // Calculer les stats pour chaque niche
            var nichesWithStats = [];
            niches.forEach(function(item, idx) {
                var n = item.niche;
                var d = item.data;
                
                var rAll = null, r3 = null, yearlyData = [];
                
                if (d.length > 0) {
                    rAll = testComboV2(d, n.cat, n.surf, n.rounds, n.strat, n.min, n.max, 2007, curYear);
                    r3 = testComboV2(d, n.cat, n.surf, n.rounds, n.strat, n.min, n.max, curYear - 3, curYear);
                    if (rAll) yearlyData = rAll.yearlyData || [];
                }
                
                // Calculer le score acad√©mique
                var scoreData = null;
                if (rAll && rAll.bets >= 10) {
                    scoreData = calcCompositeScore(rAll, r3, null, yearlyData, 500);
                }
                
                var roiAll = rAll ? rAll.roi : null;
                var roi3 = r3 ? r3.roi : null;
                
                // D√©terminer la tendance
                var trend = 'stable';
                if (roiAll !== null && roi3 !== null) {
                    if (roi3 > roiAll + 5) trend = 'up';
                    else if (roi3 < roiAll - 5) trend = 'down';
                }
                
                // D√©terminer le statut sant√©
                var health = 'unknown';
                if (roiAll !== null) {
                    if (roiAll < 0) health = 'danger';
                    else if (roi3 !== null && roi3 < 0) health = 'warning';
                    else health = 'good';
                }
                
                nichesWithStats.push({
                    idx: idx,
                    niche: n,
                    circuit: item.circuit,
                    rAll: rAll,
                    r3: r3,
                    yearlyData: yearlyData,
                    scoreData: scoreData,
                    roiAll: roiAll,
                    roi3: roi3,
                    betsAll: rAll ? rAll.bets : 0,
                    trend: trend,
                    health: health
                });
            });
            
            // Trier: actives d'abord, puis par ROI all-time
            nichesWithStats.sort(function(a, b) {
                if (a.niche.on !== b.niche.on) return b.niche.on ? 1 : -1;
                return (b.roiAll || -999) - (a.roiAll || -999);
            });
            
            // G√©n√©rer le HTML
            var html = '';
            
            if (!hasData) {
                html += '<div style="background:rgba(234,179,8,.1);border:1px solid var(--yellow);border-radius:8px;padding:1rem;margin-bottom:1rem;text-align:center">';
                html += '‚ö†Ô∏è Charge les CSV ci-dessus pour voir les performances d√©taill√©es';
                html += '</div>';
            }
            
            nichesWithStats.forEach(function(item, displayIdx) {
                var n = item.niche;
                var circuitClass = item.circuit;
                
                var borderColor = !n.on ? 'var(--muted)' : 
                                  item.health === 'danger' ? 'var(--red)' : 
                                  item.health === 'warning' ? 'var(--yellow)' : 'var(--green)';
                var bgOpacity = !n.on ? '0.5' : '1';
                
                var score = item.scoreData ? item.scoreData.score : null;
                var scoreClass = score >= 70 ? 'excellent' : score >= 55 ? 'good' : score >= 40 ? 'moderate' : 'poor';
                var trendIcon = item.trend === 'up' ? 'üìà' : item.trend === 'down' ? 'üìâ' : '‚û°Ô∏è';
                
                html += '<div class="niche-manager-card' + (!n.on ? ' paused' : '') + '" id="lab-card-' + displayIdx + '" style="border-left:4px solid ' + borderColor + ';opacity:' + bgOpacity + '">';
                
                // Header cliquable
                html += '<div class="niche-manager-header" onclick="toggleLabCard(' + displayIdx + ')" style="position:relative">';
                
                // Indicateur expand
                html += '<div class="expand-indicator" style="position:absolute;right:1rem;top:50%;transform:translateY(-50%);color:var(--muted);font-size:.8rem;transition:transform .2s">‚ñº</div>';
                
                if (score !== null) {
                    html += '<div class="niche-score ' + scoreClass + '" style="width:40px;height:40px;font-size:1rem">' + score + '</div>';
                } else {
                    html += '<div style="width:40px;height:40px;background:var(--border);border-radius:8px;display:flex;align-items:center;justify-content:center;color:var(--muted)">?</div>';
                }
                
                html += '<div class="niche-manager-info">';
                html += '<div class="niche-manager-name">';
                html += '<span class="badge ' + circuitClass + '">' + item.circuit.toUpperCase() + '</span> ';
                html += n.name;
                if (!n.on) html += ' <span style="color:var(--muted);font-size:.75rem">(pause)</span>';
                html += '</div>';
                html += '<div class="niche-manager-meta">';
                if (item.betsAll > 0) {
                    html += '<span>' + item.betsAll + ' paris</span>';
                    if (item.rAll) html += '<span>' + item.rAll.yrsPos + '/' + item.rAll.yrs + ' ans +</span>';
                    html += '<span>' + trendIcon + '</span>';
                }
                html += '</div>';
                html += '</div>';
                
                // ROI + Toggle (sur m√™me ligne en mobile)
                html += '<div class="niche-manager-roi" onclick="event.stopPropagation()">';
                if (item.roiAll !== null) {
                    var roiColor = item.roiAll >= 0 ? 'var(--green)' : 'var(--red)';
                    html += '<div><div style="font-size:1.4rem;font-weight:700;color:' + roiColor + '">' + (item.roiAll >= 0 ? '+' : '') + item.roiAll.toFixed(0) + '%</div>';
                    html += '<div style="font-size:.65rem;color:var(--muted)">ROI</div></div>';
                } else {
                    html += '<div style="color:var(--muted)">-</div>';
                }
                // Toggle inline
                if (n.on) {
                    html += '<button onclick="toggleNicheFromLab(\'' + n.id + '\',\'' + item.circuit + '\',false)" class="toggle-switch on">ON</button>';
                } else {
                    html += '<button onclick="toggleNicheFromLab(\'' + n.id + '\',\'' + item.circuit + '\',true)" class="toggle-switch off">OFF</button>';
                }
                html += '</div>';

                // Delete s√©par√©
                html += '<div class="niche-manager-actions" onclick="event.stopPropagation()">';
                html += '<button onclick="deleteNicheFromLab(\'' + n.id + '\',\'' + item.circuit + '\')" class="delete-btn">üóëÔ∏è</button>';
                html += '</div>';
                
                html += '</div>'; // header
                
                // D√©tails
                html += '<div class="niche-manager-details">';
                
                if (hasData && item.rAll) {
                    html += '<div class="niche-metrics" style="grid-template-columns:repeat(5,1fr)">';
                    html += '<div class="niche-metric"><div class="val">' + (score !== null ? score : '-') + '</div><div class="lbl">Score</div></div>';
                    html += '<div class="niche-metric"><div class="val">' + (item.rAll ? item.rAll.yrsPos + '/' + item.rAll.yrs : '-') + '</div><div class="lbl">Ann√©es +</div></div>';
                    html += '<div class="niche-metric"><div class="val">' + (item.roi3 !== null ? (item.roi3 >= 0 ? '+' : '') + item.roi3.toFixed(0) + '%' : '-') + '</div><div class="lbl">ROI 3 ans</div></div>';
                    html += '<div class="niche-metric"><div class="val">' + (item.rAll ? (item.rAll.bets / item.rAll.yrs).toFixed(1) : '-') + '</div><div class="lbl">Paris/an</div></div>';
                    html += '<div class="niche-metric"><div class="val">' + (item.rAll ? '-' + item.rAll.maxDD.toFixed(1) + 'u' : '-') + '</div><div class="lbl">Max DD</div></div>';
                    html += '</div>';
                    
                    if (item.scoreData && item.scoreData.warnings && item.scoreData.warnings.length > 0) {
                        html += '<div style="background:rgba(239,68,68,.1);border:1px solid rgba(239,68,68,.3);border-radius:6px;padding:.5rem;margin-bottom:.75rem">';
                        html += '<div style="font-size:.7rem;color:var(--red);margin-bottom:.25rem">‚ö†Ô∏è Alertes</div>';
                        item.scoreData.warnings.forEach(function(w) {
                            html += '<div style="font-size:.7rem;color:var(--text);padding-left:.5rem">' + w + '</div>';
                        });
                        html += '</div>';
                    }
                    
                    if (item.scoreData && item.scoreData.bonuses && item.scoreData.bonuses.length > 0) {
                        html += '<div style="background:rgba(34,197,94,.1);border:1px solid rgba(34,197,94,.3);border-radius:6px;padding:.5rem;margin-bottom:.75rem">';
                        html += '<div style="font-size:.7rem;color:var(--green);margin-bottom:.25rem">‚úÖ Points forts</div>';
                        item.scoreData.bonuses.forEach(function(b) {
                            html += '<div style="font-size:.7rem;color:var(--text);padding-left:.5rem">' + b + '</div>';
                        });
                        html += '</div>';
                    }
                    
                    if (item.yearlyData && item.yearlyData.length > 0) {
                        html += '<div style="font-size:.7rem;color:var(--muted);margin-bottom:.4rem">Performance par ann√©e:</div>';
                        html += '<div class="niche-years-detailed">';
                        item.yearlyData.forEach(function(y) {
                            var yClass = y.roi > 20 ? 'very-pos' : y.roi > 0 ? 'pos' : y.roi > -20 ? 'neg' : 'very-neg';
                            html += '<div class="niche-year-detail ' + yClass + '">';
                            html += '<div class="year-label">' + y.year + '</div>';
                            html += '<div class="year-bets">' + y.bets + 'p</div>';
                            html += '<div class="year-roi">' + (y.roi >= 0 ? '+' : '') + y.roi.toFixed(0) + '%</div>';
                            html += '</div>';
                        });
                        html += '</div>';
                    }
                    
                    // Coefficient de mise personnalis√©
                    var currentCoef = n.stakeCoef || 1.0;
                    var avgOdds = (n.min + n.max) / 2;
                    
                    // Calculer le coefficient conseill√© bas√© sur la formule r√©vis√©e
                    var recommendedCoef = calcRecommendedCoef(n, item.rAll, item.r3);
                    
                    // Calculer la borne basse du ROI pour l'afficher
                    var roiLower = null;
                    if (item.rAll && item.rAll.bets >= 20) {
                        var k = 80;
                        var roiAdj = (item.rAll.bets * item.rAll.roi + k * 2) / (item.rAll.bets + k);
                        var se = (avgOdds * 30) / Math.sqrt(item.rAll.bets);
                        roiLower = roiAdj - se;
                    }
                    
                    var sliderId = 'slider-' + n.id;
                    var numId = 'num-' + n.id;
                    html += '<div style="background:var(--bg);border-radius:8px;padding:.75rem;margin-top:.75rem;border:1px solid var(--border)">';
                    html += '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:.5rem">';
                    html += '<div style="font-size:.8rem;font-weight:600">üéöÔ∏è Coefficient de mise</div>';
                    html += '<div style="font-size:.75rem">';
                    html += '<span style="color:var(--green);cursor:pointer;background:rgba(34,197,94,.1);padding:2px 8px;border-radius:4px" onclick="applyRecommendedCoef(\'' + n.id + '\',\'' + item.circuit + '\',' + recommendedCoef.toFixed(2) + ')" title="Cliquer pour appliquer">üí° √ó' + recommendedCoef.toFixed(2) + '</span>';
                    html += '</div>';
                    html += '</div>';
                    html += '<div style="display:flex;gap:.5rem;align-items:center;margin-top:.5rem">';
                    html += '<input type="range" id="' + sliderId + '" min="0.3" max="1.7" step="0.05" value="' + currentCoef.toFixed(2) + '" oninput="document.getElementById(\'' + numId + '\').value=parseFloat(this.value).toFixed(2)" onchange="updateNicheStakeCoef(\'' + n.id + '\',\'' + item.circuit + '\',this.value)" style="flex:1;height:6px;accent-color:var(--blue);cursor:pointer">';
                    html += '<input type="number" id="' + numId + '" min="0.1" max="5" step="0.01" value="' + currentCoef.toFixed(2) + '" oninput="var s=document.getElementById(\'' + sliderId + '\');if(s&&this.value>=0.3&&this.value<=1.7)s.value=this.value" onchange="updateNicheStakeCoef(\'' + n.id + '\',\'' + item.circuit + '\',this.value)" style="width:65px;padding:.4rem;background:var(--card);border:2px solid var(--blue);border-radius:4px;color:var(--text);text-align:center;font-weight:700;font-size:.9rem">';
                    html += '</div>';
                    html += '<div style="display:flex;justify-content:space-between;font-size:.55rem;color:var(--muted);margin-top:.2rem">';
                    html += '<span>√ó0.3</span><span>√ó0.7</span><span>√ó1.0</span><span>√ó1.3</span><span>√ó1.7</span>';
                    html += '</div>';
                    
                    // Explication de la formule
                    html += '<div style="font-size:.6rem;color:var(--muted);margin-top:.5rem;padding:.4rem;background:var(--card);border-radius:4px;line-height:1.4">';
                    html += '<div style="font-weight:600;margin-bottom:.2rem">üìê Formule bay√©sienne :</div>';
                    if (roiLower !== null) {
                        html += 'ROI shrink: ' + (item.rAll.bets * item.rAll.roi / (item.rAll.bets + 80) + 80 * 2 / (item.rAll.bets + 80)).toFixed(1) + '% ‚Üí ';
                        html += 'Borne basse: <b style="color:' + (roiLower >= 0 ? 'var(--green)' : 'var(--red)') + '">' + (roiLower >= 0 ? '+' : '') + roiLower.toFixed(1) + '%</b><br>';
                    }
                    html += 'Cote moy: ' + avgOdds.toFixed(2) + ' | ';
                    html += 'ROI 3a: ' + (item.roi3 !== null ? (item.roi3 >= 0 ? '+' : '') + item.roi3.toFixed(0) + '%' : '?') + ' | ';
                    html += 'Paris: ' + (item.rAll ? item.rAll.bets : '?');
                    html += '</div>';
                    html += '</div>';
                    
                    // Bouton Playground
                    html += '<button onclick="event.stopPropagation();loadDetNiche(\'' + n.cat + '\',\'' + n.surf + '\',\'' + n.rounds.join(',') + '\',\'' + n.strat + '\',' + n.min + ',' + n.max + ',\'' + item.circuit + '\')" style="width:100%;margin-top:.75rem;padding:.6rem;background:linear-gradient(135deg,var(--blue),#3b82f6);color:#fff;border:none;border-radius:6px;font-size:.8rem;font-weight:600;cursor:pointer">üî¨ Analyser dans le Playground</button>';
                } else {
                    html += '<div style="text-align:center;padding:1rem;color:var(--muted);font-size:.85rem">Charge les donn√©es CSV pour voir l\'analyse d√©taill√©e</div>';
                }
                
                html += '</div>'; // details
                html += '</div>'; // card
            });
            
            container.innerHTML = html;
        }
        
        function toggleLabCard(idx) {
            console.log('toggleLabCard called:', idx);
            var card = document.getElementById('lab-card-' + idx);
            console.log('Card found:', card);
            if (card) {
                card.classList.toggle('expanded');
                console.log('Card expanded:', card.classList.contains('expanded'));
            }
        }
        
        function toggleNicheFromLab(nicheId, circuit, newStatus) {
            toggleNicheStatus(nicheId, circuit, newStatus);
            renderNichesInLab();
            // Mettre √† jour le Moniteur YTD
            if (typeof updateYTDMonitor === 'function') {
                updateYTDMonitor();
            }
        }
        
        function deleteNicheFromLab(nicheId, circuit) {
            console.log('deleteNicheFromLab called:', nicheId, circuit);
            // Suppression directe (le confirm √©tait bloqu√©)
            console.log('Deleting...');
            var result = deleteNichePermanently(nicheId, circuit);
            console.log('Delete result:', result);
            renderNichesInLab();
        }
        
        function updateNicheStakeCoef(nicheId, circuit, value) {
            var coef = parseFloat(value) || 1.0;
            coef = Math.max(0.1, Math.min(5.0, coef)); // Min 0.1, Max 5.0
            coef = Math.round(coef * 100) / 100; // Arrondir √† 0.01 pr√®s
            
            var niches = circuit === 'atp' ? NICHES_ATP : NICHES_WTA;
            for (var i = 0; i < niches.length; i++) {
                if (niches[i].id === nicheId) {
                    niches[i].stakeCoef = coef;
                    break;
                }
            }
            
            saveNiches();
            console.log('Updated stake coef for', nicheId, ':', coef);
            
            // Rafra√Æchir le bandeau, le calendrier et les projections
            if (typeof checkWeekTournaments === 'function') checkWeekTournaments();
            if (typeof renderCalendar === 'function') renderCalendar();
            if (typeof updateProjectionDisplay === 'function') updateProjectionDisplay();
        }
        
        function checkLabData() {
            var hasData = btDataATP.length > 0 || btDataWTA.length > 0;
            safeDisplay('labNoData', !hasData);
            if (hasData && labMode === 'playground') safeDisplay('labPlayground', true);
            if (hasData && labMode === 'detector') safeDisplay('labDetector', true);
        }
        
        function updateLabCategories() {
            var circuit = document.getElementById('labCircuit').value;
            var box = document.getElementById('labCatsBox');
            if (!box) return;
            
            // Reset selections
            labSelCats = [];
            
            // Update visible buttons based on circuit
            var html = '<button class="toggle-btn" onclick="toggleLabSel(\'cat\',\'Grand Slam\',this)">GS</button>';
            if (circuit === 'atp' || circuit === 'both') {
                html += '<button class="toggle-btn" onclick="toggleLabSel(\'cat\',\'Masters 1000\',this)">M1000</button>';
                html += '<button class="toggle-btn" onclick="toggleLabSel(\'cat\',\'ATP 500\',this)">ATP 500</button>';
                html += '<button class="toggle-btn" onclick="toggleLabSel(\'cat\',\'ATP 250\',this)">ATP 250</button>';
            }
            if (circuit === 'wta' || circuit === 'both') {
                html += '<button class="toggle-btn" onclick="toggleLabSel(\'cat\',\'WTA 1000\',this)">W1000</button>';
                html += '<button class="toggle-btn" onclick="toggleLabSel(\'cat\',\'WTA 500\',this)">WTA 500</button>';
                html += '<button class="toggle-btn" onclick="toggleLabSel(\'cat\',\'WTA 250\',this)">WTA 250</button>';
            }
            box.innerHTML = html;
        }
        
        function toggleLabSel(type, value, btn) {
            var arr;
            if (type === 'cat') arr = labSelCats;
            else if (type === 'surf') arr = labSelSurfs;
            else arr = labSelRounds;
            
            var idx = arr.indexOf(value);
            if (idx >= 0) {
                arr.splice(idx, 1);
                btn.classList.remove('active');
            } else {
                arr.push(value);
                btn.classList.add('active');
            }
        }
        
        function initLabToggles() {
            // Nothing to do - buttons are in HTML
        }
        
        // Store last tested params for adding to niches
        var lastLabParams = null;

        function setLabYears(n) {
            var now = new Date().getFullYear();
            document.getElementById('labYearFrom').value = n === 0 ? 2007 : now - n;
            document.getElementById('labYearTo').value = now;
            // Relancer le test automatiquement
            runLabTest();
        }
        
        function addLabNicheToConfig() {
            if (!lastLabParams) {
                alert('Teste d\'abord une strat√©gie');
                return;
            }
            
            var p = lastLabParams;
            
            // Generate niche name
            var stratLabel = p.strategy === 'underdog' ? 'UND' : 'FAV';
            var catLabel = p.categories.length === 1 ? p.categories[0].replace('Masters 1000', 'M1000').replace('Grand Slam', 'GS').replace('WTA ', 'W').replace('ATP ', '') : 'Multi';
            var surfLabel = p.surfaces.length === 1 ? p.surfaces[0] : (p.surfaces.length === 3 ? 'All' : p.surfaces.join('+'));
            var roundLabel = p.rounds.join('+');
            var oddsLabel = '@' + p.oddsMin + '-' + p.oddsMax;
            
            var defaultName = stratLabel + ' ' + catLabel + ' ' + surfLabel + ' ' + roundLabel + ' ' + oddsLabel;
            var name = prompt('Nom de la niche :', defaultName);
            if (!name) return;
            
            // Create niche object
            var nicheId = 'custom_' + Date.now();
            var niche = {
                id: nicheId,
                name: name,
                cat: p.categories[0] || 'Grand Slam',
                surf: p.surfaces[0] || 'Hard',
                rounds: p.rounds,
                strat: p.strategy,
                min: p.oddsMin,
                max: p.oddsMax,
                on: true,
                custom: true
            };
            
            // Determine which circuit to add to
            var circuit = p.circuit;
            if (circuit === 'both') {
                var choice = prompt('Ajouter √† quel circuit ?\n1 = ATP\n2 = WTA\n3 = Les deux', '1');
                if (choice === '2') circuit = 'wta';
                else if (choice === '3') circuit = 'both';
                else circuit = 'atp';
            }
            
            // Load existing custom niches from localStorage
            var customNiches = JSON.parse(localStorage.getItem('customNiches') || '{"atp":[],"wta":[]}');
            
            if (circuit === 'atp' || circuit === 'both') {
                customNiches.atp.push(niche);
            }
            if (circuit === 'wta' || circuit === 'both') {
                var wtaNiche = JSON.parse(JSON.stringify(niche));
                wtaNiche.id = nicheId + '_wta';
                customNiches.wta.push(wtaNiche);
            }
            
            // Save to localStorage
            localStorage.setItem('customNiches', JSON.stringify(customNiches));
            
            // Reload niches in config
            loadCustomNiches();
        }
        
        function loadCustomNiches() {
            var customNiches = JSON.parse(localStorage.getItem('customNiches') || '{"atp":[],"wta":[]}');
            
            // Remove old custom niches from arrays
            for (var i = NICHES_ATP.length - 1; i >= 0; i--) {
                if (NICHES_ATP[i].custom) NICHES_ATP.splice(i, 1);
            }
            for (var i = NICHES_WTA.length - 1; i >= 0; i--) {
                if (NICHES_WTA[i].custom) NICHES_WTA.splice(i, 1);
            }
            
            // Add custom niches
            for (var i = 0; i < customNiches.atp.length; i++) {
                NICHES_ATP.push(customNiches.atp[i]);
            }
            for (var i = 0; i < customNiches.wta.length; i++) {
                NICHES_WTA.push(customNiches.wta[i]);
            }
            
            // Re-render config if on that tab
            if (typeof renderActiveNiches === 'function') {
                renderActiveNiches();
            }
        }

        function runLabTest() {
            var circuit = document.getElementById('labCircuit').value;
            var categories = labSelCats.length > 0 ? labSelCats : null; // null = all
            var surfaces = labSelSurfs.length > 0 ? labSelSurfs : null;
            var rounds = labSelRounds.length > 0 ? labSelRounds : null;
            var strategy = document.getElementById('labStrategy').value;
            var oddsMin = parseFloat(document.getElementById('labOddsMin').value) || 1.5;
            var oddsMax = parseFloat(document.getElementById('labOddsMax').value) || 3.0;
            var yearFrom = parseInt(document.getElementById('labYearFrom').value) || 2007;
            var yearTo = parseInt(document.getElementById('labYearTo').value) || 2025;
            
            console.log('runLabTest - yearFrom:', yearFrom, 'yearTo:', yearTo);

            var data = [];
            if (circuit === 'atp' || circuit === 'both') {
                for (var i = 0; i < btDataATP.length; i++) data.push(btDataATP[i]);
            }
            if (circuit === 'wta' || circuit === 'both') {
                for (var i = 0; i < btDataWTA.length; i++) data.push(btDataWTA[i]);
            }

            if (data.length === 0) {
                alert('Charge les donn√©es CSV dans Backtest (mode Compare)');
                return;
            }

            var filtered = [];
            for (var i = 0; i < data.length; i++) {
                var m = data[i];
                if (m.year < yearFrom || m.year > yearTo) continue;
                
                // Category filter (multi)
                if (categories) {
                    var catMatch = false;
                    for (var c = 0; c < categories.length; c++) {
                        var catKey = categories[c].replace('Masters ', '').replace('WTA ', '');
                        if (m.category && m.category.indexOf(catKey) >= 0) {
                            catMatch = true;
                            break;
                        }
                    }
                    if (!catMatch) continue;
                }
                
                // Surface filter (multi)
                if (surfaces && surfaces.indexOf(m.surface) < 0) continue;
                
                // Round filter (multi)
                if (rounds && rounds.indexOf(m.round) < 0) continue;
                
                filtered.push(m);
            }

            labRes = [];
            var seen = {};
            for (var i = 0; i < filtered.length; i++) {
                var m = filtered[i];
                var key = m.date + m.p1 + m.p2;
                if (seen[key]) continue;

                var dogOdds = Math.max(m.o1, m.o2);
                var favOdds = Math.min(m.o1, m.o2);
                var dogIsP1 = m.o1 > m.o2;

                var odds, won, betOn, vs;
                if (strategy === 'underdog') {
                    odds = dogOdds;
                    won = dogIsP1;
                    betOn = dogIsP1 ? m.p1 : m.p2;
                    vs = dogIsP1 ? m.p2 : m.p1;
                } else {
                    odds = favOdds;
                    won = !dogIsP1;
                    betOn = dogIsP1 ? m.p2 : m.p1;
                    vs = dogIsP1 ? m.p1 : m.p2;
                }

                if (odds >= oddsMin && odds <= oddsMax) {
                    var pnl = won ? odds - 1 : -1;
                    
                    // Inverser le score si on parie sur player2 (le perdant)
                    // CSV: player1 = toujours gagnant, score = perspective gagnant
                    var betOnP2 = (strategy === 'underdog' && !dogIsP1) || (strategy === 'favorite' && dogIsP1);
                    var scoreDisplay = betOnP2 ? invertScore(m.score || '') : (m.score || '');
                    
                    labRes.push({
                        date: m.date,
                        year: m.year,
                        tournament: m.tournament,
                        round: m.round,
                        betOn: betOn,
                        vs: vs,
                        p1: m.p1,
                        p2: m.p2,
                        o1: m.o1,
                        o2: m.o2,
                        odds: odds,
                        won: won,
                        pnl: pnl,
                        score: scoreDisplay
                    });
                    seen[key] = true;
                }
            }
            
            // Save params for potential niche creation
            lastLabParams = {
                circuit: circuit,
                categories: categories || ['Grand Slam', 'Masters 1000', 'ATP 500', 'ATP 250', 'WTA 1000', 'WTA 500', 'WTA 250'],
                surfaces: surfaces || ['Hard', 'Clay', 'Grass'],
                rounds: rounds || ['F', 'SF', 'QF', 'R16', 'R32', 'R64'],
                strategy: strategy,
                oddsMin: oddsMin,
                oddsMax: oddsMax
            };
            
            renderLabRes();
        }
        
        // Calculer les s√©ries gagnantes et perdantes
        function calcStreaks(sortedBets, stake) {
            var bestWinning = [];
            var worstLosing = [];
            var currentWinStreak = [];
            var currentLoseStreak = [];
            
            for (var i = 0; i < sortedBets.length; i++) {
                var bet = sortedBets[i];
                
                if (bet.won) {
                    // S√©rie gagnante
                    currentWinStreak.push(bet);
                    
                    // Fin de s√©rie perdante
                    if (currentLoseStreak.length > worstLosing.length) {
                        worstLosing = currentLoseStreak.slice();
                    }
                    currentLoseStreak = [];
                } else {
                    // S√©rie perdante
                    currentLoseStreak.push(bet);
                    
                    // Fin de s√©rie gagnante
                    if (currentWinStreak.length > bestWinning.length) {
                        bestWinning = currentWinStreak.slice();
                    }
                    currentWinStreak = [];
                }
            }
            
            // V√©rifier les derni√®res s√©ries
            if (currentWinStreak.length > bestWinning.length) {
                bestWinning = currentWinStreak.slice();
            }
            if (currentLoseStreak.length > worstLosing.length) {
                worstLosing = currentLoseStreak.slice();
            }
            
            return {
                bestWinning: bestWinning,
                worstLosing: worstLosing
            };
        }

        function renderLabRes() {
            var stake = state.stake; // Mise en euros
            
            if (labRes.length === 0) {
                safeText('labBets', '0');
                safeText('labWins', '-');
                safeText('labWR', '-');
                safeText('labProfit', '-');
                safeText('labROI', '-');
                safeText('labDD', '-');
                safeDisplay('labVerdict', false);
                safeDisplay('labAddNicheBox', false);
                safeHTML('labYears', '<div style="color:var(--muted);font-size:.75rem">Aucun r√©sultat pour ces crit√®res</div>');
                safeHTML('labTbl', '');
                safeText('labCnt', '');
                return;
            }

            var wins = 0;
            var totalPnl = 0;
            for (var i = 0; i < labRes.length; i++) {
                if (labRes[i].won) wins++;
                totalPnl += labRes[i].pnl;
            }
            var roi = totalPnl / labRes.length * 100;
            var wr = wins / labRes.length * 100;
            
            // Convertir en euros
            var totalPnlEuros = totalPnl * stake;

            // Trier par date
            var sorted = labRes.slice().sort(function(a, b) {
                return a.date.localeCompare(b.date);
            });

            // Max DD en euros
            var cum = 0, peak = 0, maxDD = 0;
            for (var i = 0; i < sorted.length; i++) {
                cum += sorted[i].pnl * stake;
                if (cum > peak) peak = cum;
                if (peak - cum > maxDD) maxDD = peak - cum;
            }

            safeText('labBets', labRes.length);
            safeText('labWins', wins);
            safeText('labWR', wr.toFixed(1) + '%');
            safeText('labProfit', (totalPnlEuros >= 0 ? '+' : '') + totalPnlEuros.toFixed(0) + '‚Ç¨');
            document.getElementById('labProfit').className = 'val ' + (totalPnlEuros >= 0 ? 'pos' : 'neg');
            safeText('labROI', (roi >= 0 ? '+' : '') + roi.toFixed(1) + '%');
            document.getElementById('labROI').className = 'val ' + (roi >= 0 ? 'pos' : 'neg');
            safeText('labDD', '-' + maxDD.toFixed(0) + '‚Ç¨');
            
            // Calculer les s√©ries (streaks)
            var streaks = calcStreaks(sorted, stake);
            
            // Afficher pire s√©rie perdante
            var worstHtml = '';
            if (streaks.worstLosing.length > 0) {
                var worstLoss = streaks.worstLosing.reduce(function(sum, r) { return sum + r.pnl * stake; }, 0);
                worstHtml += '<div style="font-weight:700;color:var(--red);margin-bottom:.5rem">' + streaks.worstLosing.length + ' d√©faites cons√©cutives ‚Ä¢ ' + worstLoss.toFixed(0) + '‚Ç¨</div>';
                worstHtml += '<div style="max-height:150px;overflow-y:auto">';
                streaks.worstLosing.forEach(function(r) {
                    worstHtml += '<div style="padding:.3rem 0;border-bottom:1px solid var(--border);font-size:.75rem">';
                    worstHtml += '<span style="color:var(--muted)">' + r.date + '</span> ';
                    worstHtml += '<span style="color:var(--red)">‚ùå ' + r.betOn + '</span> vs ' + r.vs;
                    worstHtml += ' <span style="color:var(--muted)">@' + r.odds.toFixed(2) + '</span>';
                    if (r.score) worstHtml += ' <span style="color:var(--muted)">(' + formatScore(r.score) + ')</span>';
                    worstHtml += ' <span style="color:var(--red);font-weight:600">' + (r.pnl * stake).toFixed(0) + '‚Ç¨</span>';
                    worstHtml += '</div>';
                });
                worstHtml += '</div>';
            } else {
                worstHtml = '<div style="color:var(--muted)">Aucune s√©rie perdante</div>';
            }
            safeHTML('labWorstStreak', worstHtml);
            
            // Afficher meilleure s√©rie gagnante
            var bestHtml = '';
            if (streaks.bestWinning.length > 0) {
                var bestWin = streaks.bestWinning.reduce(function(sum, r) { return sum + r.pnl * stake; }, 0);
                bestHtml += '<div style="font-weight:700;color:var(--green);margin-bottom:.5rem">' + streaks.bestWinning.length + ' victoires cons√©cutives ‚Ä¢ +' + bestWin.toFixed(0) + '‚Ç¨</div>';
                bestHtml += '<div style="max-height:150px;overflow-y:auto">';
                streaks.bestWinning.forEach(function(r) {
                    bestHtml += '<div style="padding:.3rem 0;border-bottom:1px solid var(--border);font-size:.75rem">';
                    bestHtml += '<span style="color:var(--muted)">' + r.date + '</span> ';
                    bestHtml += '<span style="color:var(--green)">‚úÖ ' + r.betOn + '</span> vs ' + r.vs;
                    bestHtml += ' <span style="color:var(--muted)">@' + r.odds.toFixed(2) + '</span>';
                    if (r.score) bestHtml += ' <span style="color:var(--muted)">(' + formatScore(r.score) + ')</span>';
                    bestHtml += ' <span style="color:var(--green);font-weight:600">+' + (r.pnl * stake).toFixed(0) + '‚Ç¨</span>';
                    bestHtml += '</div>';
                });
                bestHtml += '</div>';
            } else {
                bestHtml = '<div style="color:var(--muted)">Aucune s√©rie gagnante</div>';
            }
            safeHTML('labBestStreak', bestHtml);

            // Analyse par ann√©e
            var byYear = {};
            for (var i = 0; i < labRes.length; i++) {
                var r = labRes[i];
                if (!byYear[r.year]) byYear[r.year] = { bets: 0, profit: 0 };
                byYear[r.year].bets++;
                byYear[r.year].profit += r.pnl;
            }
            var years = Object.keys(byYear).sort();
            var yearsPos = 0;
            for (var i = 0; i < years.length; i++) {
                if (byYear[years[i]].profit > 0) yearsPos++;
            }

            // Verdict
            var icon, title, color;
            if (roi >= 15 && yearsPos >= years.length * 0.6) {
                icon = 'üèÜ'; title = 'Excellente niche !'; color = 'var(--green)';
            } else if (roi >= 10) {
                icon = '‚úÖ'; title = 'Niche prometteuse'; color = 'var(--green)';
            } else if (roi >= 5) {
                icon = 'üü°'; title = '√Ä surveiller'; color = 'var(--yellow)';
            } else if (roi >= 0) {
                icon = '‚ö†Ô∏è'; title = 'Marginale'; color = 'var(--yellow)';
            } else {
                icon = '‚ùå'; title = 'Non rentable'; color = 'var(--red)';
            }
            
            // Profit annuel moyen en euros
            var avgProfitPerYear = (totalPnlEuros / years.length).toFixed(0);

            var verdictEl = document.getElementById('labVerdict');
            verdictEl.style.display = 'block';
            verdictEl.style.borderLeft = '4px solid ' + color;
            document.getElementById('labVerdictContent').innerHTML = 
                '<div style="display:flex;align-items:center;gap:1rem">' +
                '<span style="font-size:2rem">' + icon + '</span>' +
                '<div><div style="font-weight:700">' + title + '</div>' +
                '<div style="font-size:.8rem;color:var(--muted)">ROI ' + (roi >= 0 ? '+' : '') + roi.toFixed(1) + '% ‚Ä¢ ~' + (avgProfitPerYear >= 0 ? '+' : '') + avgProfitPerYear + '‚Ç¨/an ‚Ä¢ ' + yearsPos + '/' + years.length + ' ann√©es + ‚Ä¢ ~' + Math.round(labRes.length / years.length) + ' paris/an</div></div></div>';

            // Warning
            var warn = document.getElementById('labWarn');
            if (years.length < 5) {
                warn.style.display = 'block';
                warn.innerHTML = '‚ö†Ô∏è Seulement ' + years.length + ' ann√©e(s) de donn√©es - r√©sultats peu fiables, peut √™tre du bruit statistique';
            } else {
                warn.style.display = 'none';
            }

            // Ann√©es en euros
            var yearsHtml = '';
            for (var i = 0; i < years.length; i++) {
                var y = years[i];
                var s = byYear[y];
                var yProfitEuros = s.profit * stake;
                var yRoi = s.bets > 0 ? s.profit / s.bets * 100 : 0;
                yearsHtml += '<div class="year ' + (s.profit >= 0 ? 'pos' : 'neg') + '"><b>' + y + '</b><span>' + s.bets + 'p ‚Ä¢ ' + (yProfitEuros >= 0 ? '+' : '') + yProfitEuros.toFixed(0) + '‚Ç¨</span></div>';
            }
            safeHTML('labYears', yearsHtml);

            // Chart avec tooltips d√©taill√©s
            var ctx = document.getElementById('labChart').getContext('2d');
            if (labChart2) labChart2.destroy();
            
            // Pr√©parer les donn√©es du graphique avec infos d√©taill√©es
            cum = 0;
            var chartData = [{
                x: 0,
                y: 0,
                date: 'D√©part',
                betOn: '',
                vs: '',
                odds: 0,
                pnl: 0,
                won: null
            }];
            
            for (var i = 0; i < sorted.length; i++) {
                var r = sorted[i];
                cum += r.pnl * stake;
                chartData.push({
                    x: i + 1,
                    y: cum,
                    date: r.date,
                    betOn: r.betOn,
                    vs: r.vs,
                    odds: r.odds,
                    pnl: r.pnl * stake,
                    pnlUnits: r.pnl,
                    won: r.won,
                    tournament: r.tournament,
                    round: r.round,
                    score: r.score || ''
                });
            }
            
            labChart2 = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        data: chartData,
                        borderColor: cum >= 0 ? '#22c55e' : '#ef4444',
                        backgroundColor: cum >= 0 ? 'rgba(34,197,94,.15)' : 'rgba(239,68,68,.15)',
                        fill: true,
                        tension: 0.1,
                        pointRadius: chartData.length < 100 ? 4 : chartData.length < 300 ? 2 : 0,
                        pointHoverRadius: 6,
                        pointBackgroundColor: function(context) {
                            var index = context.dataIndex;
                            if (index === 0) return '#666';
                            var point = chartData[index];
                            return point.won ? '#22c55e' : '#ef4444';
                        },
                        pointBorderColor: '#fff',
                        pointBorderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    onClick: function(evt, elements) {
                        if (elements && elements.length > 0) {
                            var idx = elements[0].index;
                            if (idx > 0) labNavGoTo(idx);
                        }
                    },
                    parsing: {
                        xAxisKey: 'x',
                        yAxisKey: 'y'
                    },
                    plugins: { 
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: 'rgba(0,0,0,0.9)',
                            titleColor: '#fff',
                            bodyColor: '#fff',
                            padding: 12,
                            displayColors: false,
                            callbacks: {
                                title: function(context) {
                                    var point = chartData[context[0].dataIndex];
                                    if (point.date === 'D√©part') return 'Point de d√©part';
                                    return point.date;
                                },
                                label: function(context) {
                                    var point = chartData[context.dataIndex];
                                    if (point.date === 'D√©part') return 'Profit: 0‚Ç¨';
                                    var lines = [];
                                    lines.push((point.won ? '‚úÖ ' : '‚ùå ') + point.betOn + ' vs ' + point.vs);
                                    if (point.tournament) lines.push(point.tournament + ' - ' + point.round);
                                    lines.push('Cote: ' + point.odds.toFixed(2));
                                    lines.push('P&L: ' + (point.pnl >= 0 ? '+' : '') + point.pnl.toFixed(0) + '‚Ç¨');
                                    lines.push('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
                                    lines.push('Cumul: ' + (point.y >= 0 ? '+' : '') + point.y.toFixed(0) + '‚Ç¨');
                                    return lines;
                                }
                            }
                        }
                    },
                    scales: {
                        x: { 
                            type: 'linear',
                            display: true,
                            title: { display: true, text: 'Paris', color: '#888' },
                            grid: { color: 'rgba(255,255,255,.05)' },
                            ticks: { color: '#888' }
                        },
                        y: { 
                            grid: { color: 'rgba(255,255,255,.05)' },
                            ticks: { 
                                color: '#888',
                                callback: function(value) { return value + '‚Ç¨'; }
                            }
                        }
                    }
                }
            });
            
            // Activer la navigation paris par paris (exclure le premier √©l√©ment)
            var cumUnits = 0;
            var labNavBets = chartData.slice(1).map(function(p) {
                cumUnits += p.pnlUnits || 0;
                return {
                    betOn: p.betOn,
                    vs: p.vs,
                    odds: p.odds,
                    pnl: p.pnlUnits,
                    cumProfit: cumUnits,
                    won: p.won,
                    tournament: p.tournament,
                    round: p.round,
                    score: p.score,
                    date: p.date
                };
            });
            labNavShow(labNavBets, null);

            // Table - sort by date descending (most recent first)
            var sortedByDate = labRes.slice().sort(function(a, b) {
                return b.date.localeCompare(a.date);
            });
            
            safeText('labCnt', '(' + labRes.length + ' paris)');
            var rows = '';
            var max = Math.min(200, sortedByDate.length); // Show up to 200 matches
            for (var i = 0; i < max; i++) {
                var r = sortedByDate[i];
                var pnlEuros = r.pnl * stake;
                // Formater le match avec les deux joueurs et leurs cotes
                var betOnCote = r.odds.toFixed(2);
                var vsCote = (r.o1 + r.o2 - r.odds).toFixed(2);
                var matchCell = '<span style="' + (r.won ? 'font-weight:600;color:var(--green)' : '') + '">' + r.betOn + '</span> <span style="color:var(--muted);font-size:.75rem">@' + betOnCote + '</span>' +
                    ' <span style="color:var(--muted)">vs</span> ' +
                    '<span style="' + (!r.won ? 'font-weight:600;color:var(--red)' : '') + '">' + r.vs + '</span> <span style="color:var(--muted);font-size:.75rem">@' + vsCote + '</span>';
                
                // Formater le score (gagnant en premier)
                var scoreDisplay = formatScore(r.score) || '-';
                
                rows += '<tr>' +
                    '<td class="mono" style="font-size:.75rem">' + r.date + '</td>' +
                    '<td style="font-size:.75rem">' + (r.tournament || '') + '</td>' +
                    '<td style="font-size:.75rem">' + r.round + '</td>' +
                    '<td style="white-space:nowrap">' + matchCell + '</td>' +
                    '<td style="font-size:.7rem;color:var(--muted)">' + scoreDisplay + '</td>' +
                    '<td>' + (r.won ? '‚úÖ' : '‚ùå') + '</td>' +
                    '<td class="mono ' + (pnlEuros >= 0 ? 'pos' : 'neg') + '" style="font-weight:600">' + (pnlEuros >= 0 ? '+' : '') + pnlEuros.toFixed(0) + '‚Ç¨</td>' +
                    '</tr>';
            }
            if (labRes.length > 200) {
                rows += '<tr><td colspan="7" style="text-align:center;color:var(--muted);font-size:.7rem">... et ' + (labRes.length - 200) + ' paris plus anciens</td></tr>';
            }
            safeHTML('labTbl', rows);
            
            // Show add niche button if ROI is positive
            if (roi > 0) {
                safeDisplay('labAddNicheBox', true);
            } else {
                safeDisplay('labAddNicheBox', false);
            }
        }

        // ==================== DETECTEUR ====================
        // Variables globales pour stocker les r√©sultats du d√©tecteur
        var detResultsU = [], detResultsS = [], detResultsM = [], detResultsL = [], detResultsDecay = [];
        
        function refreshDetectorDisplay() {
            // Re-render all detector lists with current niche status
            if (detResultsU.length > 0 || detResultsS.length > 0 || detResultsM.length > 0 || detResultsL.length > 0) {
                renderDetectorList('detUltra', detResultsU, true);
                renderDetectorList('detShort', detResultsS, true);
                renderDetectorList('detMed', detResultsM, true);
                renderDetectorList('detLong', detResultsL, true);
            }
            if (detResultsDecay.length > 0) {
                renderDecayList('detDecay', detResultsDecay);
            }
        }
        
        function runDetector() {
            var circuit = document.getElementById('detCircuit').value;
            var minROI = parseFloat(document.getElementById('detMinROI').value) || 10;
            var minVol = parseInt(document.getElementById('detMinVol').value) || 5;

            var data = [];
            if (circuit === 'atp' || circuit === 'both') {
                for (var i = 0; i < btDataATP.length; i++) data.push(btDataATP[i]);
            }
            if (circuit === 'wta' || circuit === 'both') {
                for (var i = 0; i < btDataWTA.length; i++) data.push(btDataWTA[i]);
            }

            if (data.length === 0) {
                alert('Charge les donn√©es CSV dans Backtest (mode Compare)');
                return;
            }

            var cats = circuit === 'wta' ? ['Grand Slam', 'WTA 1000', 'WTA 500', 'WTA 250'] :
                       circuit === 'atp' ? ['Grand Slam', 'Masters 1000', 'ATP 500', 'ATP 250'] :
                       ['Grand Slam', 'Masters 1000', 'ATP 500', 'ATP 250', 'WTA 1000', 'WTA 500', 'WTA 250'];
            var surfs = ['Hard', 'Clay', 'Grass'];
            var rndCombos = [['F'], ['SF'], ['QF'], ['R16'], ['R32'], ['R64'], ['R128'], ['SF', 'F'], ['QF', 'SF'], ['R16', 'QF'], ['R32', 'R64'], ['R64', 'R128']];
            var strats = ['underdog', 'favorite'];
            var oddsRngs = [[1.3, 1.7], [1.5, 2.0], [1.5, 2.5], [2.0, 2.5], [2.0, 3.0], [2.5, 3.0], [2.5, 3.5], [3.0, 3.5], [3.0, 4.0], [3.5, 4.5], [4.0, 6.0]];
            var curYear = new Date().getFullYear();

            // Build all combinations to test
            var combos = [];
            for (var ci = 0; ci < cats.length; ci++) {
                for (var si = 0; si < surfs.length; si++) {
                    for (var ri = 0; ri < rndCombos.length; ri++) {
                        for (var sti = 0; sti < strats.length; sti++) {
                            for (var oi = 0; oi < oddsRngs.length; oi++) {
                                combos.push({
                                    cat: cats[ci], surf: surfs[si], rnds: rndCombos[ri],
                                    strat: strats[sti], oMin: oddsRngs[oi][0], oMax: oddsRngs[oi][1]
                                });
                            }
                        }
                    }
                }
            }

            var totalCombos = combos.length;
            var resU = [], resS = [], resM = [], resL = [], resDecay = [];
            var progEl = document.getElementById('detProg');
            
            // Show progress bar
            progEl.innerHTML = '<div style="background:var(--border);border-radius:4px;height:8px;overflow:hidden;margin-top:.5rem"><div id="detProgBar" style="background:var(--blue);height:100%;width:0%;transition:width .2s"></div></div><div id="detProgText" style="margin-top:.25rem">0%</div>';
            
            var idx = 0;
            var chunkSize = 50; // Process 50 combos at a time
            
            function processChunk() {
                var end = Math.min(idx + chunkSize, totalCombos);
                
                for (var i = idx; i < end; i++) {
                    var c = combos[i];
                    
                    // Ultra court terme (2 ans)
                    var r2 = testCombo(data, c.cat, c.surf, c.rnds, c.strat, c.oMin, c.oMax, curYear - 2, curYear);
                    if (r2 && r2.bets >= minVol * 2 && r2.roi >= minROI) {
                        var score2 = calcConfidenceScore(r2, 2);
                        resU.push({ cat: c.cat, surf: c.surf, rnds: c.rnds, strat: c.strat, oMin: c.oMin, oMax: c.oMax, bets: r2.bets, roi: r2.roi, yrs: r2.yrs, yrsPos: r2.yrsPos, score: score2 });
                    }
                    
                    // Court terme (3 ans)
                    var r3 = testCombo(data, c.cat, c.surf, c.rnds, c.strat, c.oMin, c.oMax, curYear - 3, curYear);
                    if (r3 && r3.bets >= minVol * 3 && r3.roi >= minROI) {
                        var score3 = calcConfidenceScore(r3, 3);
                        resS.push({ cat: c.cat, surf: c.surf, rnds: c.rnds, strat: c.strat, oMin: c.oMin, oMax: c.oMax, bets: r3.bets, roi: r3.roi, yrs: r3.yrs, yrsPos: r3.yrsPos, score: score3 });
                    }
                    
                    // Moyen terme (5 ans)
                    var r5 = testCombo(data, c.cat, c.surf, c.rnds, c.strat, c.oMin, c.oMax, curYear - 5, curYear);
                    if (r5 && r5.bets >= minVol * 5 && r5.roi >= minROI) {
                        var score5 = calcConfidenceScore(r5, 5);
                        resM.push({ cat: c.cat, surf: c.surf, rnds: c.rnds, strat: c.strat, oMin: c.oMin, oMax: c.oMax, bets: r5.bets, roi: r5.roi, yrs: r5.yrs, yrsPos: r5.yrsPos, score: score5 });
                    }
                    
                    // Long terme (10 ans)
                    var r10 = testCombo(data, c.cat, c.surf, c.rnds, c.strat, c.oMin, c.oMax, curYear - 10, curYear);
                    if (r10 && r10.bets >= minVol * 10 && r10.roi >= minROI) {
                        var score10 = calcConfidenceScore(r10, 10);
                        resL.push({ cat: c.cat, surf: c.surf, rnds: c.rnds, strat: c.strat, oMin: c.oMin, oMax: c.oMax, bets: r10.bets, roi: r10.roi, yrs: r10.yrs, yrsPos: r10.yrsPos, score: score10 });
                        
                        // Decay detection
                        if (r3 && r3.roi < 0) {
                            resDecay.push({ 
                                cat: c.cat, surf: c.surf, rnds: c.rnds, strat: c.strat, oMin: c.oMin, oMax: c.oMax,
                                roiLong: r10.roi, roiRecent: r3.roi, betsLong: r10.bets, betsRecent: r3.bets
                            });
                        }
                    }
                }
                
                idx = end;
                var pct = Math.round(idx / totalCombos * 100);
                document.getElementById('detProgBar').style.width = pct + '%';
                safeText('detProgText', pct + '% (' + idx + '/' + totalCombos + ' combinaisons)');
                
                if (idx < totalCombos) {
                    setTimeout(processChunk, 10); // Small delay to let browser breathe
                } else {
                    // Done - sort and render
                    resU.sort(function(a, b) { return b.score - a.score; });
                    resS.sort(function(a, b) { return b.score - a.score; });
                    resM.sort(function(a, b) { return b.score - a.score; });
                    resL.sort(function(a, b) { return b.score - a.score; });
                    resDecay.sort(function(a, b) { return a.roiRecent - b.roiRecent; });

                    // Stocker dans les variables globales pour refresh ult√©rieur
                    detResultsU = resU.slice(0, 12);
                    detResultsS = resS.slice(0, 12);
                    detResultsM = resM.slice(0, 12);
                    detResultsL = resL.slice(0, 12);
                    detResultsDecay = resDecay.slice(0, 10);

                    renderDetectorList('detUltra', detResultsU, true);
                    renderDetectorList('detShort', detResultsS, true);
                    renderDetectorList('detMed', detResultsM, true);
                    renderDetectorList('detLong', detResultsL, true);
                    renderDecayList('detDecay', detResultsDecay);

                    progEl.innerHTML = '‚úÖ Scan termin√© ! ' + (resU.length + resS.length + resM.length + resL.length) + ' niches trouv√©es';
                }
            }
            
            setTimeout(processChunk, 10);
        }
        
        function calcConfidenceScore(result, years) {
            // Score de confiance composite (0-100)
            // Facteurs: ROI (40%), consistance ann√©es positives (30%), volume (20%), dur√©e (10%)
            
            var roiScore = Math.min(result.roi / 30 * 40, 40); // Max 40 pts, plafonn√© √† 30% ROI
            
            var consistencyPct = result.yrsPos / result.yrs;
            var consistencyScore = consistencyPct * 30; // Max 30 pts
            
            var avgBetsPerYear = result.bets / years;
            var volumeScore = Math.min(avgBetsPerYear / 15 * 20, 20); // Max 20 pts, plafonn√© √† 15 paris/an
            
            var durationScore = Math.min(years / 10 * 10, 10); // Max 10 pts
            
            return Math.round(roiScore + consistencyScore + volumeScore + durationScore);
        }
        
        function checkActiveNiches() {
            var el = document.getElementById('activeNichesCheck');
            if (!el) return; // Element doesn't exist, skip
            
            var data = btDataATP.concat(btDataWTA);
            if (data.length === 0) {
                el.innerHTML = '<div style="color:var(--muted);padding:1rem;text-align:center">Charge les donn√©es CSV dans Backtest</div>';
                return;
            }
            
            var curYear = new Date().getFullYear();
            var allNiches = [];
            
            // Collect all active niches
            for (var i = 0; i < NICHES_ATP.length; i++) {
                if (NICHES_ATP[i].on) {
                    allNiches.push({ niche: NICHES_ATP[i], circuit: 'ATP', data: btDataATP });
                }
            }
            for (var i = 0; i < NICHES_WTA.length; i++) {
                if (NICHES_WTA[i].on) {
                    allNiches.push({ niche: NICHES_WTA[i], circuit: 'WTA', data: btDataWTA });
                }
            }
            
            if (allNiches.length === 0) {
                el.innerHTML = '<div style="color:var(--muted);padding:1rem;text-align:center">Aucune niche active configur√©e</div>';
                return;
            }
            
            var html = '<div style="display:grid;gap:.5rem">';
            var healthy = 0, warning = 0, danger = 0;
            
            for (var i = 0; i < allNiches.length; i++) {
                var item = allNiches[i];
                var n = item.niche;
                
                // Test on different time periods
                var r3 = testCombo(item.data, n.cat, n.surf, n.rounds, n.strat, n.min, n.max, curYear - 3, curYear);
                var r5 = testCombo(item.data, n.cat, n.surf, n.rounds, n.strat, n.min, n.max, curYear - 5, curYear);
                var r10 = testCombo(item.data, n.cat, n.surf, n.rounds, n.strat, n.min, n.max, curYear - 10, curYear);
                var rAll = testCombo(item.data, n.cat, n.surf, n.rounds, n.strat, n.min, n.max, 2007, curYear);
                
                // Determine status
                var status, statusIcon, statusColor, statusText, bgColor;
                
                var roi3 = r3 ? r3.roi : -999;
                var roi5 = r5 ? r5.roi : -999;
                var roiAll = rAll ? rAll.roi : -999;
                
                if (roi3 >= 5 && roi5 >= 5) {
                    status = 'healthy';
                    statusIcon = '‚úÖ';
                    statusColor = 'var(--green)';
                    statusText = 'Toujours rentable';
                    bgColor = 'rgba(34,197,94,.1)';
                    healthy++;
                } else if (roi3 >= 0 || (roi3 < 0 && roi5 >= 10)) {
                    status = 'warning';
                    statusIcon = '‚ö†Ô∏è';
                    statusColor = 'var(--yellow)';
                    statusText = 'Performance en baisse';
                    bgColor = 'rgba(234,179,8,.1)';
                    warning++;
                } else {
                    status = 'danger';
                    statusIcon = '‚ùå';
                    statusColor = 'var(--red)';
                    statusText = 'Plus rentable r√©cemment';
                    bgColor = 'rgba(239,68,68,.15)';
                    danger++;
                }
                
                // Build stats display
                var statsHtml = '<div style="display:flex;gap:.75rem;margin-top:.25rem;font-size:.6rem">';
                statsHtml += '<span style="color:var(--muted)">3a: <b style="color:' + (roi3 >= 0 ? 'var(--green)' : 'var(--red)') + '">' + (r3 ? (roi3 >= 0 ? '+' : '') + roi3.toFixed(0) + '%' : 'N/A') + '</b></span>';
                statsHtml += '<span style="color:var(--muted)">5a: <b style="color:' + (roi5 >= 0 ? 'var(--green)' : 'var(--red)') + '">' + (r5 ? (roi5 >= 0 ? '+' : '') + roi5.toFixed(0) + '%' : 'N/A') + '</b></span>';
                statsHtml += '<span style="color:var(--muted)">All: <b style="color:' + (roiAll >= 0 ? 'var(--green)' : 'var(--red)') + '">' + (rAll ? (roiAll >= 0 ? '+' : '') + roiAll.toFixed(0) + '%' : 'N/A') + '</b></span>';
                if (rAll) statsHtml += '<span style="color:var(--muted)">' + rAll.bets + 'p</span>';
                statsHtml += '</div>';
                
                html += '<div style="display:flex;align-items:center;padding:.6rem;background:' + bgColor + ';border-radius:6px;border-left:3px solid ' + statusColor + '">';
                html += '<div style="flex:1;cursor:pointer" onclick="loadDetNiche(\'' + n.cat + '\',\'' + n.surf + '\',\'' + n.rounds.join(',') + '\',\'' + n.strat + '\',' + n.min + ',' + n.max + ')">';
                html += '<div style="font-size:.75rem;font-weight:600">' + statusIcon + ' ' + n.name + ' <span style="font-size:.55rem;color:var(--muted);font-weight:400">(' + item.circuit + ')</span></div>';
                html += '<div style="font-size:.6rem;color:' + statusColor + ';font-weight:600">' + statusText + '</div>';
                html += statsHtml;
                html += '</div>';
                html += '<button onclick="event.stopPropagation();toggleNicheStatus(\'' + n.id + '\',\'' + item.circuit + '\',false)" style="background:var(--red);color:#fff;border:none;padding:.4rem .6rem;border-radius:4px;font-size:.6rem;cursor:pointer;white-space:nowrap" title="D√©sactiver cette niche">üóëÔ∏è D√©sactiver</button>';
                html += '</div>';
            }
            
            html += '</div>';
            
            // Summary
            var summaryHtml = '<div style="display:flex;gap:1rem;margin-bottom:1rem;padding:.75rem;background:var(--bg);border-radius:6px">';
            summaryHtml += '<div style="text-align:center;flex:1"><div style="font-size:1.2rem;font-weight:700;color:var(--green)">' + healthy + '</div><div style="font-size:.6rem;color:var(--muted)">Saines</div></div>';
            summaryHtml += '<div style="text-align:center;flex:1"><div style="font-size:1.2rem;font-weight:700;color:var(--yellow)">' + warning + '</div><div style="font-size:.6rem;color:var(--muted)">√Ä surveiller</div></div>';
            summaryHtml += '<div style="text-align:center;flex:1"><div style="font-size:1.2rem;font-weight:700;color:var(--red)">' + danger + '</div><div style="font-size:.6rem;color:var(--muted)">En danger</div></div>';
            summaryHtml += '</div>';
            
            var el = document.getElementById('activeNichesCheck');
            if (el) el.innerHTML = summaryHtml + html;
        }
        
        function toggleNicheStatus(nicheId, circuit, newStatus) {
            // Normalize circuit to uppercase for comparison
            var circuitUpper = circuit.toUpperCase();
            var niches = circuitUpper === 'ATP' ? NICHES_ATP : NICHES_WTA;
            var found = false;
            
            for (var i = 0; i < niches.length; i++) {
                if (niches[i].id === nicheId) {
                    niches[i].on = newStatus;
                    found = true;
                    console.log('Niche trouv√©e et modifi√©e:', nicheId, '-> on:', newStatus);
                    break;
                }
            }
            
            if (!found) {
                console.log('Niche non trouv√©e:', nicheId, 'dans circuit:', circuitUpper);
                // Try the other circuit just in case
                var otherNiches = circuitUpper === 'ATP' ? NICHES_WTA : NICHES_ATP;
                for (var i = 0; i < otherNiches.length; i++) {
                    if (otherNiches[i].id === nicheId) {
                        otherNiches[i].on = newStatus;
                        found = true;
                        console.log('Niche trouv√©e dans autre circuit:', nicheId);
                        break;
                    }
                }
            }
            
            // Re-render EVERYTHING dynamically
            syncAllNichesUI();
            
            var action = newStatus ? 'activ√©e' : 'd√©sactiv√©e';
            console.log('Action:', action, 'pour niche', nicheId);
        }
        
        // Fonction centrale pour synchroniser toute l'UI quand les niches changent
        function syncAllNichesUI() {
            // Sauvegarder les niches √† chaque changement
            saveNiches();
            
            // Mettre √† jour tous les composants UI avec try-catch pour √©viter les erreurs
            try { if (typeof renderNichesList === 'function') renderNichesList(); } catch(e) {}
            try { if (typeof renderNichesInLab === 'function') renderNichesInLab(); } catch(e) {}
            try { if (typeof renderActiveNiches === 'function') renderActiveNiches(); } catch(e) {}
            try { if (typeof renderCalendar === 'function') renderCalendar(); } catch(e) {}
            try { if (typeof updateProjections === 'function') updateProjections(); } catch(e) {}
            try { if (typeof updateProjectionDisplay === 'function') updateProjectionDisplay(); } catch(e) {}
            try { if (typeof checkWeekTournaments === 'function') checkWeekTournaments(); } catch(e) {}
            try { if (typeof refreshDetectorDisplay === 'function') refreshDetectorDisplay(); } catch(e) {}
            try { if (typeof checkActiveNiches === 'function') checkActiveNiches(); } catch(e) {}
            try { if (typeof updateSimNichesSummary === 'function') updateSimNichesSummary(); } catch(e) {}
            try { if (typeof onConfigChange === 'function') onConfigChange(); } catch(e) {}
            // Refresh detector v2 si des r√©sultats existent
            try {
                if (typeof renderDetectorV2Results === 'function' && typeof detV2Results !== 'undefined' && detV2Results.length > 0) {
                    renderDetectorV2Results();
                    if (typeof checkActiveNichesWarnings === 'function') checkActiveNichesWarnings();
                }
            } catch(e) {}
        }
        
        // Toast notification avec boutons d'action
        function showToast(message, type, actions) {
            var existing = document.getElementById('toast-notification');
            if (existing) existing.remove();
            
            var toast = document.createElement('div');
            toast.id = 'toast-notification';
            toast.style.cssText = 'position:fixed;bottom:2rem;right:2rem;background:var(--card);border:1px solid ' + 
                (type === 'success' ? 'var(--green)' : type === 'error' ? 'var(--red)' : 'var(--border)') + 
                ';border-radius:12px;padding:1rem 1.5rem;box-shadow:0 4px 20px rgba(0,0,0,.3);z-index:10000;max-width:400px;animation:slideIn .3s ease';
            
            var html = '<div style="display:flex;align-items:center;gap:.75rem;margin-bottom:' + (actions && actions.length ? '.75rem' : '0') + '">';
            html += '<span style="font-size:1.2rem">' + (type === 'success' ? '‚úÖ' : type === 'error' ? '‚ùå' : '‚ÑπÔ∏è') + '</span>';
            html += '<span style="flex:1">' + message + '</span>';
            html += '<button onclick="this.parentElement.parentElement.remove()" style="background:none;border:none;color:var(--muted);cursor:pointer;font-size:1.2rem">√ó</button>';
            html += '</div>';
            
            if (actions && actions.length) {
                html += '<div style="display:flex;gap:.5rem;justify-content:flex-end">';
                actions.forEach(function(a) {
                    html += '<button onclick="document.getElementById(\'toast-notification\').remove();(' + a.action.toString() + ')()" style="background:var(--bg);border:1px solid var(--border);color:var(--text);padding:.4rem .8rem;border-radius:6px;font-size:.8rem;cursor:pointer">' + a.label + '</button>';
                });
                html += '</div>';
            }
            
            toast.innerHTML = html;
            document.body.appendChild(toast);
            
            // Auto-dismiss apr√®s 5s
            setTimeout(function() {
                if (document.getElementById('toast-notification')) {
                    toast.style.opacity = '0';
                    toast.style.transform = 'translateX(100%)';
                    setTimeout(function() { toast.remove(); }, 300);
                }
            }, 5000);
        }
        
        // Supprimer d√©finitivement une niche (pas juste d√©sactiver)
        function deleteNichePermanently(nicheId, circuit) {
            var circuitLower = circuit.toLowerCase();
            var niches = circuitLower === 'atp' ? NICHES_ATP : NICHES_WTA;
            
            for (var i = niches.length - 1; i >= 0; i--) {
                if (niches[i].id === nicheId) {
                    niches.splice(i, 1);
                    console.log('Niche supprim√©e d√©finitivement:', nicheId);
                    saveNiches();
                    syncAllNichesUI();
                    return true;
                }
            }
            
            // Chercher dans l'autre circuit au cas o√π
            var otherNiches = circuitLower === 'atp' ? NICHES_WTA : NICHES_ATP;
            for (var i = otherNiches.length - 1; i >= 0; i--) {
                if (otherNiches[i].id === nicheId) {
                    otherNiches.splice(i, 1);
                    console.log('Niche supprim√©e d√©finitivement (autre circuit):', nicheId);
                    saveNiches();
                    syncAllNichesUI();
                    return true;
                }
            }
            
            console.warn('Niche non trouv√©e pour suppression:', nicheId, circuit);
            return false;
        }
        
        function quickAddNiche(cat, surf, rnds, strat, oMin, oMax, circuit) {
            // Generate name
            var stratLabel = strat === 'underdog' ? 'UND' : 'FAV';
            var catLabel = cat.replace('Masters 1000', 'M1000').replace('Grand Slam', 'GS').replace('WTA ', 'W').replace('ATP ', '');
            var rndsArr = typeof rnds === 'string' ? rnds.split(',') : rnds;
            
            // Determine circuit - use explicit parameter if provided, otherwise guess from category
            if (!circuit) {
                circuit = 'atp';
                if (cat.indexOf('WTA') >= 0) circuit = 'wta';
            }
            
            // Add circuit prefix to name for clarity
            var circuitPrefix = circuit === 'wta' ? 'WTA ' : 'ATP ';
            var name = circuitPrefix + stratLabel + ' ' + catLabel + ' ' + surf + ' ' + rndsArr.join('+') + ' @' + oMin + '-' + oMax;
            
            // Check for duplicate
            var targetArray = circuit === 'atp' ? NICHES_ATP : NICHES_WTA;
            for (var i = 0; i < targetArray.length; i++) {
                if (targetArray[i].name === name) {
                    showToast('‚ö†Ô∏è Niche d√©j√† existante: ' + name, 'warning');
                    return;
                }
            }
            
            // Create niche object
            var nicheId = 'quick_' + Date.now();
            var niche = {
                id: nicheId,
                name: name,
                cat: cat,
                surf: surf,
                rounds: rndsArr,
                strat: strat,
                min: oMin,
                max: oMax,
                on: true
            };
            
            // Add to appropriate array
            if (circuit === 'atp') {
                NICHES_ATP.push(niche);
            } else {
                NICHES_WTA.push(niche);
            }
            
            console.log('Added niche to', circuit.toUpperCase(), ':', name);
            
            // Re-render everything dynamically
            syncAllNichesUI();
            
            // Notification avec liens
            showToast('‚úÖ Niche ajout√©e (' + circuit.toUpperCase() + '): ' + name, 'success', [
                { label: 'üéØ Mes Niches', action: function() { showMainTab('lab'); setLabMode('niches'); } },
                { label: 'üé∞ Simuler', action: function() { showMainTab('simulator'); } }
            ]);
        }

        function testCombo(data, cat, surf, rnds, strat, oMin, oMax, yFrom, yTo) {
            var filtered = [];
            for (var i = 0; i < data.length; i++) {
                var m = data[i];
                if (m.year < yFrom || m.year > yTo) continue;
                if (!m.category) continue;
                var catKey = cat.replace('Masters ', '').replace('WTA ', '').replace('Grand Slam', 'Grand');
                if (m.category.indexOf(catKey) < 0) continue;
                if (m.surface !== surf) continue;
                var foundRnd = false;
                for (var j = 0; j < rnds.length; j++) {
                    if (m.round === rnds[j]) { foundRnd = true; break; }
                }
                if (!foundRnd) continue;
                filtered.push(m);
            }

            if (filtered.length < 5) return null;

            var results = [];
            var seen = {};
            for (var i = 0; i < filtered.length; i++) {
                var m = filtered[i];
                var key = m.date + m.p1 + m.p2;
                if (seen[key]) continue;

                var dO = Math.max(m.o1, m.o2);
                var fO = Math.min(m.o1, m.o2);
                var dP1 = m.o1 > m.o2;
                var odds = strat === 'underdog' ? dO : fO;
                var won = strat === 'underdog' ? dP1 : !dP1;

                if (odds >= oMin && odds <= oMax) {
                    results.push({ year: m.year, won: won, pnl: won ? odds - 1 : -1 });
                    seen[key] = true;
                }
            }

            if (results.length < 5) return null;

            var wins = 0, pnl = 0;
            for (var i = 0; i < results.length; i++) {
                if (results[i].won) wins++;
                pnl += results[i].pnl;
            }
            var roi = pnl / results.length * 100;

            var byY = {};
            for (var i = 0; i < results.length; i++) {
                var r = results[i];
                if (!byY[r.year]) byY[r.year] = 0;
                byY[r.year] += r.pnl;
            }
            var yrs = Object.keys(byY);
            var yrsPos = 0;
            for (var i = 0; i < yrs.length; i++) {
                if (byY[yrs[i]] > 0) yrsPos++;
            }

            return { bets: results.length, wins: wins, roi: roi, yrs: yrs.length, yrsPos: yrsPos };
        }
        
        function isNicheActive(cat, surf, rnds, strat, oMin, oMax) {
            // Check if this EXACT niche is already active
            var allNiches = NICHES_ATP.concat(NICHES_WTA);
            var rndsArr = typeof rnds === 'string' ? rnds.split(',') : rnds;
            
            for (var i = 0; i < allNiches.length; i++) {
                var n = allNiches[i];
                if (!n.on) continue;
                if (n.cat !== cat) continue;
                if (n.surf !== surf) continue;
                if (n.strat !== strat) continue;
                
                // Exact odds range match (with small tolerance for rounding)
                if (Math.abs(n.min - oMin) > 0.1) continue;
                if (Math.abs(n.max - oMax) > 0.1) continue;
                
                // Exact rounds match (same rounds, same order not required)
                if (n.rounds.length !== rndsArr.length) continue;
                var allRoundsMatch = true;
                for (var j = 0; j < rndsArr.length; j++) {
                    if (n.rounds.indexOf(rndsArr[j]) < 0) { 
                        allRoundsMatch = false; 
                        break; 
                    }
                }
                if (!allRoundsMatch) continue;
                
                return n.name;
            }
            return null;
        }
        
        // Version √©tendue qui retourne l'objet niche complet avec ID et circuit
        function getActiveNicheInfo(cat, surf, rnds, strat, oMin, oMax) {
            var rndsArr = typeof rnds === 'string' ? rnds.split(',') : rnds;
            
            // Chercher dans ATP
            for (var i = 0; i < NICHES_ATP.length; i++) {
                var n = NICHES_ATP[i];
                if (!n.on) continue;
                if (n.cat !== cat || n.surf !== surf || n.strat !== strat) continue;
                if (Math.abs(n.min - oMin) > 0.1 || Math.abs(n.max - oMax) > 0.1) continue;
                if (n.rounds.length !== rndsArr.length) continue;
                
                var allRoundsMatch = true;
                for (var j = 0; j < rndsArr.length; j++) {
                    if (n.rounds.indexOf(rndsArr[j]) < 0) { allRoundsMatch = false; break; }
                }
                if (allRoundsMatch) return { id: n.id, name: n.name, circuit: 'ATP' };
            }
            
            // Chercher dans WTA
            for (var i = 0; i < NICHES_WTA.length; i++) {
                var n = NICHES_WTA[i];
                if (!n.on) continue;
                if (n.cat !== cat || n.surf !== surf || n.strat !== strat) continue;
                if (Math.abs(n.min - oMin) > 0.1 || Math.abs(n.max - oMax) > 0.1) continue;
                if (n.rounds.length !== rndsArr.length) continue;
                
                var allRoundsMatch = true;
                for (var j = 0; j < rndsArr.length; j++) {
                    if (n.rounds.indexOf(rndsArr[j]) < 0) { allRoundsMatch = false; break; }
                }
                if (allRoundsMatch) return { id: n.id, name: n.name, circuit: 'WTA' };
            }
            
            return null;
        }
        
        // Handler centralis√© pour les actions sur les niches
        function handleNicheAction(btn, action) {
            var cat = btn.getAttribute('data-cat');
            var surf = btn.getAttribute('data-surf');
            var rnds = btn.getAttribute('data-rnds');
            var strat = btn.getAttribute('data-strat');
            var oMin = parseFloat(btn.getAttribute('data-omin'));
            var oMax = parseFloat(btn.getAttribute('data-omax'));
            var circuit = btn.getAttribute('data-circuit');
            var nicheId = btn.getAttribute('data-id');
            var circuitDelete = btn.getAttribute('data-circuit-delete');
            
            console.log('handleNicheAction:', action, 'circuit:', circuit, cat, surf, rnds, strat, oMin, oMax);
            
            switch(action) {
                case 'add':
                    quickAddNiche(cat, surf, rnds, strat, oMin, oMax, circuit);
                    break;
                    
                case 'swap':
                    smartAddNiche(cat, surf, rnds, strat, oMin, oMax, 0, circuit);
                    break;
                    
                case 'disable':
                    if (nicheId) {
                        toggleNicheStatus(nicheId, circuitDelete || circuit, false);
                        // Force refresh
                        if (typeof renderDetectorV2Results === 'function') renderDetectorV2Results();
                    }
                    break;
                    
                case 'delete':
                    if (nicheId && confirm('Supprimer d√©finitivement cette niche ?')) {
                        deleteNichePermanently(nicheId, circuitDelete || circuit);
                    }
                    break;
            }
        }

        // Fonction pour trouver les niches actives qui chevauchent une niche candidate
        function findOverlappingNiches(cat, surf, rnds, strat, oMin, oMax) {
            var overlapping = [];
            var allNiches = NICHES_ATP.concat(NICHES_WTA);
            
            for (var i = 0; i < allNiches.length; i++) {
                var n = allNiches[i];
                if (!n.on) continue;
                if (n.cat !== cat) continue;
                if (n.surf !== surf) continue;
                if (n.strat !== strat) continue;
                
                // V√©rifier si les rounds se chevauchent
                var roundsOverlap = false;
                for (var r = 0; r < rnds.length; r++) {
                    if (n.rounds.indexOf(rnds[r]) >= 0) {
                        roundsOverlap = true;
                        break;
                    }
                }
                if (!roundsOverlap) continue;
                
                // V√©rifier si les cotes se chevauchent
                var oddsOverlap = !(oMax < n.min || oMin > n.max);
                if (!oddsOverlap) continue;
                
                // Cette niche chevauche !
                overlapping.push(n);
            }
            
            return overlapping;
        }
        
        // Fonction pour ajouter une niche avec gestion des chevauchements
        function smartAddNiche(cat, surf, rnds, strat, oMin, oMax, newRoi, circuit) {
            var rndsArr = typeof rnds === 'string' ? rnds.split(',') : rnds;
            var overlapping = findOverlappingNiches(cat, surf, rndsArr, strat, oMin, oMax);
            
            if (overlapping.length > 0) {
                var msg = '‚ö†Ô∏è Cette niche chevauche ' + overlapping.length + ' niche(s) active(s):\n\n';
                for (var i = 0; i < overlapping.length; i++) {
                    msg += '‚Ä¢ ' + overlapping[i].name + '\n';
                }
                msg += '\nVoulez-vous REMPLACER les niches existantes par celle-ci ?';
                
                if (confirm(msg)) {
                    // Supprimer les niches chevauchantes
                    for (var i = 0; i < overlapping.length; i++) {
                        var toRemove = overlapping[i];
                        // Trouver et supprimer dans ATP
                        for (var j = NICHES_ATP.length - 1; j >= 0; j--) {
                            if (NICHES_ATP[j].id === toRemove.id) {
                                NICHES_ATP.splice(j, 1);
                                break;
                            }
                        }
                        // Trouver et supprimer dans WTA
                        for (var j = NICHES_WTA.length - 1; j >= 0; j--) {
                            if (NICHES_WTA[j].id === toRemove.id) {
                                NICHES_WTA.splice(j, 1);
                                break;
                            }
                        }
                    }
                    // Ajouter la nouvelle niche avec le bon circuit
                    quickAddNiche(cat, surf, rndsArr, strat, oMin, oMax, circuit);
                }
            } else {
                // Pas de chevauchement, ajouter directement avec le bon circuit
                quickAddNiche(cat, surf, rndsArr, strat, oMin, oMax, circuit);
            }
        }

        function renderDetectorList(elId, results, showScore) {
            var el = document.getElementById(elId);
            if (!el) return; // Element doesn't exist, skip
            
            if (results.length === 0) {
                el.innerHTML = '<div style="color:var(--muted);font-size:.7rem;padding:.5rem">Aucune niche trouv√©e avec ces crit√®res</div>';
                return;
            }

            // Fonction pour v√©rifier si deux niches se chevauchent entre elles
            function nichesOverlap(n1, n2) {
                if (n1.cat !== n2.cat) return false;
                if (n1.surf !== n2.surf) return false;
                if (n1.strat !== n2.strat) return false;
                
                // Rounds overlap?
                var roundsOverlap = false;
                for (var r = 0; r < n1.rnds.length; r++) {
                    if (n2.rnds.indexOf(n1.rnds[r]) >= 0) {
                        roundsOverlap = true;
                        break;
                    }
                }
                if (!roundsOverlap) return false;
                
                // Odds overlap?
                var oddsOverlap = !(n1.oMax < n2.oMin || n1.oMin > n2.oMax);
                return oddsOverlap;
            }
            
            // Grouper les niches qui se chevauchent (Union-Find simplifi√©)
            var groups = [];
            var assigned = [];
            for (var i = 0; i < results.length; i++) assigned[i] = false;
            
            for (var i = 0; i < results.length; i++) {
                if (assigned[i]) continue;
                
                var group = [results[i]];
                assigned[i] = true;
                
                // Trouver toutes les niches qui chevauchent ce groupe
                var changed = true;
                while (changed) {
                    changed = false;
                    for (var j = 0; j < results.length; j++) {
                        if (assigned[j]) continue;
                        
                        // V√©rifier si cette niche chevauche une niche du groupe
                        for (var k = 0; k < group.length; k++) {
                            if (nichesOverlap(results[j], group[k])) {
                                group.push(results[j]);
                                assigned[j] = true;
                                changed = true;
                                break;
                            }
                        }
                    }
                }
                
                // Trier le groupe par ROI d√©croissant
                group.sort(function(a, b) { return b.roi - a.roi; });
                groups.push(group);
            }
            
            // Trier les groupes par meilleur ROI du groupe
            groups.sort(function(a, b) { return b[0].roi - a[0].roi; });

            var html = '';
            var groupColors = ['var(--green)', 'var(--blue)', 'var(--purple)', 'var(--yellow)', 'var(--red)', 'var(--cyan)'];
            
            for (var g = 0; g < groups.length; g++) {
                var group = groups[g];
                var groupColor = groupColors[g % groupColors.length];
                
                // Header de groupe si plusieurs niches
                if (group.length > 1) {
                    html += '<div style="background:' + groupColor + '22;padding:.3rem .5rem;font-size:.55rem;font-weight:600;border-left:3px solid ' + groupColor + ';margin-top:' + (g > 0 ? '.5rem' : '0') + '">';
                    html += 'üîó Groupe ' + (g + 1) + ' - ' + group.length + ' niches similaires (m√™me zone)';
                    html += '</div>';
                }
                
                for (var i = 0; i < group.length; i++) {
                    var n = group[i];
                    var nm = (n.strat === 'underdog' ? 'UND' : 'FAV') + ' ' + n.cat.replace('Masters ', 'M').replace('Grand Slam', 'GS') + ' ' + n.surf + ' ' + n.rnds.join('+') + ' @' + n.oMin + '-' + n.oMax;
                    
                    // Check if already active
                    var activeName = isNicheActive(n.cat, n.surf, n.rnds, n.strat, n.oMin, n.oMax);
                    var activeBadge = activeName ? '<span style="font-size:.45rem;background:var(--blue);color:#000;padding:1px 3px;border-radius:2px;margin-left:3px">‚úì ACTIVE</span>' : '';
                    
                    // Rank badge dans le groupe
                    var rankBadge = '';
                    if (group.length > 1) {
                        if (i === 0) {
                            rankBadge = '<span style="font-size:.45rem;background:gold;color:#000;padding:1px 3px;border-radius:2px;margin-left:3px">ü•á BEST</span>';
                        } else if (i === 1) {
                            rankBadge = '<span style="font-size:.45rem;background:silver;color:#000;padding:1px 3px;border-radius:2px;margin-left:3px">ü•à</span>';
                        } else if (i === 2) {
                            rankBadge = '<span style="font-size:.45rem;background:#cd7f32;color:#fff;padding:1px 3px;border-radius:2px;margin-left:3px">ü•â</span>';
                        } else {
                            rankBadge = '<span style="font-size:.45rem;background:var(--muted);color:#fff;padding:1px 3px;border-radius:2px;margin-left:3px">#' + (i + 1) + '</span>';
                        }
                    }
                    
                    // Check for overlapping with ACTIVE niches
                    var overlapping = findOverlappingNiches(n.cat, n.surf, n.rnds, n.strat, n.oMin, n.oMax);
                    var overlapInfo = '';
                    if (overlapping.length > 0 && !activeName) {
                        var overlapNames = overlapping.map(function(o) { return o.rounds.join('+') + '@' + o.min + '-' + o.max; }).join(', ');
                        overlapInfo = '<div style="font-size:.45rem;color:var(--yellow);margin-top:1px">‚ö†Ô∏è Chevauche: ' + overlapNames + '</div>';
                    }
                    
                    // Score badge
                    var scoreColor = n.score >= 70 ? 'var(--green)' : n.score >= 50 ? 'var(--yellow)' : 'var(--muted)';
                    var scoreBadge = showScore && n.score ? '<span style="font-size:.5rem;background:' + scoreColor + ';color:#000;padding:1px 4px;border-radius:3px;margin-left:4px">' + n.score + '</span>' : '';
                    
                    // Add button
                    var addBtn = '';
                    if (!activeName) {
                        if (overlapping.length > 0) {
                            addBtn = '<button onclick="event.stopPropagation();smartAddNiche(\'' + n.cat + '\',\'' + n.surf + '\',\'' + n.rnds.join(',') + '\',\'' + n.strat + '\',' + n.oMin + ',' + n.oMax + ',' + n.roi + ',\'' + n.circuit + '\')" style="background:var(--yellow);color:#000;border:none;padding:.25rem .4rem;border-radius:3px;font-size:.55rem;cursor:pointer;margin-left:.5rem" title="Remplacer la niche existante">üîÑ</button>';
                        } else {
                            addBtn = '<button onclick="event.stopPropagation();quickAddNiche(\'' + n.cat + '\',\'' + n.surf + '\',\'' + n.rnds.join(',') + '\',\'' + n.strat + '\',' + n.oMin + ',' + n.oMax + ',\'' + n.circuit + '\')" style="background:var(--green);color:#000;border:none;padding:.25rem .4rem;border-radius:3px;font-size:.55rem;cursor:pointer;margin-left:.5rem" title="Ajouter cette niche">‚ûï</button>';
                        }
                    }
                    
                    // Diff avec le best du groupe
                    var diffBadge = '';
                    if (group.length > 1 && i > 0) {
                        var diff = n.roi - group[0].roi;
                        diffBadge = '<span style="font-size:.45rem;color:var(--red);margin-left:3px">(' + diff.toFixed(0) + '%)</span>';
                    }
                    
                    var bgColor = activeName ? 'rgba(59,130,246,.1)' : (group.length > 1 ? groupColor + '11' : '');
                    var borderLeft = group.length > 1 ? 'border-left:3px solid ' + groupColor + ';' : '';
                    
                    html += '<div style="display:flex;align-items:center;padding:.4rem;border-bottom:1px solid var(--border);background:' + bgColor + ';' + borderLeft + '">' +
                        '<div style="flex:1;cursor:pointer" onclick="loadDetNiche(\'' + n.cat + '\',\'' + n.surf + '\',\'' + n.rnds.join(',') + '\',\'' + n.strat + '\',' + n.oMin + ',' + n.oMax + ')">' +
                        '<div style="font-size:.65rem">' + nm + activeBadge + rankBadge + scoreBadge + '</div>' +
                        '<div style="font-size:.5rem;color:var(--muted)">' + n.bets + 'p ‚Ä¢ ' + n.yrsPos + '/' + n.yrs + ' ans+</div>' + overlapInfo + '</div>' +
                        '<span style="font-weight:700;color:var(--green);font-size:.8rem">+' + n.roi.toFixed(0) + '%' + diffBadge + '</span>' + addBtn + '</div>';
                }
            }
            el.innerHTML = html;
        }
        
        function renderDecayList(elId, results) {
            var el = document.getElementById(elId);
            if (!el) return; // Element doesn't exist, skip
            
            if (results.length === 0) {
                el.innerHTML = '<div style="color:var(--muted);font-size:.7rem;padding:.5rem">‚úÖ Aucune niche en d√©clin d√©tect√©e</div>';
                return;
            }

            var html = '';
            for (var i = 0; i < results.length; i++) {
                var n = results[i];
                var nm = (n.strat === 'underdog' ? 'UND' : 'FAV') + ' ' + n.cat.replace('Masters ', 'M').replace('Grand Slam', 'GS') + ' ' + n.surf + ' ' + n.rnds.join('+') + ' @' + n.oMin + '-' + n.oMax;
                
                // Check if active - this is a WARNING
                var activeName = isNicheActive(n.cat, n.surf, n.rnds, n.strat, n.oMin, n.oMax);
                var warningBadge = activeName ? '<div style="background:var(--red);color:#fff;padding:2px 6px;border-radius:3px;font-size:.55rem;margin-top:3px">‚ö†Ô∏è DANGER: Cette niche est dans vos strat√©gies actives !</div>' : '';
                var bgColor = activeName ? 'rgba(239,68,68,.2)' : 'rgba(239,68,68,.05)';
                
                html += '<div style="display:flex;align-items:center;padding:.4rem;border-bottom:1px solid var(--border);cursor:pointer;background:' + bgColor + '" onclick="loadDetNiche(\'' + n.cat + '\',\'' + n.surf + '\',\'' + n.rnds.join(',') + '\',\'' + n.strat + '\',' + n.oMin + ',' + n.oMax + ')">' +
                    '<div style="flex:1"><div style="font-size:.65rem">üíÄ ' + nm + '</div><div style="font-size:.5rem;color:var(--muted)">' + n.betsLong + 'p (10a) ‚Üí ' + n.betsRecent + 'p (3a)</div>' + warningBadge + '</div>' +
                    '<div style="text-align:right"><div style="font-weight:700;color:var(--green);font-size:.7rem">+' + n.roiLong.toFixed(0) + '%</div><div style="font-weight:700;color:var(--red);font-size:.7rem">' + n.roiRecent.toFixed(0) + '%</div></div></div>';
            }
            el.innerHTML = html;
        }

        function loadDetNiche(cat, surf, rnds, strat, oMin, oMax, circuit) {
            console.log('loadDetNiche called:', { cat, surf, rnds, strat, oMin, oMax, circuit });
            
            // Set circuit if provided (detect from category name if not)
            if (!circuit) {
                // Detect from category
                if (cat.indexOf('WTA') >= 0) {
                    circuit = 'wta';
                } else {
                    circuit = 'atp';
                }
            }
            document.getElementById('labCircuit').value = circuit;
            
            // IMPORTANT: Appeler updateLabCategories AVANT de d√©finir les s√©lections
            // car cette fonction r√©initialise labSelCats √† []
            updateLabCategories();
            
            // MAINTENANT on peut d√©finir les s√©lections
            labSelCats = [cat];
            labSelSurfs = [surf];
            labSelRounds = rnds.split(',');
            
            console.log('Selections set:', { labSelCats, labSelSurfs, labSelRounds, oMin, oMax });
            
            // Update toggle buttons visually (APR√àS updateLabCategories qui recr√©e les boutons)
            updateToggleButtons('labCatsBox', labSelCats);
            updateToggleButtons('labSurfsBox', labSelSurfs);
            updateToggleButtons('labRoundsBox', labSelRounds);
            
            // Force update inputs
            var oddsMinInput = document.getElementById('labOddsMin');
            var oddsMaxInput = document.getElementById('labOddsMax');
            var stratInput = document.getElementById('labStrategy');
            var yearFromInput = document.getElementById('labYearFrom');
            var yearToInput = document.getElementById('labYearTo');
            
            if (oddsMinInput) {
                oddsMinInput.value = oMin;
                oddsMinInput.setAttribute('value', oMin);
            }
            if (oddsMaxInput) {
                oddsMaxInput.value = oMax;
                oddsMaxInput.setAttribute('value', oMax);
            }
            if (stratInput) {
                stratInput.value = strat;
            }
            if (yearFromInput) {
                yearFromInput.value = 2007;
            }
            if (yearToInput) {
                yearToInput.value = new Date().getFullYear();
            }
            
            console.log('Final state before test:', {
                labSelCats, labSelSurfs, labSelRounds,
                oddsMin: oddsMinInput ? oddsMinInput.value : 'NOT FOUND',
                oddsMax: oddsMaxInput ? oddsMaxInput.value : 'NOT FOUND'
            });
            
            setLabMode('playground');
            
            // Lancer le test
            setTimeout(function() {
                runLabTest();
            }, 100);
        }
        
        function updateToggleButtons(boxId, selectedValues) {
            console.log('updateToggleButtons:', boxId, selectedValues);
            var box = document.getElementById(boxId);
            if (!box) {
                console.log('Box not found:', boxId);
                return;
            }
            var buttons = box.getElementsByClassName('toggle-btn');
            console.log('Found', buttons.length, 'buttons in', boxId);
            
            for (var i = 0; i < buttons.length; i++) {
                var btn = buttons[i];
                var btnText = btn.textContent.trim();
                // Map display text back to value
                var value = btnText;
                if (btnText === 'GS') value = 'Grand Slam';
                else if (btnText === 'M1000') value = 'Masters 1000';
                else if (btnText === 'W1000') value = 'WTA 1000';
                
                var shouldBeActive = selectedValues.indexOf(value) >= 0 || selectedValues.indexOf(btnText) >= 0;
                console.log('Button:', btnText, '-> value:', value, '| selected:', selectedValues, '| shouldBeActive:', shouldBeActive);
                
                if (shouldBeActive) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            }
        }

        // ==================== DETECTOR V2 - SCORE COMPOSITE ====================
        var detV2Results = [];
        var detV2CurrentFilter = 'all';
        var detV2CurrentSort = 'score';
        var detV2GroupSimilar = true;
        
        function runDetectorV2() {
            var circuit = document.getElementById('detCircuit').value;
            var minROI = parseFloat(document.getElementById('detMinROI').value);
            var minVol = parseFloat(document.getElementById('detMinVol').value);
            var period = document.getElementById('detPeriod').value;
            
            var dataToUse = [];
            if (circuit === 'atp' || circuit === 'both') dataToUse = dataToUse.concat(btDataATP.map(function(m) { return Object.assign({}, m, {circuit: 'atp'}); }));
            if (circuit === 'wta' || circuit === 'both') dataToUse = dataToUse.concat(btDataWTA.map(function(m) { return Object.assign({}, m, {circuit: 'wta'}); }));
            
            if (dataToUse.length === 0) {
                safeHTML('detProgV2', '<span style="color:var(--red)">‚ùå Charge d\'abord les donn√©es CSV dans Backtest</span>');
                return;
            }
            
            var curYear = new Date().getFullYear();
            var startYear = period === 'all' ? 2007 : curYear - parseInt(period);
            
            // Cat√©gories selon circuit
            var catsATP = ['Grand Slam', 'Masters 1000', 'ATP 500', 'ATP 250'];
            var catsWTA = ['Grand Slam', 'WTA 1000', 'WTA 500', 'WTA 250'];
            var surfs = ['Hard', 'Clay', 'Grass'];
            var strats = ['underdog', 'favorite'];
            var oddsRanges = [[1.5,2.5], [2.0,3.0], [2.5,4.0], [3.0,5.0], [4.0,7.0], [1.2,1.5], [1.3,1.7], [1.5,2.0]];
            var roundSets = [['F'], ['SF'], ['QF'], ['R16'], ['R32'], ['R64'], ['R128'], ['F','SF'], ['QF','R16'], ['SF','QF'], ['R16','R32'], ['R32','R64'], ['R64','R128']];
            
            // Construire toutes les combinaisons
            var combos = [];
            ['atp', 'wta'].forEach(function(c) {
                if (circuit !== 'both' && circuit !== c) return;
                var cats = c === 'atp' ? catsATP : catsWTA;
                cats.forEach(function(cat) {
                    surfs.forEach(function(surf) {
                        roundSets.forEach(function(rnds) {
                            strats.forEach(function(strat) {
                                oddsRanges.forEach(function(odds) {
                                    combos.push({circuit: c, cat: cat, surf: surf, rnds: rnds, strat: strat, oMin: odds[0], oMax: odds[1]});
                                });
                            });
                        });
                    });
                });
            });
            
            var progEl = document.getElementById('detProgV2');
            progEl.innerHTML = '<div style="background:var(--border);border-radius:4px;height:8px;overflow:hidden;margin-top:.5rem"><div id="detProgBarV2" style="height:100%;background:linear-gradient(90deg,var(--green),var(--blue));width:0%;transition:width .2s"></div></div><div id="detProgTextV2" style="margin-top:.5rem">0%</div>';
            
            var results = [];
            var idx = 0;
            var totalCombos = combos.length;
            
            function processChunk() {
                var end = Math.min(idx + 50, totalCombos);
                
                while (idx < end) {
                    var c = combos[idx];
                    var circuitData = c.circuit === 'atp' ? btDataATP : btDataWTA;
                    
                    // Test complet sur toute la p√©riode
                    var rFull = testComboV2(circuitData, c.cat, c.surf, c.rnds, c.strat, c.oMin, c.oMax, startYear, curYear);
                    
                    if (rFull && rFull.roi >= minROI && rFull.bets >= minVol * rFull.yrs) {
                        // Tests sur diff√©rentes p√©riodes pour le score
                        var r3 = testComboV2(circuitData, c.cat, c.surf, c.rnds, c.strat, c.oMin, c.oMax, curYear - 3, curYear);
                        var r5 = testComboV2(circuitData, c.cat, c.surf, c.rnds, c.strat, c.oMin, c.oMax, curYear - 5, curYear);
                        
                        // Calculer le score composite avec donn√©es annuelles
                        var scoreData = calcCompositeScore(rFull, r3, r5, rFull.yearlyData, totalCombos);

                        // === VERIFIER SI LES ROUNDS SONT ACTIFS ===
                        var inactiveRounds = [];
                        for (var ri = 0; ri < c.rnds.length; ri++) {
                            var rnd = c.rnds[ri];
                            if (!isRoundActiveForCategory(c.cat, rnd)) {
                                inactiveRounds.push(rnd);
                            }
                        }

                        if (inactiveRounds.length > 0) {
                            // V√©rifier s'il y a des exceptions (tournois sp√©cifiques)
                            var exceptions = getTournamentsForCombo(c.cat, c.surf, inactiveRounds[0]);
                            if (exceptions.length > 0) {
                                scoreData.warnings.push('‚ö†Ô∏è Round ' + inactiveRounds.join('+') + ' rare pour ' + c.cat + ' ‚Äî Seul(s): ' + exceptions.join(', '));
                            } else {
                                scoreData.warnings.push('üö´ NICHE MORTE ‚Äî Aucun tournoi ' + c.cat + ' actuel n\'a de ' + inactiveRounds.join('+'));
                                // P√©naliser le score pour les niches mortes
                                scoreData.score = Math.max(0, scoreData.score - 30);
                                if (scoreData.verdict === 'fiable') scoreData.verdict = 'surveiller';
                                if (scoreData.verdict === 'surveiller') scoreData.verdictReason = 'Niche bas√©e sur tournois inactifs';
                            }
                        }

                        results.push({
                            circuit: c.circuit,
                            cat: c.cat,
                            surf: c.surf,
                            rnds: c.rnds,
                            strat: c.strat,
                            oMin: c.oMin,
                            oMax: c.oMax,
                            roi: rFull.roi,
                            roiRecent: r3 ? r3.roi : null,
                            bets: rFull.bets,
                            wins: rFull.wins,
                            yrs: rFull.yrs,
                            yrsPos: rFull.yrsPos,
                            yearlyData: rFull.yearlyData,
                            score: scoreData.score,
                            consistency: scoreData.consistency,
                            trend: scoreData.trend,
                            trendDir: scoreData.trendDir,
                            verdict: scoreData.verdict,
                            verdictReason: scoreData.verdictReason,
                            warnings: scoreData.warnings,
                            bonuses: scoreData.bonuses,
                            breakdown: scoreData.breakdown,
                            maxDD: rFull.maxDD
                        });
                    }
                    idx++;
                }
                
                var pct = Math.round(idx / totalCombos * 100);
                document.getElementById('detProgBarV2').style.width = pct + '%';
                safeText('detProgTextV2', pct + '% (' + idx + '/' + totalCombos + ' combinaisons)');
                
                if (idx < totalCombos) {
                    setTimeout(processChunk, 10);
                } else {
                    // Termin√© - stocker et afficher
                    detV2Results = results;
                    detV2Results.sort(function(a, b) { return b.score - a.score; });
                    
                    safeHTML('detProgV2', '‚úÖ Scan termin√© ! <b>' + results.length + '</b> niches trouv√©es');
                    safeDisplay('detSummary', true);
                    
                    renderDetectorV2Results();
                    checkActiveNichesWarnings();
                }
            }
            
            setTimeout(processChunk, 10);
        }
        
        function testComboV2(data, cat, surf, rnds, strat, oMin, oMax, yFrom, yTo) {
            var filtered = [];
            for (var i = 0; i < data.length; i++) {
                var m = data[i];
                if (m.year < yFrom || m.year > yTo) continue;
                if (!m.category) continue;
                var catKey = cat.replace('Masters ', '').replace('WTA ', '').replace('Grand Slam', 'Grand');
                if (m.category.indexOf(catKey) < 0) continue;
                if (m.surface !== surf) continue;
                var foundRnd = false;
                for (var j = 0; j < rnds.length; j++) {
                    if (m.round === rnds[j]) { foundRnd = true; break; }
                }
                if (!foundRnd) continue;
                filtered.push(m);
            }

            if (filtered.length < 5) return null;

            var results = [];
            var seen = {};
            for (var i = 0; i < filtered.length; i++) {
                var m = filtered[i];
                var key = m.date + m.p1 + m.p2;
                if (seen[key]) continue;

                var dO = Math.max(m.o1, m.o2);
                var fO = Math.min(m.o1, m.o2);
                var dP1 = m.o1 > m.o2;
                var odds = strat === 'underdog' ? dO : fO;
                var won = strat === 'underdog' ? dP1 : !dP1;

                if (odds >= oMin && odds <= oMax) {
                    results.push({ year: m.year, won: won, pnl: won ? odds - 1 : -1 });
                    seen[key] = true;
                }
            }

            if (results.length < 5) return null;

            var wins = 0, pnl = 0;
            for (var i = 0; i < results.length; i++) {
                if (results[i].won) wins++;
                pnl += results[i].pnl;
            }
            var roi = pnl / results.length * 100;

            // Calcul par ann√©e
            var byY = {};
            for (var i = 0; i < results.length; i++) {
                var r = results[i];
                if (!byY[r.year]) byY[r.year] = {pnl: 0, bets: 0};
                byY[r.year].pnl += r.pnl;
                byY[r.year].bets++;
            }
            
            var yrs = Object.keys(byY).sort();
            var yrsPos = 0;
            var yearlyData = [];
            for (var i = 0; i < yrs.length; i++) {
                var yData = byY[yrs[i]];
                if (yData.pnl > 0) yrsPos++;
                yearlyData.push({year: parseInt(yrs[i]), pnl: yData.pnl, bets: yData.bets, roi: yData.bets > 0 ? yData.pnl / yData.bets * 100 : 0});
            }
            
            // Calcul du max drawdown
            var cumPnl = 0, peak = 0, maxDD = 0;
            for (var i = 0; i < results.length; i++) {
                cumPnl += results[i].pnl;
                if (cumPnl > peak) peak = cumPnl;
                var dd = peak - cumPnl;
                if (dd > maxDD) maxDD = dd;
            }

            return { bets: results.length, wins: wins, roi: roi, yrs: yrs.length, yrsPos: yrsPos, yearlyData: yearlyData, maxDD: maxDD };
        }
        
        // ============================================
        // MODULE VALIDATION ACAD√âMIQUE
        // Bas√© sur la recherche: Winkelmann et al. 2024, Lahviƒçka 2014, Snowberg & Wolfers 2010
        // ============================================
        
        // Fonction de distribution normale cumulative (approximation)
        function normalCDF(x) {
            var a1 =  0.254829592;
            var a2 = -0.284496736;
            var a3 =  1.421413741;
            var a4 = -1.453152027;
            var a5 =  1.061405429;
            var p  =  0.3275911;
            
            var sign = x < 0 ? -1 : 1;
            x = Math.abs(x) / Math.sqrt(2);
            
            var t = 1.0 / (1.0 + p * x);
            var y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);
            
            return 0.5 * (1.0 + sign * y);
        }
        
        // Calcul du Z-Score pour une strat√©gie de paris
        // Formule: Z = (ROI observ√© - ROI attendu) / (œÉ / ‚àön)
        // ROI attendu avec vig standard = -4.545% (cotes -110)
        // œÉ ‚âà 0.9545 pour paris standard
        function calcZScore(bets, roi, avgOdds) {
            if (bets < 10) return { zscore: 0, pvalue: 1, significant: false };
            
            // Calcul de la marge bookmaker implicite
            var impliedMargin = avgOdds > 1 ? (1 / avgOdds) : 0.5;
            var expectedROI = -impliedMargin * 100; // ROI attendu n√©gatif (maison gagne)
            
            // Pour Pinnacle avec ~2% de marge, ROI attendu ‚âà -2%
            // Ajuster selon les cotes moyennes
            if (avgOdds >= 1.8 && avgOdds <= 2.2) expectedROI = -2.5;
            else if (avgOdds >= 2.2 && avgOdds <= 3.0) expectedROI = -3.0;
            else if (avgOdds >= 3.0) expectedROI = -4.0;
            else expectedROI = -2.0;
            
            // √âcart-type empirique pour paris sportifs
            // œÉ varie selon les cotes: plus les cotes sont hautes, plus la variance est grande
            var sigma = Math.sqrt(avgOdds - 1) * 100; // Approximation
            
            // Z-Score
            var zscore = (roi - expectedROI) / (sigma / Math.sqrt(bets));
            
            // P-Value (test unilat√©ral: on veut ROI > attendu)
            var pvalue = 1 - normalCDF(zscore);
            
            // Significativit√© (p < 0.05 pour 95% de confiance)
            var significant = pvalue < 0.05;
            var highlySignificant = pvalue < 0.01;
            
            return {
                zscore: zscore,
                pvalue: pvalue,
                significant: significant,
                highlySignificant: highlySignificant,
                expectedROI: expectedROI,
                sigma: sigma
            };
        }
        
        // Correction de Bonferroni pour tests multiples
        // Si on teste N niches, le seuil devient Œ±/N
        function calcBonferroniThreshold(numTests, alpha) {
            alpha = alpha || 0.05;
            return alpha / numTests;
        }
        
        // Correction FDR (Benjamini-Hochberg) - moins conservative
        function calcFDRThreshold(pvalues, alpha) {
            alpha = alpha || 0.05;
            var sorted = pvalues.slice().sort(function(a, b) { return a - b; });
            var n = sorted.length;
            var threshold = alpha;
            
            for (var i = n - 1; i >= 0; i--) {
                var bhThreshold = (i + 1) / n * alpha;
                if (sorted[i] <= bhThreshold) {
                    threshold = bhThreshold;
                    break;
                }
            }
            
            return threshold;
        }
        
        // Calcul du Kelly Criterion ajust√© pour l'incertitude
        // Bas√© sur Baker & McHale 2013, Chu, Wu & Swartz
        function calcAdjustedKelly(winrate, avgOdds, bets, confidence) {
            // Kelly brut: f* = (p*b - q) / b o√π b = odds-1, p = winrate, q = 1-p
            var b = avgOdds - 1;
            var p = winrate / 100;
            var q = 1 - p;
            
            var kellyRaw = (p * b - q) / b;
            kellyRaw = Math.max(0, kellyRaw); // Pas de kelly n√©gatif
            
            // Ajustement pour l'incertitude sur les param√®tres
            // Plus on a de paris, plus on est confiant
            // Prior conservateur Beta(50,50) centr√© sur 50%
            var priorStrength = 50;
            var posteriorWinrate = (winrate/100 * bets + 0.5 * priorStrength) / (bets + priorStrength);
            
            // Kelly ajust√© avec posterior
            var kellyAdjusted = (posteriorWinrate * b - (1 - posteriorWinrate)) / b;
            kellyAdjusted = Math.max(0, kellyAdjusted);
            
            // Recommandation de fraction Kelly
            var recommendedFraction = 0.25; // Quarter Kelly par d√©faut
            if (bets >= 500 && confidence >= 80) recommendedFraction = 0.5;
            else if (bets >= 200 && confidence >= 60) recommendedFraction = 0.33;
            else if (bets < 50) recommendedFraction = 0.1;
            
            var kellyFinal = kellyAdjusted * recommendedFraction;
            
            return {
                kellyRaw: kellyRaw * 100, // En pourcentage
                kellyAdjusted: kellyAdjusted * 100,
                kellyFinal: kellyFinal * 100,
                recommendedFraction: recommendedFraction,
                fractionLabel: recommendedFraction === 0.5 ? 'Half-Kelly' : 
                              recommendedFraction === 0.33 ? 'Third-Kelly' : 
                              recommendedFraction === 0.25 ? 'Quarter-Kelly' : 
                              'Tenth-Kelly'
            };
        }
        
        // D√©tection du type de biais (FLB classique vs Reverse)
        // Bas√© sur Newall & Cortis 2021, Lahviƒçka 2014
        function detectBiasType(strategy, avgOdds, roi) {
            var biasType = {
                type: 'neutral',
                label: 'Neutre',
                academicConsistency: 'unknown',
                explanation: ''
            };
            
            // Tennis montre g√©n√©ralement un FLB classique (favoris sous-cot√©s)
            // Selon Lahviƒçka 2014, le FLB est plus fort:
            // - Dans les tours tardifs (SF, F)
            // - Dans les tournois majeurs (GS, M1000)
            // - Entre joueurs mal class√©s
            
            if (strategy === 'underdog') {
                if (roi > 0) {
                    biasType.type = 'reverse_flb';
                    biasType.label = 'Reverse FLB';
                    biasType.academicConsistency = 'atypical';
                    biasType.explanation = 'Underdogs profitables = atypique en tennis. Lahviƒçka (2014) documente un FLB classique. Votre niche pourrait exploiter un segment sp√©cifique non √©tudi√©.';
                } else {
                    biasType.type = 'classic_flb';
                    biasType.label = 'FLB Classique';
                    biasType.academicConsistency = 'consistent';
                    biasType.explanation = 'Coh√©rent avec la litt√©rature: underdogs surcot√©s en tennis (Forrest & McHale 2007).';
                }
            } else { // favorite
                if (roi > 0) {
                    biasType.type = 'classic_flb';
                    biasType.label = 'FLB Classique';
                    biasType.academicConsistency = 'consistent';
                    biasType.explanation = 'Favoris profitables = coh√©rent avec le FLB classique document√© en tennis.';
                } else {
                    biasType.type = 'reverse_flb';
                    biasType.label = 'Reverse FLB';
                    biasType.academicConsistency = 'atypical';
                    biasType.explanation = 'Favoris non profitables = atypique. Possible sur-correction du march√©.';
                }
            }
            
            // Ajustement selon la plage de cotes
            if (avgOdds >= 2.0 && avgOdds <= 2.5 && strategy === 'underdog' && roi > 0) {
                biasType.explanation += ' Zone "slight underdog" - Robbins (2022) trouve des rendements positifs dans cette zone pour NFL/UFC.';
            }
            
            return biasType;
        }
        
        // Alerte Data Mining
        // Bas√© sur Winkelmann et al. 2024: >75% de chance de faux positif dans l'analyse par saison
        function calcDataMiningRisk(numTestsPerformed, pvalue, yearsPositive, totalYears, bets) {
            var risk = {
                level: 'low',
                label: 'Faible',
                color: 'var(--green)',
                warnings: [],
                score: 0
            };
            
            // Facteur 1: Nombre de tests effectu√©s
            if (numTestsPerformed > 1000) {
                risk.score += 40;
                risk.warnings.push('üî¥ ' + numTestsPerformed + ' combinaisons test√©es - risque √©lev√© de faux positif');
            } else if (numTestsPerformed > 100) {
                risk.score += 20;
                risk.warnings.push('üü° ' + numTestsPerformed + ' combinaisons test√©es');
            }
            
            // Facteur 2: P-value vs seuil corrig√©
            var bonferroniThreshold = 0.05 / numTestsPerformed;
            if (pvalue > bonferroniThreshold) {
                risk.score += 30;
                risk.warnings.push('‚ö†Ô∏è Non significatif apr√®s correction Bonferroni (seuil: ' + bonferroniThreshold.toExponential(2) + ')');
            }
            
            // Facteur 3: Consistance inter-ann√©es (Winkelmann 2024)
            var consistencyRatio = yearsPositive / totalYears;
            if (consistencyRatio < 0.6) {
                risk.score += 20;
                risk.warnings.push('üìâ Seulement ' + Math.round(consistencyRatio * 100) + '% des ann√©es positives');
            }
            
            // Facteur 4: Taille d'√©chantillon
            if (bets < 100) {
                risk.score += 25;
                risk.warnings.push('üìä √âchantillon faible (' + bets + ' paris) - significativit√© douteuse');
            } else if (bets < 200) {
                risk.score += 10;
                risk.warnings.push('üìä √âchantillon mod√©r√© (' + bets + ' paris)');
            }
            
            // D√©terminer le niveau de risque
            if (risk.score >= 60) {
                risk.level = 'high';
                risk.label = '√âlev√©';
                risk.color = 'var(--red)';
            } else if (risk.score >= 30) {
                risk.level = 'medium';
                risk.label = 'Mod√©r√©';
                risk.color = 'var(--yellow)';
            } else {
                risk.level = 'low';
                risk.label = 'Faible';
                risk.color = 'var(--green)';
            }
            
            return risk;
        }
        
        // Calcul du score acad√©mique global
        function calcAcademicValidation(rFull, strategy, avgOdds, numTestsPerformed) {
            numTestsPerformed = numTestsPerformed || 500; // Estimation par d√©faut
            
            var stats = calcZScore(rFull.bets, rFull.roi, avgOdds);
            var kelly = calcAdjustedKelly(rFull.wr, avgOdds, rFull.bets, 50);
            var bias = detectBiasType(strategy, avgOdds, rFull.roi);
            var dataMining = calcDataMiningRisk(numTestsPerformed, stats.pvalue, rFull.yrsPos, rFull.yrs, rFull.bets);
            
            // Score acad√©mique sur 100
            var academicScore = 0;
            
            // Significativit√© statistique (40 pts max)
            if (stats.highlySignificant) academicScore += 40;
            else if (stats.significant) academicScore += 25;
            else if (stats.pvalue < 0.10) academicScore += 10;
            
            // Taille d'√©chantillon (20 pts max)
            if (rFull.bets >= 500) academicScore += 20;
            else if (rFull.bets >= 200) academicScore += 15;
            else if (rFull.bets >= 100) academicScore += 10;
            else if (rFull.bets >= 50) academicScore += 5;
            
            // Consistance inter-ann√©es (25 pts max)
            var consistencyRatio = rFull.yrsPos / rFull.yrs;
            academicScore += Math.round(consistencyRatio * 25);
            
            // Coh√©rence avec la litt√©rature (15 pts max)
            if (bias.academicConsistency === 'consistent') academicScore += 15;
            else if (bias.academicConsistency === 'atypical') academicScore += 5; // Bonus si √ßa marche quand m√™me
            
            // Malus data mining
            academicScore -= Math.round(dataMining.score * 0.3);
            academicScore = Math.max(0, Math.min(100, academicScore));
            
            // Verdict acad√©mique
            var verdict = 'reject';
            var verdictLabel = '‚ùå Non valid√©';
            if (academicScore >= 70 && stats.significant) {
                verdict = 'validated';
                verdictLabel = '‚úÖ Valid√© acad√©miquement';
            } else if (academicScore >= 50 || stats.pvalue < 0.10) {
                verdict = 'promising';
                verdictLabel = 'üî¨ Prometteur (validation en cours)';
            } else if (academicScore >= 30) {
                verdict = 'investigate';
                verdictLabel = 'üîç √Ä investiguer';
            }
            
            return {
                score: academicScore,
                verdict: verdict,
                verdictLabel: verdictLabel,
                stats: stats,
                kelly: kelly,
                bias: bias,
                dataMining: dataMining
            };
        }

        function calcCompositeScore(rFull, r3, r5, yearlyData, numTestsPerformed) {
            // === NOUVEAU SCORING ACAD√âMIQUE ===
            // Bas√© sur: Winkelmann 2024, Lahviƒçka 2014, analyse des patterns cycliques
            
            numTestsPerformed = numTestsPerformed || 1728; // D√©faut bas√© sur ton Lab
            yearlyData = yearlyData || [];
            
            var warnings = [];
            var bonuses = [];
            
            // ============================================
            // 1. ANALYSE DES ANN√âES FOLLES (Outlier Detection)
            // ============================================
            var outlierPenalty = 0;
            var outlierYears = [];
            
            if (yearlyData.length >= 5) {
                // Calculer moyenne et √©cart-type des ROI annuels
                var rois = yearlyData.map(function(y) { return y.roi; });
                var meanROI = rois.reduce(function(a, b) { return a + b; }, 0) / rois.length;
                var variance = rois.reduce(function(sum, r) { return sum + Math.pow(r - meanROI, 2); }, 0) / rois.length;
                var stdROI = Math.sqrt(variance);
                
                // Identifier les outliers (> 2 √©carts-types)
                for (var i = 0; i < yearlyData.length; i++) {
                    var y = yearlyData[i];
                    if (Math.abs(y.roi - meanROI) > 2 * stdROI) {
                        outlierYears.push({ year: y.year, roi: y.roi, bets: y.bets });
                        
                        // P√©nalit√© plus forte si outlier positif tire le ROI
                        if (y.roi > meanROI) {
                            outlierPenalty += 5;
                        }
                    }
                }
                
                if (outlierYears.length > 0) {
                    var outlierNames = outlierYears.map(function(o) { 
                        return o.year + ' (' + (o.roi >= 0 ? '+' : '') + o.roi.toFixed(0) + '%)'; 
                    }).join(', ');
                    warnings.push('üé∞ Ann√©es outliers: ' + outlierNames);
                }
                
                // Calculer le ROI SANS les outliers positifs
                var robustROIs = [];
                for (var i = 0; i < yearlyData.length; i++) {
                    var isPositiveOutlier = false;
                    for (var j = 0; j < outlierYears.length; j++) {
                        if (outlierYears[j].year === yearlyData[i].year && outlierYears[j].roi > meanROI) {
                            isPositiveOutlier = true;
                            break;
                        }
                    }
                    if (!isPositiveOutlier) {
                        robustROIs.push(yearlyData[i].roi);
                    }
                }
                
                if (robustROIs.length > 0) {
                    var robustMeanROI = robustROIs.reduce(function(a, b) { return a + b; }, 0) / robustROIs.length;
                    if (robustMeanROI < 0 && rFull.roi > 0) {
                        outlierPenalty += 15;
                        warnings.push('‚ö†Ô∏è ROI n√©gatif sans les outliers (' + robustMeanROI.toFixed(1) + '%)');
                    }
                }
            }
            
            // ============================================
            // 2. VOLATILIT√â INTER-ANN√âES
            // ============================================
            var volatilityPenalty = 0;
            
            if (yearlyData.length >= 3) {
                var rois = yearlyData.map(function(y) { return y.roi; });
                var meanROI = rois.reduce(function(a, b) { return a + b; }, 0) / rois.length;
                var variance = rois.reduce(function(sum, r) { return sum + Math.pow(r - meanROI, 2); }, 0) / rois.length;
                var stdROI = Math.sqrt(variance);
                var coeffVar = Math.abs(meanROI) > 0 ? stdROI / Math.abs(meanROI) : stdROI;
                
                // P√©nalit√© si coefficient de variation > 1 (tr√®s volatile)
                if (coeffVar > 2) {
                    volatilityPenalty = 15;
                    warnings.push('üìä Tr√®s haute volatilit√© (CV: ' + coeffVar.toFixed(1) + ')');
                } else if (coeffVar > 1) {
                    volatilityPenalty = 8;
                    warnings.push('üìä Haute volatilit√© (CV: ' + coeffVar.toFixed(1) + ')');
                }
            }
            
            // ============================================
            // 3. FIABILIT√â DES DONN√âES R√âCENTES
            // ============================================
            var recentReliabilityPenalty = 0;
            var recentYearWarning = '';
            
            if (yearlyData.length >= 2) {
                var lastYear = yearlyData[yearlyData.length - 1];
                var prevYear = yearlyData[yearlyData.length - 2];
                
                // Ann√©e en cours avec peu de paris = non fiable
                if (lastYear.bets < 20) {
                    recentReliabilityPenalty += 10;
                    recentYearWarning = '‚ö†Ô∏è ' + lastYear.year + ': seulement ' + lastYear.bets + ' paris (non fiable)';
                    warnings.push(recentYearWarning);
                    
                    // Si cette ann√©e peu fiable montre un ROI extr√™me, grosse p√©nalit√©
                    if (Math.abs(lastYear.roi) > 50) {
                        recentReliabilityPenalty += 10;
                        warnings.push('üé≤ ROI extr√™me (' + (lastYear.roi >= 0 ? '+' : '') + lastYear.roi.toFixed(0) + '%) sur √©chantillon faible');
                    }
                }
                
                // V√©rifier si ann√©e pr√©c√©dente √©tait mauvaise
                if (prevYear.roi < -20) {
                    recentReliabilityPenalty += 5;
                    warnings.push('üìâ ' + prevYear.year + ' √©tait √† ' + prevYear.roi.toFixed(0) + '%');
                }
            }
            
            // ============================================
            // 4. PATTERNS CYCLIQUES (Trous r√©currents)
            // ============================================
            var cyclePenalty = 0;
            
            if (yearlyData.length >= 6) {
                // Compter les "trous" (s√©quences de 2+ ann√©es n√©gatives)
                var consecutiveNeg = 0;
                var holeCount = 0;
                
                for (var i = 0; i < yearlyData.length; i++) {
                    if (yearlyData[i].roi < 0) {
                        consecutiveNeg++;
                    } else {
                        if (consecutiveNeg >= 2) holeCount++;
                        consecutiveNeg = 0;
                    }
                }
                if (consecutiveNeg >= 2) holeCount++;
                
                if (holeCount >= 2) {
                    cyclePenalty = 10;
                    warnings.push('üîÑ Pattern cyclique d√©tect√© (' + holeCount + ' trous de 2+ ans)');
                } else if (holeCount === 1) {
                    cyclePenalty = 5;
                }
                
                // V√©rifier si on est potentiellement dans un trou maintenant
                if (yearlyData.length >= 2) {
                    var last2 = yearlyData.slice(-2);
                    var last2Neg = last2.filter(function(y) { return y.roi < 0; }).length;
                    if (last2Neg >= 1 && last2[last2.length - 1].bets >= 20) {
                        cyclePenalty += 5;
                        warnings.push('‚ö†Ô∏è Possible d√©but de phase n√©gative');
                    }
                }
            }
            
            // ============================================
            // 5. SIGNIFICATIVIT√â STATISTIQUE
            // Bonferroni = info seulement, pas de p√©nalit√© (trop s√©v√®re en pratique)
            // ============================================
            var statsPenalty = 0;
            var avgOdds = 2.5; // Approximation, sera affin√©e
            if (rFull.bets > 0 && rFull.roi !== undefined) {
                // Estimation cotes moyennes selon strat√©gie implicite
                // (sera pass√© en param√®tre dans version finale)
            }
            
            var stats = calcZScore(rFull.bets, rFull.roi, avgOdds);
            var bonferroniThreshold = 0.05 / numTestsPerformed;
            
            if (!stats.significant) {
                // Vraiment non significatif (p > 0.05) = p√©nalit√©
                statsPenalty = 10;
                warnings.push('üìà Non significatif (p=' + stats.pvalue.toFixed(3) + ')');
            } else if (stats.pvalue > bonferroniThreshold) {
                // Significatif mais √©choue Bonferroni = juste une INFO, pas de p√©nalit√©
                // Bonferroni est trop s√©v√®re pour √™tre un crit√®re √©liminatoire
                bonuses.push('üìä Significatif (p=' + stats.pvalue.toFixed(3) + ')');
                warnings.push('‚ÑπÔ∏è Bonferroni non atteint (seuil: ' + bonferroniThreshold.toExponential(1) + ') ‚Äî normal avec ' + numTestsPerformed + ' tests');
            } else {
                // Passe Bonferroni = tr√®s fort signal
                bonuses.push('‚úÖ Significatif m√™me apr√®s Bonferroni (p=' + stats.pvalue.toExponential(2) + ') ‚Äî signal tr√®s fort !');
            }
            
            // ============================================
            // 6. CALCUL DU SCORE DE BASE
            // ============================================
            
            // Consistance (30 pts max) - % ann√©es positives
            var consistencyPct = rFull.yrsPos / rFull.yrs;
            var consistencyScore = consistencyPct * 30;
            
            // ROI ajust√© pour la volatilit√© (25 pts max)
            var roiScore = 0;
            if (rFull.roi >= 15) roiScore = 25;
            else if (rFull.roi >= 10) roiScore = 20;
            else if (rFull.roi >= 5) roiScore = 15;
            else if (rFull.roi >= 0) roiScore = 8;
            else roiScore = 0;
            
            // Volume robuste (20 pts max)
            var avgBetsPerYear = rFull.bets / rFull.yrs;
            var volumeScore = 0;
            if (avgBetsPerYear >= 50) volumeScore = 20;
            else if (avgBetsPerYear >= 30) volumeScore = 15;
            else if (avgBetsPerYear >= 20) volumeScore = 12;
            else if (avgBetsPerYear >= 10) volumeScore = 8;
            else volumeScore = 4;
            
            // Tendance r√©cente FIABLE (15 pts max)
            var trendScore = 0;
            var trendDir = 'stable';
            if (r3 && r3.bets >= 30) { // Minimum 30 paris pour √™tre fiable
                if (r3.roi >= rFull.roi + 10) { trendScore = 15; trendDir = 'up'; bonuses.push('üìà Tendance haussi√®re confirm√©e'); }
                else if (r3.roi >= rFull.roi) { trendScore = 12; trendDir = 'up'; }
                else if (r3.roi >= rFull.roi - 10) { trendScore = 8; trendDir = 'stable'; }
                else if (r3.roi >= 0) { trendScore = 5; trendDir = 'down'; }
                else { trendScore = 0; trendDir = 'down'; warnings.push('üìâ ROI n√©gatif sur 3 ans'); }
            } else if (r3 && r3.bets >= 15) {
                // Donn√©es r√©centes partielles
                trendScore = 7;
                trendDir = r3.roi >= rFull.roi ? 'up' : r3.roi >= 0 ? 'stable' : 'down';
            } else {
                trendScore = 5; // Neutre si pas assez de donn√©es
                warnings.push('üìä Donn√©es r√©centes insuffisantes pour tendance fiable');
            }
            
            // Significativit√© statistique (10 pts max)
            var sigScore = 0;
            if (stats.highlySignificant) sigScore = 10;
            else if (stats.significant) sigScore = 6;
            else sigScore = 0;
            
            // ============================================
            // 7. SCORE FINAL
            // ============================================
            var baseScore = consistencyScore + roiScore + volumeScore + trendScore + sigScore;
            var totalPenalties = outlierPenalty + volatilityPenalty + recentReliabilityPenalty + cyclePenalty + statsPenalty;
            
            var finalScore = Math.round(Math.max(0, Math.min(100, baseScore - totalPenalties)));
            
            // ============================================
            // 8. VERDICT AJUST√â
            // ============================================
            var verdict = 'eviter';
            var verdictReason = '';
            
            // Conditions strictes pour "fiable"
            if (finalScore >= 70 && 
                consistencyPct >= 0.65 && 
                outlierPenalty <= 5 &&
                (r3 === null || r3.bets < 15 || r3.roi >= 0)) {
                verdict = 'fiable';
                verdictReason = 'Historique solide et stable';
            } 
            // Conditions pour "surveiller"
            else if (finalScore >= 45 && consistencyPct >= 0.5) {
                verdict = 'surveiller';
                if (warnings.length > 0) {
                    verdictReason = 'Potentiel mais: ' + warnings[0];
                } else {
                    verdictReason = 'N√©cessite plus de donn√©es ou surveillance';
                }
            } 
            // Sinon √©viter
            else {
                verdict = 'eviter';
                if (warnings.length > 0) {
                    verdictReason = warnings[0];
                } else {
                    verdictReason = 'Score insuffisant ou trop volatile';
                }
            }
            
            return {
                score: finalScore,
                consistency: Math.round(consistencyPct * 100),
                trend: trendScore,
                trendDir: trendDir,
                verdict: verdict,
                verdictReason: verdictReason,
                warnings: warnings,
                bonuses: bonuses,
                // D√©tails pour debug/affichage
                breakdown: {
                    base: Math.round(baseScore),
                    consistencyScore: Math.round(consistencyScore),
                    roiScore: roiScore,
                    volumeScore: volumeScore,
                    trendScore: trendScore,
                    sigScore: sigScore,
                    penalties: {
                        outlier: outlierPenalty,
                        volatility: volatilityPenalty,
                        recentReliability: recentReliabilityPenalty,
                        cycle: cyclePenalty,
                        stats: statsPenalty,
                        total: totalPenalties
                    }
                },
                stats: stats
            };
        }
        
        function renderDetectorV2Results() {
            var filtered = detV2Results;
            
            // Filtrer par verdict
            if (detV2CurrentFilter !== 'all') {
                filtered = filtered.filter(function(n) { return n.verdict === detV2CurrentFilter; });
            }
            
            // Trier
            filtered = filtered.slice().sort(function(a, b) {
                switch (detV2CurrentSort) {
                    case 'roi': return b.roi - a.roi;
                    case 'consistency': return b.consistency - a.consistency;
                    case 'volume': return b.bets - a.bets;
                    default: return b.score - a.score;
                }
            });
            
            // Compter par cat√©gorie
            var countFiable = detV2Results.filter(function(n) { return n.verdict === 'fiable'; }).length;
            var countSurveiller = detV2Results.filter(function(n) { return n.verdict === 'surveiller'; }).length;
            var countEviter = detV2Results.filter(function(n) { return n.verdict === 'eviter'; }).length;
            
            var countFiableEl = document.getElementById('detCountFiable');
            var countSurveillerEl = document.getElementById('detCountSurveiller');
            var countEviterEl = document.getElementById('detCountEviter');
            if (countFiableEl) countFiableEl.textContent = countFiable;
            if (countSurveillerEl) countSurveillerEl.textContent = countSurveiller;
            if (countEviterEl) countEviterEl.textContent = countEviter;
            
            // Grouper les similaires si activ√©
            var groups = [];
            if (detV2GroupSimilar) {
                groups = groupSimilarNiches(filtered);
            } else {
                groups = filtered.map(function(n) { return [n]; });
            }
            
            // Rendre le HTML
            var html = '';
            
            for (var g = 0; g < groups.length; g++) {
                var group = groups[g];
                var best = group[0];
                var hasAlternatives = group.length > 1;
                
                html += renderNicheCard(best, hasAlternatives ? group.slice(1) : [], g);
            }
            
            if (html === '') {
                html = '<div style="text-align:center;padding:2rem;color:var(--muted)"><div style="font-size:3rem;margin-bottom:1rem">üîç</div><p>Aucune niche trouv√©e avec ces crit√®res</p></div>';
            }
            
            var nichesListEl = document.getElementById('detNichesList');
            if (nichesListEl) nichesListEl.innerHTML = html;
        }
        
        function renderNicheCard(n, alternatives, idx) {
            var activeNicheInfo = getActiveNicheInfo(n.cat, n.surf, n.rnds, n.strat, n.oMin, n.oMax);
            var isActive = activeNicheInfo !== null;
            var overlapping = findOverlappingNiches(n.cat, n.surf, n.rnds, n.strat, n.oMin, n.oMax);
            
            var stratLabel = n.strat === 'underdog' ? 'UND' : 'FAV';
            var catLabel = n.cat.replace('Masters 1000', 'M1000').replace('Grand Slam', 'GS').replace('WTA ', 'W').replace('ATP ', '');
            var name = stratLabel + ' ' + catLabel + ' ' + n.surf + ' ' + n.rnds.join('+') + ' @' + n.oMin + '-' + n.oMax;
            
            // Score class
            var scoreClass = n.score >= 70 ? 'excellent' : n.score >= 55 ? 'good' : n.score >= 40 ? 'moderate' : 'poor';
            var verdictClass = n.verdict;
            var verdictText = n.verdict === 'fiable' ? 'üü¢ Exploitable' : n.verdict === 'surveiller' ? 'üü° √Ä surveiller' : 'üî¥ Risqu√©';
            var verdictDesc = n.verdictReason || (n.verdict === 'fiable' ? 'Historique solide, tendance stable ou positive' : n.verdict === 'surveiller' ? 'Potentiel mais n√©cessite surveillance' : 'Inconsistant ou en d√©clin');
            
            // Trend icon
            var trendIcon = n.trendDir === 'up' ? 'üìà' : n.trendDir === 'down' ? 'üìâ' : '‚û°Ô∏è';
            var trendClass = n.trendDir;
            
            // Action buttons - on utilise des data attributes pour √©viter les probl√®mes d'escape
            var actionBtn = '';
            var nicheDataAttr = 'data-cat="' + n.cat + '" data-surf="' + n.surf + '" data-rnds="' + n.rnds.join(',') + '" data-strat="' + n.strat + '" data-omin="' + n.oMin + '" data-omax="' + n.oMax + '" data-circuit="' + n.circuit + '"';
            
            if (isActive) {
                actionBtn = '<div style="display:flex;gap:.5rem;flex-wrap:wrap">';
                actionBtn += '<button class="niche-action remove" ' + nicheDataAttr + ' data-id="' + activeNicheInfo.id + '" onclick="event.stopPropagation();handleNicheAction(this,\'disable\')">üî¥ D√©sactiver</button>';
                actionBtn += '<button style="background:var(--bg);color:var(--red);border:1px solid var(--red);padding:.5rem .75rem;border-radius:8px;font-size:.8rem;cursor:pointer" ' + nicheDataAttr + ' data-id="' + activeNicheInfo.id + '" data-circuit-delete="' + activeNicheInfo.circuit + '" onclick="event.stopPropagation();handleNicheAction(this,\'delete\')">üóëÔ∏è</button>';
                actionBtn += '</div>';
            } else if (overlapping.length > 0) {
                actionBtn = '<button class="niche-action swap" ' + nicheDataAttr + ' onclick="event.stopPropagation();handleNicheAction(this,\'swap\')">üîÑ Remplacer</button>';
            } else {
                actionBtn = '<button class="niche-action" ' + nicheDataAttr + ' onclick="event.stopPropagation();handleNicheAction(this,\'add\')">‚ûï Ajouter</button>';
            }
            
            var html = '<div class="niche-card ' + (isActive ? 'selected' : '') + ' ' + (n.verdict === 'eviter' ? 'danger' : '') + '" id="niche-card-' + idx + '">';
            
            // Header
            html += '<div class="niche-header" onclick="toggleNicheCard(' + idx + ')">';
            html += '<div class="niche-score ' + scoreClass + '">' + n.score + '</div>';
            html += '<div class="niche-info">';
            html += '<div class="niche-name">' + name;
            html += '<span class="badge ' + n.circuit + '">' + n.circuit.toUpperCase() + '</span>';
            if (isActive) html += '<span class="badge active">‚úì Active</span>';
            if (alternatives.length > 0) html += '<span class="badge" style="background:var(--purple);color:#fff">+' + alternatives.length + ' similaires</span>';
            html += '</div>';
            html += '<div class="niche-meta">';
            html += '<span>' + n.bets + ' paris</span>';
            html += '<span>' + n.yrsPos + '/' + n.yrs + ' ann√©es +</span>';
            html += '<span class="niche-trend ' + trendClass + '">' + trendIcon + ' ' + (n.trendDir === 'up' ? 'En hausse' : n.trendDir === 'down' ? 'En baisse' : 'Stable') + '</span>';
            html += '</div></div>';
            html += '<div class="niche-stats"><div class="niche-roi' + (n.roi < 0 ? ' neg' : '') + '">+' + n.roi.toFixed(0) + '%</div></div>';
            html += actionBtn;
            html += '</div>';
            
            // Details (hidden by default)
            html += '<div class="niche-details">';
            
            // Verdict
            html += '<div class="niche-verdict ' + verdictClass + '">';
            html += '<span style="font-size:1.5rem">' + (n.verdict === 'fiable' ? '‚úÖ' : n.verdict === 'surveiller' ? '‚ö†Ô∏è' : '‚ùå') + '</span>';
            html += '<div><strong>' + verdictText + '</strong><div style="font-size:.75rem;opacity:.8">' + verdictDesc + '</div></div>';
            html += '</div>';
            
            // === NOUVEAU: Warnings acad√©miques ===
            if (n.warnings && n.warnings.length > 0) {
                html += '<div style="background:rgba(239,68,68,.1);border:1px solid rgba(239,68,68,.3);border-radius:8px;padding:.75rem;margin-bottom:1rem">';
                html += '<div style="font-weight:600;color:var(--red);margin-bottom:.5rem;font-size:.8rem">‚ö†Ô∏è Alertes de validation</div>';
                for (var w = 0; w < n.warnings.length; w++) {
                    html += '<div style="font-size:.75rem;color:var(--text);margin-bottom:.25rem;padding-left:.5rem">' + n.warnings[w] + '</div>';
                }
                html += '</div>';
            }
            
            // === NOUVEAU: Bonuses acad√©miques ===
            if (n.bonuses && n.bonuses.length > 0) {
                html += '<div style="background:rgba(34,197,94,.1);border:1px solid rgba(34,197,94,.3);border-radius:8px;padding:.75rem;margin-bottom:1rem">';
                html += '<div style="font-weight:600;color:var(--green);margin-bottom:.5rem;font-size:.8rem">‚úÖ Points forts</div>';
                for (var b = 0; b < n.bonuses.length; b++) {
                    html += '<div style="font-size:.75rem;color:var(--text);margin-bottom:.25rem;padding-left:.5rem">' + n.bonuses[b] + '</div>';
                }
                html += '</div>';
            }
            
            // M√©triques
            html += '<div class="niche-metrics">';
            html += '<div class="niche-metric"><div class="val">' + n.score + '</div><div class="lbl">Score</div></div>';
            html += '<div class="niche-metric"><div class="val">' + n.consistency + '%</div><div class="lbl">Consistance</div></div>';
            html += '<div class="niche-metric"><div class="val">' + (n.roiRecent !== null ? (n.roiRecent >= 0 ? '+' : '') + n.roiRecent.toFixed(0) + '%' : 'N/A') + '</div><div class="lbl">ROI 3 ans</div></div>';
            html += '<div class="niche-metric"><div class="val">' + (n.bets / n.yrs).toFixed(1) + '</div><div class="lbl">Paris/an</div></div>';
            html += '<div class="niche-metric"><div class="val">-' + n.maxDD.toFixed(1) + 'u</div><div class="lbl">Max DD</div></div>';
            html += '</div>';
            
            // === NOUVEAU: Breakdown du score ===
            if (n.breakdown) {
                html += '<div style="background:var(--bg);border:1px solid var(--border);border-radius:8px;padding:.75rem;margin-bottom:1rem">';
                html += '<div style="font-weight:600;margin-bottom:.5rem;font-size:.8rem;display:flex;justify-content:space-between">';
                html += '<span>üìä D√©composition du score</span>';
                html += '<span style="color:var(--muted)">Base: ' + n.breakdown.base + ' ‚Üí Final: ' + n.score + '</span>';
                html += '</div>';
                
                // Barres de progression pour chaque composant
                html += '<div style="display:grid;grid-template-columns:1fr 1fr;gap:.5rem;font-size:.7rem">';
                
                // Consistance (30 pts max)
                html += '<div style="display:flex;align-items:center;gap:.5rem">';
                html += '<span style="width:70px;color:var(--muted)">Consistance</span>';
                html += '<div style="flex:1;height:6px;background:var(--border);border-radius:3px;overflow:hidden"><div style="width:' + (n.breakdown.consistencyScore / 30 * 100) + '%;height:100%;background:var(--green)"></div></div>';
                html += '<span style="width:30px;text-align:right">' + n.breakdown.consistencyScore.toFixed(0) + '/30</span>';
                html += '</div>';
                
                // ROI (25 pts max)
                html += '<div style="display:flex;align-items:center;gap:.5rem">';
                html += '<span style="width:70px;color:var(--muted)">ROI</span>';
                html += '<div style="flex:1;height:6px;background:var(--border);border-radius:3px;overflow:hidden"><div style="width:' + (n.breakdown.roiScore / 25 * 100) + '%;height:100%;background:var(--blue)"></div></div>';
                html += '<span style="width:30px;text-align:right">' + n.breakdown.roiScore + '/25</span>';
                html += '</div>';
                
                // Volume (20 pts max)
                html += '<div style="display:flex;align-items:center;gap:.5rem">';
                html += '<span style="width:70px;color:var(--muted)">Volume</span>';
                html += '<div style="flex:1;height:6px;background:var(--border);border-radius:3px;overflow:hidden"><div style="width:' + (n.breakdown.volumeScore / 20 * 100) + '%;height:100%;background:var(--purple)"></div></div>';
                html += '<span style="width:30px;text-align:right">' + n.breakdown.volumeScore + '/20</span>';
                html += '</div>';
                
                // Tendance (15 pts max)
                html += '<div style="display:flex;align-items:center;gap:.5rem">';
                html += '<span style="width:70px;color:var(--muted)">Tendance</span>';
                html += '<div style="flex:1;height:6px;background:var(--border);border-radius:3px;overflow:hidden"><div style="width:' + (n.breakdown.trendScore / 15 * 100) + '%;height:100%;background:var(--yellow)"></div></div>';
                html += '<span style="width:30px;text-align:right">' + n.breakdown.trendScore + '/15</span>';
                html += '</div>';
                
                // Significativit√© (10 pts max)
                html += '<div style="display:flex;align-items:center;gap:.5rem">';
                html += '<span style="width:70px;color:var(--muted)">Stats</span>';
                html += '<div style="flex:1;height:6px;background:var(--border);border-radius:3px;overflow:hidden"><div style="width:' + (n.breakdown.sigScore / 10 * 100) + '%;height:100%;background:var(--cyan,#06b6d4)"></div></div>';
                html += '<span style="width:30px;text-align:right">' + n.breakdown.sigScore + '/10</span>';
                html += '</div>';
                
                // P√©nalit√©s
                html += '<div style="display:flex;align-items:center;gap:.5rem;grid-column:span 2;margin-top:.25rem;padding-top:.5rem;border-top:1px solid var(--border)">';
                html += '<span style="width:70px;color:var(--red)">P√©nalit√©s</span>';
                html += '<div style="flex:1;font-size:.65rem;color:var(--muted)">';
                if (n.breakdown.penalties.outlier > 0) html += 'Outliers: -' + n.breakdown.penalties.outlier + ' ';
                if (n.breakdown.penalties.volatility > 0) html += 'Volatilit√©: -' + n.breakdown.penalties.volatility + ' ';
                if (n.breakdown.penalties.recentReliability > 0) html += 'R√©cent: -' + n.breakdown.penalties.recentReliability + ' ';
                if (n.breakdown.penalties.cycle > 0) html += 'Cycles: -' + n.breakdown.penalties.cycle + ' ';
                if (n.breakdown.penalties.stats > 0) html += 'Stats: -' + n.breakdown.penalties.stats + ' ';
                if (n.breakdown.penalties.total === 0) html += 'Aucune';
                html += '</div>';
                html += '<span style="width:50px;text-align:right;color:var(--red);font-weight:600">-' + n.breakdown.penalties.total + '</span>';
                html += '</div>';
                
                html += '</div>'; // grid
                html += '</div>'; // breakdown box
            }
            
            // Ann√©es - avec affichage ROI d√©taill√©
            html += '<div style="font-size:.75rem;color:var(--muted);margin-bottom:.5rem">Performance ann√©e par ann√©e:</div>';
            html += '<div class="niche-years-detailed">';
            for (var i = 0; i < n.yearlyData.length; i++) {
                var y = n.yearlyData[i];
                var yClass = y.roi > 20 ? 'very-pos' : y.roi > 0 ? 'pos' : y.roi > -20 ? 'neg' : 'very-neg';
                html += '<div class="niche-year-detail ' + yClass + '" title="' + y.year + ': ' + (y.roi >= 0 ? '+' : '') + y.roi.toFixed(0) + '% ROI (' + y.bets + ' paris)">';
                html += '<div class="year-label">' + y.year + '</div>';
                html += '<div class="year-bets">' + y.bets + 'p</div>';
                html += '<div class="year-roi">' + (y.roi >= 0 ? '+' : '') + y.roi.toFixed(0) + '%</div>';
                html += '</div>';
            }
            html += '</div>';
            
            // Alternatives similaires
            if (alternatives.length > 0) {
                html += '<button class="similar-toggle" onclick="event.stopPropagation();toggleSimilarNiches(' + idx + ')">‚ñº ' + alternatives.length + ' alternative(s) similaire(s)</button>';
                html += '<div class="similar-niches" id="similar-' + idx + '">';
                for (var a = 0; a < alternatives.length; a++) {
                    var alt = alternatives[a];
                    var altName = (alt.strat === 'underdog' ? 'UND' : 'FAV') + ' ' + alt.cat.replace('Masters 1000', 'M1000').replace('Grand Slam', 'GS') + ' ' + alt.surf + ' ' + alt.rnds.join('+') + ' @' + alt.oMin + '-' + alt.oMax;
                    var altActive = isNicheActive(alt.cat, alt.surf, alt.rnds, alt.strat, alt.oMin, alt.oMax);
                    var altDataAttr = 'data-cat="' + alt.cat + '" data-surf="' + alt.surf + '" data-rnds="' + alt.rnds.join(',') + '" data-strat="' + alt.strat + '" data-omin="' + alt.oMin + '" data-omax="' + alt.oMax + '" data-circuit="' + alt.circuit + '"';
                    html += '<div class="similar-niche">';
                    html += '<div><span style="font-weight:500">' + altName + '</span> <span style="font-size:.7rem;color:var(--muted)">Score: ' + alt.score + '</span>' + (altActive ? ' <span class="badge active" style="font-size:.6rem">Active</span>' : '') + '</div>';
                    html += '<div style="display:flex;align-items:center;gap:.75rem">';
                    html += '<span style="color:var(--green);font-weight:600">+' + alt.roi.toFixed(0) + '%</span>';
                    if (!altActive) {
                        html += '<button ' + altDataAttr + ' onclick="event.stopPropagation();handleNicheAction(this,\'add\')" style="background:var(--green);color:#000;border:none;padding:.25rem .5rem;border-radius:4px;font-size:.7rem;cursor:pointer">‚ûï</button>';
                    }
                    html += '</div></div>';
                }
                html += '</div>';
            }
            
            // Bouton voir d√©tails dans playground
            html += '<button onclick="event.stopPropagation();loadDetNiche(\'' + n.cat + '\',\'' + n.surf + '\',\'' + n.rnds.join(',') + '\',\'' + n.strat + '\',' + n.oMin + ',' + n.oMax + ')" style="width:100%;margin-top:1rem;padding:.75rem;background:var(--bg);border:1px solid var(--border);border-radius:8px;color:var(--text);font-size:.85rem;cursor:pointer">üî¨ Analyser en d√©tail dans le Playground</button>';
            
            html += '</div>'; // niche-details
            html += '</div>'; // niche-card
            
            return html;
        }
        
        function groupSimilarNiches(niches) {
            var groups = [];
            var assigned = new Array(niches.length).fill(false);
            
            for (var i = 0; i < niches.length; i++) {
                if (assigned[i]) continue;
                
                var group = [niches[i]];
                assigned[i] = true;
                
                for (var j = i + 1; j < niches.length; j++) {
                    if (assigned[j]) continue;
                    if (nichesOverlapV2(niches[i], niches[j])) {
                        group.push(niches[j]);
                        assigned[j] = true;
                    }
                }
                
                // Trier le groupe par score
                group.sort(function(a, b) { return b.score - a.score; });
                groups.push(group);
            }
            
            return groups;
        }
        
        function nichesOverlapV2(n1, n2) {
            if (n1.circuit !== n2.circuit) return false;
            if (n1.cat !== n2.cat) return false;
            if (n1.surf !== n2.surf) return false;
            if (n1.strat !== n2.strat) return false;
            
            // Rounds overlap?
            var roundsOverlap = false;
            for (var r = 0; r < n1.rnds.length; r++) {
                if (n2.rnds.indexOf(n1.rnds[r]) >= 0) {
                    roundsOverlap = true;
                    break;
                }
            }
            if (!roundsOverlap) return false;
            
            // Odds overlap?
            return !(n1.oMax < n2.oMin || n1.oMin > n2.oMax);
        }
        
        function toggleNicheCard(idx) {
            var card = document.getElementById('niche-card-' + idx);
            if (card) card.classList.toggle('expanded');
        }
        
        function toggleSimilarNiches(idx) {
            var el = document.getElementById('similar-' + idx);
            if (el) el.classList.toggle('show');
        }
        
        function filterNiches(filter, btn) {
            detV2CurrentFilter = filter;
            document.querySelectorAll('.filter-btn').forEach(function(b) { b.classList.remove('active'); });
            if (btn) btn.classList.add('active');
            renderDetectorV2Results();
        }
        
        function sortNiches(sortBy) {
            detV2CurrentSort = sortBy;
            renderDetectorV2Results();
        }
        
        function toggleSimilarGrouping() {
            detV2GroupSimilar = document.getElementById('detHideSimilar').checked;
            renderDetectorV2Results();
        }
        
        function removeNicheFromDetector(cat, surf, rnds, strat, oMin, oMax) {
            var rndsArr = typeof rnds === 'string' ? rnds.split(',') : rnds;
            var allNiches = NICHES_ATP.concat(NICHES_WTA);
            
            for (var i = 0; i < allNiches.length; i++) {
                var n = allNiches[i];
                if (!n.on) continue;
                if (n.cat !== cat || n.surf !== surf || n.strat !== strat) continue;
                if (Math.abs(n.min - oMin) > 0.1 || Math.abs(n.max - oMax) > 0.1) continue;
                
                var allRoundsMatch = n.rounds.length === rndsArr.length;
                if (allRoundsMatch) {
                    for (var j = 0; j < rndsArr.length; j++) {
                        if (n.rounds.indexOf(rndsArr[j]) < 0) {
                            allRoundsMatch = false;
                            break;
                        }
                    }
                }
                
                if (allRoundsMatch) {
                    n.on = false;
                    syncAllNichesUI();
                    renderDetectorV2Results();
                    return;
                }
            }
        }
        
        function checkActiveNichesWarnings() {
            var warnings = [];
            var curYear = new Date().getFullYear();
            
            var allActive = NICHES_ATP.filter(function(n) { return n.on; }).map(function(n) { return {niche: n, data: btDataATP, circuit: 'ATP'}; })
                .concat(NICHES_WTA.filter(function(n) { return n.on; }).map(function(n) { return {niche: n, data: btDataWTA, circuit: 'WTA'}; }));
            
            for (var i = 0; i < allActive.length; i++) {
                var item = allActive[i];
                var n = item.niche;
                
                if (item.data.length === 0) continue;
                
                var rFull = testComboV2(item.data, n.cat, n.surf, n.rounds, n.strat, n.min, n.max, 2007, curYear);
                var r3 = testComboV2(item.data, n.cat, n.surf, n.rounds, n.strat, n.min, n.max, curYear - 3, curYear);
                
                if (rFull && r3) {
                    var scoreData = calcCompositeScore(rFull, r3, null, rFull.yearlyData, 500);
                    if (scoreData.verdict === 'eviter' || (scoreData.verdict === 'surveiller' && r3.roi < 0)) {
                        warnings.push({
                            name: n.name,
                            circuit: item.circuit,
                            score: scoreData.score,
                            roiRecent: r3.roi,
                            verdict: scoreData.verdict,
                            warnings: scoreData.warnings
                        });
                    }
                }
            }
            
            var warningsEl = document.getElementById('detActiveWarnings');
            if (!warningsEl) return; // Element doesn't exist, skip
            
            if (warnings.length > 0) {
                warningsEl.style.display = 'block';
                var html = '';
                for (var i = 0; i < warnings.length; i++) {
                    var w = warnings[i];
                    html += '<div style="display:flex;align-items:center;justify-content:space-between;padding:.75rem;background:rgba(239,68,68,.1);border-radius:8px;margin-bottom:.5rem">';
                    html += '<div><strong>' + w.name + '</strong> <span class="badge ' + w.circuit.toLowerCase() + '">' + w.circuit + '</span>';
                    html += '<div style="font-size:.8rem;color:var(--muted)">Score: ' + w.score + ' ‚Ä¢ ROI 3 ans: ' + (w.roiRecent >= 0 ? '+' : '') + w.roiRecent.toFixed(0) + '%</div></div>';
                    html += '<span style="color:var(--red);font-weight:600">' + (w.verdict === 'eviter' ? '‚õî √Ä retirer' : '‚ö†Ô∏è √Ä surveiller') + '</span>';
                    html += '</div>';
                }
                var listEl = document.getElementById('detActiveWarningsList');
                if (listEl) listEl.innerHTML = html;
            } else {
                warningsEl.style.display = 'none';
            }
        }

        // ==================== MONITEUR YTD ====================
        function updateYTDMonitor() {
            var monitorCard = document.getElementById('ytdMonitorCard');
            var nichesList = document.getElementById('ytdNichesList');
            var globalStats = document.getElementById('ytdGlobalStats');
            var alertBox = document.getElementById('ytdAlertBox');
            var yearLabel = document.getElementById('ytdYear');
            
            if (!monitorCard || !nichesList) return;
            
            // V√©rifier si on a des donn√©es
            if (btDataATP.length === 0 && btDataWTA.length === 0) {
                monitorCard.style.display = 'none';
                return;
            }
            
            var currentYear = new Date().getFullYear();
            if (yearLabel) yearLabel.textContent = currentYear;
            
            // Collecter toutes les niches actives
            var allActiveNiches = [];
            
            NICHES_ATP.forEach(function(n) {
                if (n.on) allActiveNiches.push({ niche: n, data: btDataATP, circuit: 'ATP' });
            });
            
            NICHES_WTA.forEach(function(n) {
                if (n.on) allActiveNiches.push({ niche: n, data: btDataWTA, circuit: 'WTA' });
            });
            
            if (allActiveNiches.length === 0) {
                monitorCard.style.display = 'none';
                return;
            }
            
            monitorCard.style.display = 'block';
            
            // Calculer les stats YTD pour chaque niche
            var nicheResults = [];
            var totalProfit = 0;
            var totalBets = 0;
            var alerts = [];
            
            allActiveNiches.forEach(function(item) {
                var n = item.niche;
                var data = item.data;
                
                if (data.length === 0) {
                    nicheResults.push({
                        name: n.name,
                        circuit: item.circuit,
                        bets: 0,
                        wins: 0,
                        profit: 0,
                        roi: 0,
                        status: 'inactive',
                        historicalROI: null
                    });
                    return;
                }
                
                // Filtrer les matchs de l'ann√©e en cours
                var ytdMatches = data.filter(function(m) { return m.year === currentYear; });
                
                // Calculer stats YTD
                var bets = 0, wins = 0, profit = 0;
                var seen = {};
                
                ytdMatches.forEach(function(m) {
                    var key = m.date + m.p1 + m.p2;
                    if (seen[key]) return;
                    
                    if (m.category !== n.cat || m.surface !== n.surf) return;
                    if (n.rounds.indexOf(m.round) < 0) return;
                    
                    var dogOdds = Math.max(m.o1, m.o2);
                    var favOdds = Math.min(m.o1, m.o2);
                    var dogIsP1 = m.o1 > m.o2;
                    
                    var odds, won;
                    if (n.strat === 'underdog') {
                        odds = dogOdds;
                        won = dogIsP1;
                    } else {
                        odds = favOdds;
                        won = !dogIsP1;
                    }
                    
                    if (odds >= n.min && odds <= n.max) {
                        bets++;
                        if (won) wins++;
                        profit += won ? (odds - 1) : -1;
                        seen[key] = true;
                    }
                });
                
                // Calculer ROI historique (pour comparaison)
                var histMatches = data.filter(function(m) { return m.year < currentYear && m.year >= 2007; });
                var histBets = 0, histProfit = 0;
                var histSeen = {};
                
                histMatches.forEach(function(m) {
                    var key = m.date + m.p1 + m.p2;
                    if (histSeen[key]) return;
                    
                    if (m.category !== n.cat || m.surface !== n.surf) return;
                    if (n.rounds.indexOf(m.round) < 0) return;
                    
                    var dogOdds = Math.max(m.o1, m.o2);
                    var favOdds = Math.min(m.o1, m.o2);
                    var dogIsP1 = m.o1 > m.o2;
                    
                    var odds, won;
                    if (n.strat === 'underdog') {
                        odds = dogOdds;
                        won = dogIsP1;
                    } else {
                        odds = favOdds;
                        won = !dogIsP1;
                    }
                    
                    if (odds >= n.min && odds <= n.max) {
                        histBets++;
                        histProfit += won ? (odds - 1) : -1;
                        histSeen[key] = true;
                    }
                });
                
                var historicalROI = histBets > 0 ? (histProfit / histBets * 100) : null;
                var ytdROI = bets > 0 ? (profit / bets * 100) : 0;
                
                // D√©terminer le status
                var status = 'inactive';
                if (bets > 0) {
                    if (ytdROI > 5) status = 'good';
                    else if (ytdROI >= -5) status = 'neutral';
                    else status = 'bad';
                }
                
                // D√©tecter les alertes (ROI YTD < -10% avec au moins 5 paris)
                if (bets >= 5 && ytdROI < -10) {
                    alerts.push({
                        name: n.name,
                        circuit: item.circuit,
                        ytdROI: ytdROI,
                        bets: bets,
                        historicalROI: historicalROI
                    });
                }
                
                nicheResults.push({
                    name: n.name,
                    circuit: item.circuit,
                    bets: bets,
                    wins: wins,
                    profit: profit,
                    roi: ytdROI,
                    status: status,
                    historicalROI: historicalROI
                });
                
                totalProfit += profit;
                totalBets += bets;
            });
            
            // Trier par ROI (les pires en premier pour visibilit√©)
            nicheResults.sort(function(a, b) {
                if (a.status === 'inactive' && b.status !== 'inactive') return 1;
                if (a.status !== 'inactive' && b.status === 'inactive') return -1;
                return a.roi - b.roi;
            });
            
            // Afficher stats globales
            var globalROI = totalBets > 0 ? (totalProfit / totalBets * 100) : 0;
            globalStats.innerHTML = 
                '<span style="font-weight:600">' + totalBets + ' paris</span>' +
                '<span style="color:' + (totalProfit >= 0 ? 'var(--green)' : 'var(--red)') + ';font-weight:700">' + 
                    (totalProfit >= 0 ? '+' : '') + totalProfit.toFixed(1) + 'u</span>' +
                '<span style="color:' + (globalROI >= 0 ? 'var(--green)' : 'var(--red)') + ';font-weight:700">' +
                    'ROI ' + (globalROI >= 0 ? '+' : '') + globalROI.toFixed(1) + '%</span>';
            
            // Afficher alertes
            if (alerts.length > 0) {
                alertBox.style.display = 'block';
                document.getElementById('ytdAlertTitle').textContent = alerts.length + ' niche' + (alerts.length > 1 ? 's' : '') + ' en difficult√©';
                
                var alertHtml = '';
                alerts.forEach(function(a) {
                    var variance = a.historicalROI !== null ? 
                        ' (historique: ' + (a.historicalROI >= 0 ? '+' : '') + a.historicalROI.toFixed(0) + '%)' : '';
                    alertHtml += '<div style="padding:.4rem 0;border-bottom:1px solid rgba(239,68,68,.2)">' +
                        '<strong>' + a.name + '</strong> <span style="font-size:.75rem;color:var(--muted)">' + a.circuit + '</span><br>' +
                        '<span style="color:var(--red)">' + a.ytdROI.toFixed(0) + '% ROI</span> sur ' + a.bets + ' paris' + variance +
                        '</div>';
                });
                document.getElementById('ytdAlertContent').innerHTML = alertHtml;
            } else {
                alertBox.style.display = 'none';
            }
            
            // Afficher la liste des niches
            var statusIcons = {
                'good': 'üü¢',
                'neutral': 'üü°',
                'bad': 'üî¥',
                'inactive': '‚ö™'
            };
            
            var statusColors = {
                'good': 'var(--green)',
                'neutral': 'var(--yellow)',
                'bad': 'var(--red)',
                'inactive': 'var(--muted)'
            };
            
            var html = '';
            nicheResults.forEach(function(r) {
                var icon = statusIcons[r.status];
                var color = statusColors[r.status];
                var circuitBadge = r.circuit === 'ATP' ? 
                    '<span style="font-size:.65rem;padding:.1rem .3rem;background:var(--green);color:#000;border-radius:3px;margin-left:.5rem">ATP</span>' :
                    '<span style="font-size:.65rem;padding:.1rem .3rem;background:var(--pink);color:#000;border-radius:3px;margin-left:.5rem">WTA</span>';
                
                var roiText = r.bets > 0 ? 
                    ((r.roi >= 0 ? '+' : '') + r.roi.toFixed(0) + '%') : 
                    '-';
                
                var profitText = r.bets > 0 ?
                    ((r.profit >= 0 ? '+' : '') + r.profit.toFixed(1) + 'u') :
                    '-';
                
                var recordText = r.bets > 0 ?
                    (r.wins + 'W-' + (r.bets - r.wins) + 'L') :
                    'Pas de paris';
                
                var histText = r.historicalROI !== null ?
                    '<span style="font-size:.7rem;color:var(--muted)">(hist: ' + (r.historicalROI >= 0 ? '+' : '') + r.historicalROI.toFixed(0) + '%)</span>' :
                    '';
                
                html += '<div style="display:flex;align-items:center;justify-content:space-between;padding:.6rem .75rem;background:var(--bg);border:1px solid var(--border);border-radius:6px;border-left:4px solid ' + color + '">';
                html += '<div style="flex:1">';
                html += '<span style="font-size:1.1rem;margin-right:.5rem">' + icon + '</span>';
                html += '<span style="font-weight:600;font-size:.85rem">' + r.name + '</span>' + circuitBadge;
                html += '</div>';
                html += '<div style="display:flex;gap:1rem;align-items:center;font-family:\'JetBrains Mono\',monospace;font-size:.8rem">';
                html += '<span style="color:var(--muted);min-width:60px;text-align:center">' + recordText + '</span>';
                html += '<span style="min-width:50px;text-align:right;color:' + (r.profit >= 0 ? 'var(--green)' : 'var(--red)') + '">' + profitText + '</span>';
                html += '<span style="min-width:50px;text-align:right;font-weight:700;color:' + color + '">' + roiText + '</span>';
                html += histText;
                html += '</div>';
                html += '</div>';
            });
            
            nichesList.innerHTML = html;
        }

        // ==================== PORTFOLIO BUILDER ====================
        var pfCircuit = 'both';  // 'atp', 'wta', ou 'both'

        function setPortfolioCircuit(c) {
            pfCircuit = c;
            document.getElementById('pfCircuitATP').classList.toggle('active', c === 'atp');
            document.getElementById('pfCircuitWTA').classList.toggle('active', c === 'wta');
            document.getElementById('pfCircuitBoth').classList.toggle('active', c === 'both');
        }

        // Generateur dynamique de toutes les niches possibles (version exhaustive)
        function generateAllNiches(circuit) {
            var niches = [];
            var cats_atp = ['Grand Slam', 'Masters 1000', 'ATP 500', 'ATP 250'];
            var cats_wta = ['Grand Slam', 'WTA 1000', 'WTA 500', 'WTA 250'];
            var surfaces = ['Hard', 'Clay', 'Grass'];
            var strategies = ['underdog', 'favorite'];

            // Rounds individuels et combinaisons utiles
            var roundCombos = [
                ['F'], ['SF'], ['QF'], ['R16'], ['R32'], ['R64'],
                ['F', 'SF'], ['SF', 'QF'], ['QF', 'R16'], ['R16', 'R32'], ['R32', 'R64'],
                ['F', 'SF', 'QF'], ['QF', 'R16', 'R32'], ['R16', 'R32', 'R64'],
                ['F', 'SF', 'QF', 'R16']
            ];

            // Ranges de cotes plus fines (par pas de 0.5)
            var oddsRanges = [
                { min: 1.2, max: 1.5 },
                { min: 1.5, max: 2.0 },
                { min: 2.0, max: 2.5 },
                { min: 2.5, max: 3.0 },
                { min: 3.0, max: 3.5 },
                { min: 3.5, max: 4.0 },
                { min: 4.0, max: 5.0 },
                { min: 5.0, max: 7.0 },
                { min: 1.5, max: 2.5 },
                { min: 2.0, max: 3.0 },
                { min: 2.5, max: 3.5 },
                { min: 3.0, max: 4.0 }
            ];

            var circuits = [];
            if (circuit === 'atp' || circuit === 'both') circuits.push({ name: 'atp', cats: cats_atp });
            if (circuit === 'wta' || circuit === 'both') circuits.push({ name: 'wta', cats: cats_wta });

            for (var c = 0; c < circuits.length; c++) {
                var circ = circuits[c];
                for (var cat = 0; cat < circ.cats.length; cat++) {
                    for (var surf = 0; surf < surfaces.length; surf++) {
                        for (var rnd = 0; rnd < roundCombos.length; rnd++) {
                            for (var strat = 0; strat < strategies.length; strat++) {
                                for (var odds = 0; odds < oddsRanges.length; odds++) {
                                    niches.push({
                                        circuit: circ.name,
                                        cat: circ.cats[cat],
                                        surf: surfaces[surf],
                                        rounds: roundCombos[rnd],
                                        strat: strategies[strat],
                                        min: oddsRanges[odds].min,
                                        max: oddsRanges[odds].max
                                    });
                                }
                            }
                        }
                    }
                }
            }
            return niches;
        }

        // Backtester une niche sur une periode donnee
        function backtestNichePeriod(niche, data, yearStart, yearEnd) {
            if (!data || data.length === 0) return null;

            var filtered = data.filter(function(m) { return m.year >= yearStart && m.year <= yearEnd; });
            var wins = 0, losses = 0, profit = 0;

            for (var i = 0; i < filtered.length; i++) {
                var m = filtered[i];
                if (m.category !== niche.cat) continue;
                if (m.surface !== niche.surf) continue;
                if (niche.rounds.indexOf(m.round) === -1) continue;

                var dogOdds = Math.max(m.o1, m.o2);
                var favOdds = Math.min(m.o1, m.o2);
                var dogIsP1 = m.o1 > m.o2;

                var odds, won;
                if (niche.strat === 'underdog') {
                    odds = dogOdds;
                    won = dogIsP1;
                } else {
                    odds = favOdds;
                    won = !dogIsP1;
                }

                if (odds >= niche.min && odds <= niche.max) {
                    if (won) {
                        wins++;
                        profit += odds - 1;
                    } else {
                        losses++;
                        profit -= 1;
                    }
                }
            }

            var total = wins + losses;
            if (total < 15) return null;  // Minimum 15 paris par periode

            return {
                bets: total,
                wins: wins,
                profit: profit,
                roi: (profit / total) * 100
            };
        }

        // Backtester une niche sur les donnees
        function backtestNicheForPortfolio(niche, data, yearStart, yearEnd) {
            if (!data || data.length === 0) return null;

            var filtered = data.filter(function(m) { return m.year >= yearStart && m.year <= yearEnd; });
            var wins = 0, losses = 0, profit = 0;
            var bets = [];

            for (var i = 0; i < filtered.length; i++) {
                var m = filtered[i];
                // Matching exact comme dans processBacktestForCircuit
                if (m.category !== niche.cat) continue;
                if (m.surface !== niche.surf) continue;
                if (niche.rounds.indexOf(m.round) === -1) continue;

                var dogOdds = Math.max(m.o1, m.o2);
                var favOdds = Math.min(m.o1, m.o2);
                var dogIsP1 = m.o1 > m.o2;

                var odds, won;
                if (niche.strat === 'underdog') {
                    odds = dogOdds;
                    won = dogIsP1;  // player1 gagne toujours dans les donnees normalisees
                } else {
                    odds = favOdds;
                    won = !dogIsP1;
                }

                if (odds >= niche.min && odds <= niche.max) {
                    if (won) {
                        wins++;
                        profit += odds - 1;
                    } else {
                        losses++;
                        profit -= 1;
                    }
                    bets.push({ date: m.date, year: m.year, won: won, odds: odds, pnl: won ? odds - 1 : -1 });
                }
            }

            var total = wins + losses;
            if (total < 40) return null;  // Minimum 40 paris sur periode complete (2007-2025)

            return {
                niche: niche,
                bets: total,
                betsPerYear: total / (yearEnd - yearStart + 1),
                wins: wins,
                winrate: (wins / total) * 100,
                roi: (profit / total) * 100,
                profit: profit,
                history: bets
            };
        }

        // Generer les 3 portfolios
        async function buildPortfolios() {
            try {
                console.log('[Portfolio] Demarrage...');
                console.log('[Portfolio] Circuit:', pfCircuit);

                var targetPicks = parseInt(document.getElementById('pfTargetSlider').value);

                // Verifier que les donnees sont chargees
                if ((pfCircuit === 'atp' || pfCircuit === 'both') && (!btDataATP || btDataATP.length === 0)) {
                    showToast('Donnees ATP non chargees - Va dans Backtest et charge les donnees', 'error');
                    return;
                }
                if ((pfCircuit === 'wta' || pfCircuit === 'both') && (!btDataWTA || btDataWTA.length === 0)) {
                    showToast('Donnees WTA non chargees - Va dans Backtest et charge les donnees', 'error');
                    return;
                }

                // NOUVELLE APPROCHE: Utiliser les niches ajoutees par l'utilisateur
                var userNiches = [];
                if (pfCircuit === 'atp' || pfCircuit === 'both') {
                    NICHES_ATP.forEach(function(n) {
                        userNiches.push({ niche: n, circuit: 'atp', data: btDataATP });
                    });
                }
                if (pfCircuit === 'wta' || pfCircuit === 'both') {
                    NICHES_WTA.forEach(function(n) {
                        userNiches.push({ niche: n, circuit: 'wta', data: btDataWTA });
                    });
                }

                console.log('[Portfolio] Niches utilisateur trouvees:', userNiches.length);

                if (userNiches.length === 0) {
                    showToast('Aucune niche ajoutee! Va dans le Detecteur pour en trouver.', 'error');
                    return;
                }

                // Afficher le loading
                document.getElementById('pfLoading').style.display = 'block';
                document.getElementById('pfResults').style.display = 'none';
                await new Promise(function(r) { setTimeout(r, 50); });

                // Periodes pour validation train/test
                var trainStart = 2007, trainEnd = 2019;
                var testStart = 2020, testEnd = 2025;
                var fullStart = 2007, fullEnd = 2025;
                var yearsCount = fullEnd - fullStart + 1;
                var curYear = new Date().getFullYear();

                // Analyser chaque niche utilisateur
                var nicheResults = [];
                var totalNiches = userNiches.length;

                for (var i = 0; i < totalNiches; i++) {
                    var item = userNiches[i];
                    var n = item.niche;
                    var data = item.data;

                    document.getElementById('pfLoadingProgress').textContent = 'Analyse niche ' + (i + 1) + '/' + totalNiches + ': ' + n.name;
                    await new Promise(function(r) { setTimeout(r, 10); });

                    // Utiliser testComboV2 comme le Detecteur
                    var rTrain = testComboV2(data, n.cat, n.surf, n.rounds, n.strat, n.min, n.max, trainStart, trainEnd);
                    var rTest = testComboV2(data, n.cat, n.surf, n.rounds, n.strat, n.min, n.max, testStart, testEnd);
                    var rFull = testComboV2(data, n.cat, n.surf, n.rounds, n.strat, n.min, n.max, fullStart, fullEnd);
                    var r3 = testComboV2(data, n.cat, n.surf, n.rounds, n.strat, n.min, n.max, curYear - 3, curYear);

                    if (!rFull || rFull.bets < 30) continue;

                    var trainROI = rTrain ? rTrain.roi : 0;
                    var testROI = rTest ? rTest.roi : 0;
                    var trainBets = rTrain ? rTrain.bets : 0;
                    var testBets = rTest ? rTest.bets : 0;
                    var roi3 = r3 ? r3.roi : 0;

                    // Calculer le profit a partir du ROI (profit = roi * bets / 100)
                    var profit = rFull.roi * rFull.bets / 100;

                    // Calculer le score comme dans le Detecteur
                    var scoreData = null;
                    if (rFull.bets >= 10) {
                        scoreData = calcCompositeScore(rFull, r3, null, rFull.yearlyData || [], 100);
                    }

                    nicheResults.push({
                        niche: { cat: n.cat, surf: n.surf, rounds: n.rounds, strat: n.strat, min: n.min, max: n.max, circuit: item.circuit },
                        name: n.name,
                        bets: rFull.bets,
                        betsPerYear: rFull.bets / rFull.yrs,
                        wins: rFull.wins,
                        winrate: (rFull.wins / rFull.bets) * 100,
                        roi: rFull.roi,
                        profit: profit,
                        maxDD: rFull.maxDD || 0,
                        trainROI: trainROI,
                        testROI: testROI,
                        trainBets: trainBets,
                        testBets: testBets,
                        roi3: roi3,
                        score: scoreData ? scoreData.score : 0,
                        verdict: scoreData ? scoreData.verdict : 'unknown',
                        isValidated: trainROI > 0 && testROI > 0
                    });

                    console.log('[Portfolio] Niche:', n.name, '| Bets:', rFull.bets, '| ROI:', rFull.roi.toFixed(1) + '%', '| DD:', rFull.maxDD, '| Train:', trainROI.toFixed(1) + '%', '| Test:', testROI.toFixed(1) + '%');
                }

                console.log('[Portfolio] === RESUME ===');
                console.log('[Portfolio] Niches analysees:', nicheResults.length);
                document.getElementById('pfLoadingProgress').textContent = 'Construction des portfolios...';

            // Trier par ROI decroissant
            nicheResults.sort(function(a, b) { return b.roi - a.roi; });

            // Calculer le volume mensuel cible (picks/mois = picks/an / 12)
            var targetPerMonth = targetPicks;
            var targetPerYear = targetPerMonth * 12;

            // ======== PORTFOLIO 1: MAX ROI (Rentabilite pure) ========
            // SEULEMENT les niches avec ROI >= 15% - peu importe le volume
            var pfMaxRoi = { niches: [], totalBets: 0, totalProfit: 0, name: 'Max ROI', allNiches: nicheResults };
            var highRoiNiches = nicheResults.filter(function(n) { return n.roi >= 15; });
            highRoiNiches.sort(function(a, b) { return b.roi - a.roi; });
            for (var i = 0; i < highRoiNiches.length; i++) {
                pfMaxRoi.niches.push(highRoiNiches[i]);
                pfMaxRoi.totalBets += highRoiNiches[i].bets;
                pfMaxRoi.totalProfit += highRoiNiches[i].profit;
            }
            pfMaxRoi.betsPerMonth = (pfMaxRoi.totalBets / yearsCount) / 12;
            pfMaxRoi.roi = pfMaxRoi.totalBets > 0 ? (pfMaxRoi.totalProfit / pfMaxRoi.totalBets) * 100 : 0;

            // ======== PORTFOLIO 2: EQUILIBRE (Cible volume avec bon ROI) ========
            // Atteindre le volume cible avec les meilleures niches (ROI >= 5%)
            var pfBalanced = { niches: [], totalBets: 0, totalProfit: 0, name: 'Equilibre', allNiches: nicheResults };
            var balancedNiches = nicheResults.filter(function(n) { return n.roi >= 5; });
            // Trier par ROI decroissant pour prendre les meilleurs d'abord
            balancedNiches.sort(function(a, b) { return b.roi - a.roi; });
            for (var i = 0; i < balancedNiches.length && pfBalanced.totalBets / yearsCount < targetPerYear; i++) {
                pfBalanced.niches.push(balancedNiches[i]);
                pfBalanced.totalBets += balancedNiches[i].bets;
                pfBalanced.totalProfit += balancedNiches[i].profit;
            }
            pfBalanced.betsPerMonth = (pfBalanced.totalBets / yearsCount) / 12;
            pfBalanced.roi = pfBalanced.totalBets > 0 ? (pfBalanced.totalProfit / pfBalanced.totalBets) * 100 : 0;

            // ======== PORTFOLIO 3: MAX VOLUME (Regularite) ========
            // TOUTES les niches avec ROI > 0 pour maximiser le volume
            var pfMaxVolume = { niches: [], totalBets: 0, totalProfit: 0, name: 'Max Volume', allNiches: nicheResults };
            var volumeNiches = nicheResults.filter(function(n) { return n.roi > 0; });
            volumeNiches.sort(function(a, b) { return b.betsPerYear - a.betsPerYear; });
            for (var i = 0; i < volumeNiches.length; i++) {
                pfMaxVolume.niches.push(volumeNiches[i]);
                pfMaxVolume.totalBets += volumeNiches[i].bets;
                pfMaxVolume.totalProfit += volumeNiches[i].profit;
            }
            pfMaxVolume.betsPerMonth = (pfMaxVolume.totalBets / yearsCount) / 12;
            pfMaxVolume.roi = pfMaxVolume.totalBets > 0 ? (pfMaxVolume.totalProfit / pfMaxVolume.totalBets) * 100 : 0;

            // Cacher le loading
            document.getElementById('pfLoading').style.display = 'none';
            document.getElementById('pfResults').style.display = 'block';

            // Calculer volume max disponible avec toutes les niches validees
            var totalMaxBets = nicheResults.reduce(function(sum, n) { return sum + n.bets; }, 0);
            var totalMaxProfit = nicheResults.reduce(function(sum, n) { return sum + n.profit; }, 0);
            var maxBetsPerMonth = (totalMaxBets / yearsCount) / 12;
            var maxCombinedRoi = totalMaxBets > 0 ? (totalMaxProfit / totalMaxBets) * 100 : 0;

            // Compter les niches validees (train/test positif)
            var validatedNiches = nicheResults.filter(function(n) { return n.isValidated; });

            // ======== TRIER ET CALCULER LA STRATEGIE RECOMMANDEE ========
            nicheResults.sort(function(a, b) { return b.score - a.score; });

            // Calculer ou tombe la cible
            var cumBets = 0;
            var cumProfit = 0;
            var targetReachedAt = -1;
            var recNiches = 0;
            var recVolume = 0;
            var recRoi = 0;

            for (var calc = 0; calc < nicheResults.length; calc++) {
                cumBets += nicheResults[calc].bets;
                cumProfit += nicheResults[calc].profit;
                var cumPicksMonth = (cumBets / yearsCount) / 12;
                if (targetReachedAt < 0 && cumPicksMonth >= targetPicks) {
                    targetReachedAt = calc;
                    recNiches = calc + 1;
                    recVolume = cumPicksMonth;
                    recRoi = cumBets > 0 ? (cumProfit / cumBets) * 100 : 0;
                }
            }
            // Si cible jamais atteinte, prendre tout
            if (targetReachedAt < 0) {
                recNiches = nicheResults.length;
                recVolume = maxBetsPerMonth;
                recRoi = maxCombinedRoi;
            }

            // Afficher le resume avec STRATEGIE RECOMMANDEE
            var summaryHtml = '';

            // Bloc strategie recommandee (en fonction de la cible)
            summaryHtml += '<div style="margin-bottom:.75rem;padding:.75rem;background:rgba(34,197,94,0.15);border:2px solid var(--green);border-radius:8px">';
            summaryHtml += '<div style="font-size:.85rem;font-weight:700;color:var(--green);margin-bottom:.5rem">üéØ Strategie pour ' + targetPicks + ' picks/mois</div>';
            summaryHtml += '<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:.5rem">';
            summaryHtml += '<div style="text-align:center;padding:.5rem;background:var(--bg);border-radius:4px"><div style="font-size:1.3rem;font-weight:700;color:var(--green)">' + recNiches + '</div><div style="font-size:.65rem;color:var(--muted)">Niches a garder</div></div>';
            summaryHtml += '<div style="text-align:center;padding:.5rem;background:var(--bg);border-radius:4px"><div style="font-size:1.3rem;font-weight:700;color:var(--blue)">' + recVolume.toFixed(1) + '</div><div style="font-size:.65rem;color:var(--muted)">Picks/mois</div></div>';
            summaryHtml += '<div style="text-align:center;padding:.5rem;background:var(--bg);border-radius:4px"><div style="font-size:1.3rem;font-weight:700;color:' + (recRoi >= 10 ? 'var(--green)' : 'var(--yellow)') + '">+' + recRoi.toFixed(1) + '%</div><div style="font-size:.65rem;color:var(--muted)">ROI</div></div>';
            summaryHtml += '</div></div>';

            // Stats globales (plus petites)
            summaryHtml += '<div style="font-size:.7rem;color:var(--muted);margin-bottom:.5rem">Stats globales (toutes niches):</div>';
            summaryHtml += '<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(100px,1fr));gap:.3rem;margin-bottom:.5rem">';
            summaryHtml += '<div style="padding:.3rem;background:var(--bg);border-radius:4px;text-align:center;font-size:.65rem"><span style="color:var(--muted)">Total:</span> <strong>' + nicheResults.length + '</strong> niches</div>';
            summaryHtml += '<div style="padding:.3rem;background:var(--bg);border-radius:4px;text-align:center;font-size:.65rem"><span style="color:var(--muted)">Max:</span> <strong>' + maxBetsPerMonth.toFixed(1) + '</strong> p/m</div>';
            summaryHtml += '<div style="padding:.3rem;background:var(--bg);border-radius:4px;text-align:center;font-size:.65rem"><span style="color:var(--muted)">ROI max:</span> <strong>+' + maxCombinedRoi.toFixed(1) + '%</strong></div>';
            summaryHtml += '</div>';

            // Avertissement si volume max < cible
            if (maxBetsPerMonth < targetPicks) {
                summaryHtml += '<div style="background:rgba(251,191,36,0.2);border:1px solid var(--yellow);padding:.5rem;border-radius:6px;font-size:.75rem">';
                summaryHtml += '<strong style="color:var(--yellow)">‚ö†Ô∏è</strong> Volume insuffisant pour atteindre ' + targetPicks + ' picks/mois. Ajoute des niches dans le Detecteur.';
                summaryHtml += '</div>';
            }

            document.getElementById('pfSummary').innerHTML = summaryHtml;

            // ======== LISTE TRIEE ========
            // Reset cumuls pour l'affichage
            cumBets = 0;
            cumProfit = 0;

            var compHtml = '<div class="card">';
            compHtml += '<div style="font-size:1rem;font-weight:700;margin-bottom:.5rem">üìä Classement de tes niches</div>';
            compHtml += '<p style="font-size:.75rem;color:var(--muted);margin-bottom:.75rem">Triees par score. Meilleures en haut, moins bonnes en bas. La ligne verte indique ou tu atteins ta cible de ' + targetPicks + ' picks/mois.</p>';

            // En-tete du tableau
            compHtml += '<div style="overflow-x:auto">';
            compHtml += '<table style="width:100%;font-size:.6rem;border-collapse:collapse">';
            compHtml += '<thead><tr style="background:var(--bg);position:sticky;top:0">';
            compHtml += '<th style="padding:.25rem;text-align:left;border-bottom:2px solid var(--border)">#</th>';
            compHtml += '<th style="padding:.25rem;text-align:left;border-bottom:2px solid var(--border)">Niche</th>';
            compHtml += '<th style="padding:.25rem;text-align:center;border-bottom:2px solid var(--border)">p/m</th>';
            compHtml += '<th style="padding:.25rem;text-align:center;border-bottom:2px solid var(--border)" title="ROI depuis 2007">ROI</th>';
            compHtml += '<th style="padding:.25rem;text-align:center;border-bottom:2px solid var(--border)" title="ROI 3 dernieres annees">3ans</th>';
            compHtml += '<th style="padding:.25rem;text-align:center;border-bottom:2px solid var(--border);color:var(--red)" title="Max Drawdown en unites">DD</th>';
            compHtml += '<th style="padding:.25rem;text-align:center;border-bottom:2px solid var(--border)">Sc</th>';
            compHtml += '<th style="padding:.25rem;text-align:center;border-bottom:2px solid var(--border);color:var(--blue)" title="Cumul picks/mois">Œ£p/m</th>';
            compHtml += '<th style="padding:.25rem;text-align:center;border-bottom:2px solid var(--border);color:var(--blue)" title="ROI cumule">Œ£ROI</th>';
            compHtml += '</tr></thead><tbody>';

            for (var i = 0; i < nicheResults.length; i++) {
                var n = nicheResults[i];
                var picksPerMonth = n.betsPerYear / 12;
                cumBets += n.bets;
                cumProfit += n.profit;
                var cumPicksMonth = (cumBets / yearsCount) / 12;
                var cumRoi = cumBets > 0 ? (cumProfit / cumBets) * 100 : 0;

                // Verifier si c'est la ligne ou la cible est atteinte
                var isTargetLine = (i === targetReachedAt);

                var circuitBadge = n.niche.circuit === 'atp' ? '<span style="color:var(--green);font-weight:700">A</span>' : '<span style="color:var(--pink);font-weight:700">W</span>';
                var roiColor = n.roi >= 20 ? 'var(--green)' : n.roi >= 10 ? 'var(--blue)' : n.roi >= 0 ? 'var(--yellow)' : 'var(--red)';
                var roi3Color = n.roi3 >= 20 ? 'var(--green)' : n.roi3 >= 10 ? 'var(--blue)' : n.roi3 >= 0 ? 'var(--yellow)' : 'var(--red)';
                var scoreColor = n.score >= 60 ? 'var(--green)' : n.score >= 40 ? 'var(--blue)' : 'var(--yellow)';
                var rowBg = isTargetLine ? 'background:rgba(34,197,94,0.2);border:2px solid var(--green)' : (i % 2 === 0 ? 'background:var(--bg)' : '');
                var roi3Display = n.roi3 ? (n.roi3 >= 0 ? '+' : '') + n.roi3.toFixed(0) + '%' : '-';

                compHtml += '<tr style="' + rowBg + '">';
                compHtml += '<td style="padding:.3rem;border-bottom:1px solid var(--border);font-weight:600">' + (i + 1) + '</td>';
                compHtml += '<td style="padding:.3rem;border-bottom:1px solid var(--border);max-width:150px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap" title="' + n.name + '">' + circuitBadge + ' ' + n.name + '</td>';
                compHtml += '<td style="padding:.3rem;border-bottom:1px solid var(--border);text-align:center">' + picksPerMonth.toFixed(1) + '</td>';
                compHtml += '<td style="padding:.3rem;border-bottom:1px solid var(--border);text-align:center;color:' + roiColor + ';font-weight:600">+' + n.roi.toFixed(0) + '%</td>';
                compHtml += '<td style="padding:.3rem;border-bottom:1px solid var(--border);text-align:center;color:' + roi3Color + ';font-weight:600">' + roi3Display + '</td>';
                compHtml += '<td style="padding:.3rem;border-bottom:1px solid var(--border);text-align:center;color:var(--red)">-' + (n.maxDD ? n.maxDD.toFixed(1) : '0') + '</td>';
                compHtml += '<td style="padding:.3rem;border-bottom:1px solid var(--border);text-align:center;color:' + scoreColor + ';font-weight:600">' + n.score + '</td>';
                compHtml += '<td style="padding:.3rem;border-bottom:1px solid var(--border);text-align:center;color:var(--blue);font-weight:600">' + cumPicksMonth.toFixed(1) + '</td>';
                compHtml += '<td style="padding:.3rem;border-bottom:1px solid var(--border);text-align:center;color:' + (cumRoi >= 15 ? 'var(--green)' : cumRoi >= 10 ? 'var(--blue)' : 'var(--yellow)') + ';font-weight:600">+' + cumRoi.toFixed(1) + '%</td>';
                compHtml += '</tr>';

                // Ajouter une ligne de separation apres la cible atteinte
                if (isTargetLine) {
                    compHtml += '<tr><td colspan="9" style="padding:.3rem;background:var(--green);color:#000;text-align:center;font-weight:700;font-size:.6rem">';
                    compHtml += '‚ñ≤ CIBLE ' + targetPicks + ' p/m ATTEINTE (' + (i + 1) + ' niches, ROI +' + cumRoi.toFixed(1) + '%) ‚ñ≤';
                    compHtml += '</td></tr>';
                }
            }

            compHtml += '</tbody></table></div>';

            // Stocker les niches a desactiver pour le bouton Appliquer
            window.pfNichesToDisable = [];
            if (targetReachedAt >= 0) {
                for (var d = targetReachedAt + 1; d < nicheResults.length; d++) {
                    window.pfNichesToDisable.push({
                        name: nicheResults[d].name,
                        circuit: nicheResults[d].niche.circuit
                    });
                }
            }

            // Resume en bas
            if (targetReachedAt >= 0) {
                compHtml += '<div style="margin-top:.75rem;padding:.75rem;background:rgba(34,197,94,0.15);border:1px solid var(--green);border-radius:6px">';
                compHtml += '<div style="font-size:.75rem;margin-bottom:.5rem"><strong style="color:var(--green)">‚úì Recommandation:</strong> Active les <strong>' + (targetReachedAt + 1) + ' premieres niches</strong> pour atteindre ta cible.</div>';

                if (window.pfNichesToDisable.length > 0) {
                    compHtml += '<div style="display:flex;gap:.5rem;align-items:center;flex-wrap:wrap">';
                    compHtml += '<button onclick="applyPortfolioStrategy()" style="background:var(--green);color:#000;border:none;padding:.5rem 1rem;border-radius:6px;font-weight:700;cursor:pointer;font-size:.8rem">‚úì Appliquer (desactiver ' + window.pfNichesToDisable.length + ' niches)</button>';
                    compHtml += '<span style="font-size:.7rem;color:var(--muted)">Desactive automatiquement les niches sous la ligne verte</span>';
                    compHtml += '</div>';
                } else {
                    compHtml += '<div style="font-size:.7rem;color:var(--muted)">Toutes tes niches sont deja optimales pour cette cible.</div>';
                }
                compHtml += '</div>';
            } else {
                compHtml += '<div style="margin-top:.75rem;padding:.5rem;background:rgba(251,191,36,0.15);border:1px solid var(--yellow);border-radius:6px;font-size:.75rem">';
                compHtml += '<strong style="color:var(--yellow)">‚ö†Ô∏è Volume insuffisant:</strong> Toutes tes niches combinees = ' + maxBetsPerMonth.toFixed(1) + ' picks/mois. ';
                compHtml += 'Ajoute plus de niches dans le Detecteur pour atteindre ' + targetPicks + ' picks/mois.';
                compHtml += '</div>';
            }

            compHtml += '</div>';

            // Stocker les resultats pour l'optimiseur
            window.pfNicheResults = nicheResults;
            window.pfUserNiches = userNiches;

            // Ajouter bouton Optimiser Combos
            compHtml += '<div style="margin-top:1rem;padding-top:1rem;border-top:1px solid var(--border)">';
            compHtml += '<button onclick="optimizeCombos()" style="background:var(--purple);color:#fff;border:none;padding:.6rem 1.2rem;border-radius:6px;font-weight:700;cursor:pointer;font-size:.8rem;width:100%">';
            compHtml += 'üî¨ Optimiser Combinaisons (ROI/Volume/DD)';
            compHtml += '</button>';
            compHtml += '<div id="pfOptResults" style="margin-top:.75rem"></div>';
            compHtml += '</div>';

            document.getElementById('pfComparison').innerHTML = compHtml;
            showToast('Portfolios generes avec succes', 'success');
            console.log('[Portfolio] Termine avec succes');

            } catch (err) {
                console.error('[Portfolio] Erreur:', err);
                document.getElementById('pfLoading').style.display = 'none';
                showToast('Erreur: ' + err.message, 'error');
            }
        }

        function applyPortfolioStrategy() {
            if (!window.pfNichesToDisable || window.pfNichesToDisable.length === 0) {
                showToast('Aucune niche a desactiver', 'info');
                return;
            }

            var count = 0;
            for (var i = 0; i < window.pfNichesToDisable.length; i++) {
                var item = window.pfNichesToDisable[i];
                var niches = item.circuit === 'atp' ? NICHES_ATP : NICHES_WTA;

                // Trouver la niche par son nom
                for (var j = 0; j < niches.length; j++) {
                    if (niches[j].name === item.name) {
                        niches[j].on = false;
                        count++;
                        console.log('[Portfolio] Desactive:', item.name);
                        break;
                    }
                }
            }

            // Sauvegarder les changements
            saveNiches();

            // Rafraichir les affichages
            if (typeof renderNichesList === 'function') renderNichesList();
            if (typeof renderNichesInLab === 'function') renderNichesInLab();
            if (typeof updateSimDisplay === 'function') updateSimDisplay();

            showToast(count + ' niches desactivees avec succes!', 'success');

            // Relancer le calcul pour mettre a jour l'affichage
            buildPortfolios();
        }

        // ============================================
        // OPTIMISEUR DE COMBINAISONS
        // Trouve les meilleures combos de niches selon ROI/Volume/DD
        // ============================================
        async function optimizeCombos() {
            console.log('[Optimizer] Fonction appelee');
            console.log('[Optimizer] pfNicheResults:', window.pfNicheResults ? window.pfNicheResults.length : 'null');
            console.log('[Optimizer] pfUserNiches:', window.pfUserNiches ? window.pfUserNiches.length : 'null');

            if (!window.pfNicheResults || window.pfNicheResults.length === 0) {
                showToast('Lance d\'abord le calcul Portfolio', 'warning');
                return;
            }

            var container = document.getElementById('pfOptResults');
            if (!container) {
                console.error('[Optimizer] Container pfOptResults non trouve!');
                showToast('Erreur: container non trouve', 'error');
                return;
            }
            container.innerHTML = '<div style="text-align:center;padding:1rem;color:var(--muted)">‚è≥ Calcul des combinaisons optimales...</div>';

            await new Promise(function(r) { setTimeout(r, 100); });

            try {
                var niches = window.pfNicheResults;
                var userNiches = window.pfUserNiches;
                var sliderEl = document.getElementById('pfTargetSlider');
                var targetPicks = sliderEl ? parseInt(sliderEl.value) : 35;
                console.log('[Optimizer] Slider trouve:', !!sliderEl, '| Target:', targetPicks);

                console.log('[Optimizer] Demarrage avec', niches.length, 'niches, cible:', targetPicks, 'picks/mois');

                // Version simple - utilise stats pre-calculees, DD = max des DD individuels
                function calcComboStats(combo) {
                    var totalBets = 0;
                    var totalProfit = 0;
                    var maxDD = 0;

                    for (var i = 0; i < combo.length; i++) {
                        var n = combo[i];
                        totalBets += n.bets;
                        totalProfit += n.profit;
                        // DD = max des DD individuels (approximation realiste)
                        if ((n.maxDD || 0) > maxDD) maxDD = n.maxDD;
                    }

                    var roi = totalBets > 0 ? (totalProfit / totalBets) * 100 : 0;
                    var betsPerMonth = totalBets / (18 * 12);

                    return { bets: totalBets, profit: totalProfit, roi: roi, maxDD: maxDD, betsPerMonth: betsPerMonth };
                }

                // Generer des combinaisons intelligentes
                var combos = [];
                var n = niches.length;
                console.log('[Optimizer] Nombre de niches:', n);

                // Strategie 1: Top N par ROI (greedy jusqu'a la cible)
                console.log('[Optimizer] Strategie 1: Max ROI...');
                var sortedByRoi = niches.slice().sort(function(a, b) { return b.roi - a.roi; });
                for (var size = 3; size <= Math.min(n, 15); size++) {
                    var combo = sortedByRoi.slice(0, size);
                    var stats = calcComboStats(combo);
                    if (stats.betsPerMonth >= targetPicks * 0.5) {
                        combos.push({ type: 'Max ROI', size: size, niches: combo, stats: stats });
                    }
                }

                // Strategie 2: Top N par Score
                console.log('[Optimizer] Strategie 2: Max Score...');
                var sortedByScore = niches.slice().sort(function(a, b) { return b.score - a.score; });
                for (var size = 3; size <= Math.min(n, 15); size++) {
                    var combo = sortedByScore.slice(0, size);
                    var stats = calcComboStats(combo);
                    if (stats.betsPerMonth >= targetPicks * 0.5) {
                        combos.push({ type: 'Max Score', size: size, niches: combo, stats: stats });
                    }
                }

                // Strategie 3: Meilleur ratio ROI/DD
                console.log('[Optimizer] Strategie 3: Min DD/ROI...');
                var sortedByRatio = niches.slice().sort(function(a, b) {
                    var ratioA = a.maxDD > 0 ? a.roi / a.maxDD : a.roi;
                    var ratioB = b.maxDD > 0 ? b.roi / b.maxDD : b.roi;
                    return ratioB - ratioA;
                });
                for (var size = 3; size <= Math.min(n, 15); size++) {
                    var combo = sortedByRatio.slice(0, size);
                    var stats = calcComboStats(combo);
                    if (stats.betsPerMonth >= targetPicks * 0.5) {
                        combos.push({ type: 'Min DD/ROI', size: size, niches: combo, stats: stats });
                    }
                }

                console.log('[Optimizer] Combos generees:', combos.length);

                // Trouver les meilleures par categorie
                var bestByROI = combos.filter(function(c) { return c.stats.betsPerMonth >= targetPicks * 0.8; })
                    .sort(function(a, b) { return b.stats.roi - a.stats.roi; })[0];
                var bestByVolume = combos.slice().sort(function(a, b) { return b.stats.betsPerMonth - a.stats.betsPerMonth; })[0];
                var bestByDD = combos.filter(function(c) { return c.stats.roi > 5; })
                    .sort(function(a, b) { return a.stats.maxDD - b.stats.maxDD; })[0];
                var bestBalanced = combos.filter(function(c) { return c.stats.betsPerMonth >= targetPicks * 0.8 && c.stats.roi > 8; })
                    .sort(function(a, b) {
                        var scoreA = a.stats.roi - (a.stats.maxDD * 0.5);
                        var scoreB = b.stats.roi - (b.stats.maxDD * 0.5);
                        return scoreB - scoreA;
                    })[0];

                // Stocker les combos pour pouvoir les appliquer
                window.pfBestCombos = {
                    roi: bestByROI,
                    volume: bestByVolume,
                    dd: bestByDD,
                    balanced: bestBalanced
                };

                // Afficher les resultats
                var html = '<div style="font-size:.75rem;font-weight:700;margin-bottom:.5rem;color:var(--purple)">üèÜ MEILLEURES COMBINAISONS</div>';

                function renderCombo(title, combo, color, comboKey) {
                    if (!combo) return '<div style="padding:.5rem;background:var(--bg);border-radius:4px;margin-bottom:.5rem;font-size:.65rem;color:var(--muted)">Aucune combo ' + title + ' trouvee</div>';
                    var nicheNames = combo.niches.map(function(n) { return n.name.substring(0, 20); }).join(', ');
                    return '<div style="padding:.5rem;background:var(--bg);border:1px solid ' + color + ';border-radius:6px;margin-bottom:.5rem">' +
                        '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:.25rem">' +
                        '<span style="font-weight:700;color:' + color + ';font-size:.7rem">' + title + '</span>' +
                        '<button onclick="applyOptCombo(\'' + comboKey + '\')" style="background:' + color + ';color:#000;border:none;padding:.2rem .5rem;border-radius:4px;font-size:.55rem;font-weight:700;cursor:pointer">Appliquer</button>' +
                        '</div>' +
                        '<div style="display:flex;gap:.75rem;font-size:.65rem;margin-bottom:.25rem">' +
                        '<span>ROI: <b style="color:var(--green)">+' + combo.stats.roi.toFixed(1) + '%</b></span>' +
                        '<span>Vol: <b style="color:var(--blue)">' + combo.stats.betsPerMonth.toFixed(1) + ' p/m</b></span>' +
                        '<span>DD: <b style="color:var(--red)">-' + combo.stats.maxDD.toFixed(1) + 'u</b></span>' +
                        '<span style="color:var(--muted)">' + combo.size + ' niches</span>' +
                        '</div>' +
                        '<div style="font-size:.55rem;color:var(--muted);overflow:hidden;text-overflow:ellipsis;white-space:nowrap" title="' + nicheNames + '">' + nicheNames + '</div>' +
                        '</div>';
                }

                html += renderCombo('üéØ Max ROI', bestByROI, 'var(--green)', 'roi');
                html += renderCombo('üìä Max Volume', bestByVolume, 'var(--blue)', 'volume');
                html += renderCombo('üõ°Ô∏è Min Drawdown', bestByDD, 'var(--yellow)', 'dd');
                html += renderCombo('‚öñÔ∏è Equilibre', bestBalanced, 'var(--purple)', 'balanced');

                container.innerHTML = html;
                showToast('Optimisation terminee!', 'success');

            } catch (err) {
                console.error('[Optimizer] Erreur:', err);
                container.innerHTML = '<div style="color:var(--red);font-size:.7rem">Erreur: ' + err.message + '</div>';
            }
        }

        // ============================================
        // APPLIQUER UNE COMBO OPTIMISEE
        // Active les niches du combo, desactive les autres
        // ============================================
        function applyOptCombo(comboKey) {
            if (!window.pfBestCombos || !window.pfBestCombos[comboKey]) {
                showToast('Combo non trouvee', 'error');
                return;
            }

            var combo = window.pfBestCombos[comboKey];
            var comboNicheNames = combo.niches.map(function(n) { return n.name; });

            console.log('[ApplyCombo] Application de', comboKey, ':', comboNicheNames);

            var activated = 0;
            var deactivated = 0;

            // Traiter NICHES_ATP
            for (var i = 0; i < NICHES_ATP.length; i++) {
                var inCombo = comboNicheNames.indexOf(NICHES_ATP[i].name) >= 0;
                if (inCombo && !NICHES_ATP[i].on) {
                    NICHES_ATP[i].on = true;
                    activated++;
                } else if (!inCombo && NICHES_ATP[i].on) {
                    NICHES_ATP[i].on = false;
                    deactivated++;
                }
            }

            // Traiter NICHES_WTA
            for (var j = 0; j < NICHES_WTA.length; j++) {
                var inComboWTA = comboNicheNames.indexOf(NICHES_WTA[j].name) >= 0;
                if (inComboWTA && !NICHES_WTA[j].on) {
                    NICHES_WTA[j].on = true;
                    activated++;
                } else if (!inComboWTA && NICHES_WTA[j].on) {
                    NICHES_WTA[j].on = false;
                    deactivated++;
                }
            }

            // Sauvegarder
            saveNiches();

            // Rafraichir les affichages
            if (typeof renderNichesList === 'function') renderNichesList();
            if (typeof renderNichesInLab === 'function') renderNichesInLab();
            if (typeof updateSimDisplay === 'function') updateSimDisplay();

            // Relancer le calcul Portfolio Builder
            buildPortfolios();

            var titles = { roi: 'Max ROI', volume: 'Max Volume', dd: 'Min DD', balanced: 'Equilibre' };
            showToast('Strategie "' + titles[comboKey] + '" appliquee! ' + combo.niches.length + ' niches actives.', 'success');
        }

        // ==================== DATAHUB TM ====================
        var DATAHUB_STORAGE_KEY = 'tennislab_datahub';
        var datahubData = [];

        // Mapping surfaces par tournoi (bas√© sur les tournois courants)
        var TOURNAMENT_SURFACES = {
            // ATP 250
            'brisbane': 'Hard', 'adelaide': 'Hard', 'auckland': 'Hard', 'hong kong': 'Hard',
            'doha': 'Hard', 'montpellier': 'Indoor Hard', 'dallas': 'Indoor Hard',
            'marseille': 'Indoor Hard', 'delray beach': 'Hard', 'los cabos': 'Hard',
            'atlanta': 'Hard', 'newport': 'Grass', 'bastad': 'Clay', 'gstaad': 'Clay',
            'kitzbuhel': 'Clay', 'umag': 'Clay', 'winston-salem': 'Hard',
            'metz': 'Indoor Hard', 'sofia': 'Indoor Hard', 'astana': 'Indoor Hard',
            'antwerp': 'Indoor Hard', 'stockholm': 'Indoor Hard', 'basel': 'Indoor Hard',
            'vienna': 'Indoor Hard',
            // ATP 500
            'rotterdam': 'Indoor Hard', 'rio de janeiro': 'Clay', 'acapulco': 'Hard',
            'dubai': 'Hard', 'barcelona': 'Clay', 'queens': 'Grass', 'halle': 'Grass',
            'hamburg': 'Clay', 'washington': 'Hard', 'tokyo': 'Hard', 'beijing': 'Hard',
            // ATP 1000
            'indian wells': 'Hard', 'miami': 'Hard', 'monte carlo': 'Clay',
            'madrid': 'Clay', 'rome': 'Clay', 'canada': 'Hard', 'montreal': 'Hard',
            'toronto': 'Hard', 'cincinnati': 'Hard', 'shanghai': 'Hard', 'paris': 'Indoor Hard',
            // Grand Slam
            'australian open': 'Hard', 'roland garros': 'Clay', 'wimbledon': 'Grass',
            'us open': 'Hard',
            // WTA
            'hobart': 'Hard', 'sydney': 'Hard', 'charleston': 'Clay', 'stuttgart': 'Clay',
            'birmingham': 'Grass', 'eastbourne': 'Grass', 'san jose': 'Hard',
            'montreal wta': 'Hard', 'toronto wta': 'Hard', 'new haven': 'Hard',
            'wuhan': 'Hard', 'zhengzhou': 'Hard', 'osaka': 'Hard', 'seoul': 'Hard',
            'guangzhou': 'Hard', 'linz': 'Indoor Hard', 'luxembourg': 'Indoor Hard',
            'zhuhai': 'Hard',
            // Challengers (par d√©faut Hard, ajuster si connu)
            'canberra': 'Hard', 'playford': 'Hard', 'quimper': 'Indoor Hard',
            'nonthaburi': 'Hard', 'koblenz': 'Indoor Hard'
        };

        // Detection circuit depuis nom du tournoi
        function detectCircuit(tournament) {
            var t = tournament.toLowerCase();
            if (t.includes('wta') || t.includes('women')) return 'WTA';
            if (t.includes('challenger')) return 'Challenger';
            if (t.includes('itf')) return 'ITF';
            if (t.includes('atp') || t.includes('united cup')) return 'ATP';
            // Par d√©faut selon le format du nom
            if (t.includes('250') || t.includes('500') || t.includes('1000') || t.includes('masters')) return 'ATP';
            return 'ATP'; // d√©faut
        }

        // Detection cat√©gorie depuis nom du tournoi
        function detectCategory(tournament) {
            var t = tournament.toLowerCase();
            if (t.includes('grand slam') || t.includes('australian open') || t.includes('roland garros') ||
                t.includes('wimbledon') || t.includes('us open')) return 'Grand Slam';
            if (t.includes('1000') || t.includes('masters')) return '1000';
            if (t.includes('500')) return '500';
            if (t.includes('250')) return '250';
            if (t.includes('challenger')) return 'Challenger';
            if (t.includes('itf')) return 'ITF';
            if (t.includes('united cup')) return 'United Cup';
            return '250'; // d√©faut
        }

        // Detection surface depuis nom du tournoi
        function detectSurface(tournament) {
            var t = tournament.toLowerCase();
            // Chercher correspondance directe
            for (var key in TOURNAMENT_SURFACES) {
                if (t.includes(key)) return TOURNAMENT_SURFACES[key];
            }
            // Sinon regarder les indices dans le nom
            if (t.includes('clay') || t.includes('terre')) return 'Clay';
            if (t.includes('grass') || t.includes('gazon')) return 'Grass';
            if (t.includes('indoor') || t.includes('covered')) return 'Indoor Hard';
            return 'Hard'; // d√©faut
        }

        function initDatahubDate() {
            var dateInput = document.getElementById('datahubDate');
            if (dateInput && !dateInput.value) {
                dateInput.value = new Date().toISOString().split('T')[0];
            }
        }

        function loadDatahubFromStorage() {
            try {
                var stored = localStorage.getItem(DATAHUB_STORAGE_KEY);
                if (stored) {
                    datahubData = JSON.parse(stored);
                }
            } catch (e) {
                console.error('Erreur chargement DataHub:', e);
                datahubData = [];
            }
        }

        function saveDatahubToStorage() {
            try {
                localStorage.setItem(DATAHUB_STORAGE_KEY, JSON.stringify(datahubData));
            } catch (e) {
                console.error('Erreur sauvegarde DataHub:', e);
            }
        }

        function parseDatahubInput() {
            var text = document.getElementById('datahubInput').value;
            var dateStr = document.getElementById('datahubDate').value;

            if (!text.trim()) {
                showToast('Colle d\'abord les donnees TM', 'error');
                return;
            }
            if (!dateStr) {
                showToast('Selectionne une date', 'error');
                return;
            }

            var matches = [];
            // Pattern pour extraire les infos TM
            var pattern = /(\d{2}h\d{2})\s*\n.*?Result\s*\n([^,]+),\s*([^\/]+)\s*\/\s*([^:]+)\s*:\s*([^.]+)\.\s*Cotes de d√©but de match\s*:\s*(\d+\.?\d*|None)\s*\/\s*(\d+\.?\d*|None)/gm;

            var match;
            while ((match = pattern.exec(text)) !== null) {
                var time = match[1];
                var tournament = match[2].trim();
                var player1 = match[3].trim();
                var player2 = match[4].trim();
                var score = match[5].trim();
                var odds1 = match[6] === 'None' ? null : parseFloat(match[6]);
                var odds2 = match[7] === 'None' ? null : parseFloat(match[7]);

                // Determiner le gagnant
                var sets = score.split(/\s+/);
                var p1Sets = 0, p2Sets = 0;
                sets.forEach(function(s) {
                    var parts = s.split('/');
                    if (parts.length === 2) {
                        if (parseInt(parts[0]) > parseInt(parts[1])) p1Sets++;
                        else p2Sets++;
                    }
                });
                var winner = p1Sets > p2Sets ? player1 : player2;

                // Enrichissement des donn√©es
                var circuit = detectCircuit(tournament);
                var category = detectCategory(tournament);
                var surface = detectSurface(tournament);
                var year = parseInt(dateStr.split('-')[0]) || new Date().getFullYear();

                matches.push({
                    date: dateStr,
                    time: time,
                    year: year,
                    tournament: tournament,
                    circuit: circuit,
                    category: category,
                    surface: surface,
                    player1: player1,
                    player2: player2,
                    p1: player1,
                    p2: player2,
                    score: score,
                    winner: winner,
                    odds_player1: odds1,
                    odds_player2: odds2,
                    o1: odds1,
                    o2: odds2,
                    winner_odds: winner === player1 ? odds1 : odds2,
                    loser_odds: winner === player1 ? odds2 : odds1,
                    imported_at: new Date().toISOString()
                });
            }

            if (matches.length === 0) {
                showToast('Aucun match trouve. Verifie le format.', 'error');
                return;
            }

            // Ajouter les matchs (sans doublons)
            var added = 0;
            matches.forEach(function(m) {
                var exists = datahubData.some(function(d) {
                    return d.date === m.date && d.player1 === m.player1 && d.player2 === m.player2;
                });
                if (!exists) {
                    datahubData.push(m);
                    added++;
                }
            });

            saveDatahubToStorage();
            updateDatahubStats();

            // Afficher resultat
            document.getElementById('datahubParseResult').style.display = 'block';
            document.getElementById('datahubParseCount').innerHTML =
                '<strong>' + matches.length + '</strong> matchs parses, <strong>' + added + '</strong> nouveaux ajoutes';

            showToast(added + ' matchs ajoutes a la base', 'success');
            document.getElementById('datahubInput').value = '';
        }

        function clearDatahubInput() {
            document.getElementById('datahubInput').value = '';
            document.getElementById('datahubParseResult').style.display = 'none';
        }

        function updateDatahubStats() {
            loadDatahubFromStorage();

            // Stats globales
            document.getElementById('dhTotalMatches').textContent = datahubData.length;

            // Jours uniques
            var uniqueDays = {};
            datahubData.forEach(function(m) { uniqueDays[m.date] = true; });
            var daysList = Object.keys(uniqueDays).sort();
            document.getElementById('dhTotalDays').textContent = daysList.length;

            // Periode
            if (daysList.length > 0) {
                var first = daysList[0];
                var last = daysList[daysList.length - 1];
                document.getElementById('dhDateRange').textContent = first.slice(5) + ' ‚Üí ' + last.slice(5);
            } else {
                document.getElementById('dhDateRange').textContent = '-';
            }

            // Derniere MAJ
            if (datahubData.length > 0) {
                var lastImport = datahubData.reduce(function(latest, m) {
                    return m.imported_at > latest ? m.imported_at : latest;
                }, '');
                if (lastImport) {
                    var d = new Date(lastImport);
                    document.getElementById('dhLastUpdate').textContent = d.toLocaleDateString('fr-FR');
                }
            } else {
                document.getElementById('dhLastUpdate').textContent = '-';
            }

            // Jours manquants (depuis le premier jour jusqu'a aujourd'hui)
            checkMissingDays(daysList);

            // Derniers matchs
            renderRecentMatches();
        }

        function checkMissingDays(existingDays) {
            var missingDiv = document.getElementById('dhMissingDays');
            var missingList = document.getElementById('dhMissingList');

            if (existingDays.length === 0) {
                missingDiv.style.display = 'none';
                return;
            }

            var firstDay = new Date(existingDays[0]);
            var today = new Date();
            today.setHours(0,0,0,0);

            var missing = [];
            var current = new Date(firstDay);

            while (current <= today) {
                var dateStr = current.toISOString().split('T')[0];
                if (!existingDays.includes(dateStr)) {
                    // Verifier si c'est un jour avec des matchs potentiels (pas trop vieux)
                    var daysDiff = Math.floor((today - current) / (1000 * 60 * 60 * 24));
                    if (daysDiff <= 7) { // Seulement les 7 derniers jours
                        missing.push(dateStr);
                    }
                }
                current.setDate(current.getDate() + 1);
            }

            if (missing.length > 0) {
                missingDiv.style.display = 'block';
                missingList.textContent = missing.join(', ');
            } else {
                missingDiv.style.display = 'none';
            }
        }

        function renderRecentMatches() {
            var tbody = document.getElementById('dhRecentMatches');
            if (!tbody) return;

            // Trier par date + heure decroissante
            var sorted = datahubData.slice().sort(function(a, b) {
                var dateA = a.date + ' ' + a.time;
                var dateB = b.date + ' ' + b.time;
                return dateB.localeCompare(dateA);
            });

            // Afficher les 50 derniers
            var recent = sorted.slice(0, 50);

            tbody.innerHTML = recent.map(function(m) {
                var odds1 = m.odds_player1 ? m.odds_player1.toFixed(2) : '-';
                var odds2 = m.odds_player2 ? m.odds_player2.toFixed(2) : '-';
                var winnerStyle = m.winner === m.player1 ? 'font-weight:700;color:var(--green)' : '';
                var loserStyle = m.winner === m.player2 ? 'font-weight:700;color:var(--green)' : '';

                // Couleur circuit
                var circuitColor = m.circuit === 'ATP' ? 'var(--atp)' :
                                   m.circuit === 'WTA' ? 'var(--wta)' :
                                   m.circuit === 'Challenger' ? 'var(--orange)' : 'var(--muted)';
                var circuitBadge = '<span style="background:' + circuitColor + ';color:#000;padding:.1rem .3rem;border-radius:3px;font-size:.65rem;font-weight:600">' + (m.circuit || 'ATP') + '</span>';

                // Couleur surface
                var surfaceColors = { 'Hard': '#4d9fff', 'Clay': '#e57c35', 'Grass': '#22c55e', 'Indoor Hard': '#a855f7' };
                var surfaceColor = surfaceColors[m.surface] || 'var(--muted)';
                var surfaceBadge = '<span style="color:' + surfaceColor + ';font-size:.7rem">' + (m.surface || '-') + '</span>';

                return '<tr>' +
                    '<td style="font-size:.7rem;white-space:nowrap">' + m.date.slice(5) + '</td>' +
                    '<td>' + circuitBadge + '</td>' +
                    '<td style="font-size:.7rem">' + m.tournament.replace(/^(ATP|WTA|Challenger.*?)\s*[-,]?\s*/i, '') + '</td>' +
                    '<td>' + surfaceBadge + '</td>' +
                    '<td style="font-size:.7rem"><span style="' + winnerStyle + '">' + m.player1 + '</span> vs <span style="' + loserStyle + '">' + m.player2 + '</span></td>' +
                    '<td style="font-size:.7rem;font-family:monospace">' + m.score + '</td>' +
                    '<td style="font-size:.7rem;font-family:monospace">' + odds1 + '/' + odds2 + '</td>' +
                '</tr>';
            }).join('');

            // Afficher stats par circuit
            renderCircuitStats();
        }

        function renderCircuitStats() {
            var container = document.getElementById('dhCircuitStats');
            if (!container) return;

            var circuits = {};
            datahubData.forEach(function(m) {
                var c = m.circuit || 'ATP';
                if (!circuits[c]) circuits[c] = 0;
                circuits[c]++;
            });

            var circuitColors = { 'ATP': 'var(--atp)', 'WTA': 'var(--wta)', 'Challenger': 'var(--orange)', 'ITF': 'var(--muted)' };

            container.innerHTML = Object.keys(circuits).map(function(c) {
                var color = circuitColors[c] || 'var(--muted)';
                return '<div style="background:' + color + ';color:#000;padding:.3rem .6rem;border-radius:4px;font-size:.75rem;font-weight:600">' +
                    c + ': ' + circuits[c] + '</div>';
            }).join('');
        }

        function exportDatahub() {
            if (datahubData.length === 0) {
                showToast('Aucune donnee a exporter', 'error');
                return;
            }

            var json = JSON.stringify(datahubData, null, 2);
            var blob = new Blob([json], { type: 'application/json' });
            var url = URL.createObjectURL(blob);
            var a = document.createElement('a');
            a.href = url;
            a.download = 'datahub_tm_' + new Date().toISOString().split('T')[0] + '.json';
            a.click();
            URL.revokeObjectURL(url);
            showToast('Export JSON telecharge', 'success');
        }

        function clearDatahub() {
            if (!confirm('Vider toute la base DataHub ? Cette action est irreversible.')) return;
            datahubData = [];
            saveDatahubToStorage();
            updateDatahubStats();
            showToast('Base DataHub videe', 'success');
        }

        // Charger les donnees au demarrage
        loadDatahubFromStorage();

        init();
        initV2();
        initLabToggles();
        loadCustomNiches();

        // Mettre √† jour l'affichage du simulateur apr√®s le chargement complet
        setTimeout(function() { updateSimDisplay(); }, 100);
    </script>

    <!-- Version + Force Update -->
    <div style="position:fixed;bottom:8px;right:12px;font-size:11px;color:#888;background:rgba(0,0,0,0.6);padding:4px 10px;border-radius:4px;z-index:9999">
        v57 <button onclick="forceUpdate()" style="font-size:10px;padding:2px 8px;margin-left:6px;cursor:pointer;background:#4d9fff;color:#000;border:none;border-radius:3px;font-weight:600">MAJ</button>
    </div>
    <script>
    function forceUpdate() {
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.getRegistrations().then(function(regs) {
                regs.forEach(function(r) { r.unregister(); });
            }).then(function() {
                return caches.keys();
            }).then(function(keys) {
                keys.forEach(function(k) { caches.delete(k); });
            }).then(function() {
                alert('Cache vide. Rechargement...');
                location.reload(true);
            });
        } else {
            location.reload(true);
        }
    }
    </script>
</body>
</html>
