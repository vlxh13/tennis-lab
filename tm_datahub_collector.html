<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TM DataHub Collector</title>
    <link rel="manifest" href="manifest_datahub.json">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="TM DataHub">
    <link rel="apple-touch-icon" href="icon-datahub-192.png">
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&family=Outfit:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #0a0a0f;
            --card: #12121a;
            --border: #2a2a3a;
            --text: #fff;
            --muted: #888;
            --green: #22c55e;
            --red: #ef4444;
            --blue: #4d9fff;
            --yellow: #eab308;
            --orange: #f97316;
            --atp: #22c55e;
            --wta: #ec4899;
            --challenger: #f97316;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Outfit', sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            padding: 1rem;
            padding-bottom: 80px;
        }

        .header {
            text-align: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border);
        }
        .header h1 {
            font-size: 1.4rem;
            background: linear-gradient(135deg, #f59e0b, #ef4444);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 0.5rem;
        }
        .header .subtitle {
            font-size: 0.85rem;
            color: var(--muted);
        }

        /* Alert box */
        .alert {
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            font-size: 0.9rem;
        }
        .alert.danger {
            background: rgba(239, 68, 68, 0.15);
            border: 1px solid var(--red);
            color: var(--red);
        }
        .alert.warning {
            background: rgba(234, 179, 8, 0.15);
            border: 1px solid var(--yellow);
            color: var(--yellow);
        }
        .alert.success {
            background: rgba(34, 197, 94, 0.15);
            border: 1px solid var(--green);
            color: var(--green);
        }
        .alert-title {
            font-weight: 700;
            margin-bottom: 0.3rem;
        }

        /* Cards */
        .card {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 1rem;
            margin-bottom: 1rem;
        }
        .card-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--muted);
            text-transform: uppercase;
            margin-bottom: 0.75rem;
        }

        /* Stats grid */
        .stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.75rem;
            margin-bottom: 1rem;
        }
        .stat {
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 0.75rem;
            text-align: center;
        }
        .stat .val {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.3rem;
            font-weight: 600;
        }
        .stat .val.green { color: var(--green); }
        .stat .val.red { color: var(--red); }
        .stat .val.orange { color: var(--orange); }
        .stat .lbl {
            font-size: 0.7rem;
            color: var(--muted);
            text-transform: uppercase;
        }

        /* Circuit stats */
        .circuit-stats {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-bottom: 1rem;
        }
        .circuit-badge {
            padding: 0.4rem 0.8rem;
            border-radius: 6px;
            font-size: 0.8rem;
            font-weight: 600;
            opacity: 0.5;
            transition: all 0.2s;
        }
        .circuit-badge.selectable:hover { opacity: 0.8; transform: scale(1.05); }
        .circuit-badge.selected { opacity: 1; box-shadow: 0 0 0 2px #fff; }
        .circuit-badge.atp { background: var(--atp); color: #000; }
        .circuit-badge.wta { background: var(--wta); color: #000; }
        .circuit-badge.challenger { background: var(--challenger); color: #000; }

        /* Form */
        textarea {
            width: 100%;
            height: 150px;
            padding: 0.75rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            resize: vertical;
            margin-bottom: 0.75rem;
        }
        textarea:focus {
            outline: none;
            border-color: var(--orange);
        }
        textarea::placeholder {
            color: var(--muted);
        }

        .form-row {
            display: flex;
            gap: 0.75rem;
            align-items: flex-end;
            flex-wrap: wrap;
            margin-bottom: 1rem;
        }
        .form-group {
            display: flex;
            flex-direction: column;
            gap: 0.3rem;
        }
        .form-group label {
            font-size: 0.75rem;
            color: var(--muted);
        }
        .form-group input {
            padding: 0.5rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text);
            font-size: 0.9rem;
        }

        /* Buttons */
        .btn {
            padding: 0.6rem 1.2rem;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            font-size: 0.85rem;
            cursor: pointer;
            font-family: inherit;
        }
        .btn-primary {
            background: linear-gradient(135deg, #f59e0b, #ef4444);
            color: #fff;
        }
        .btn-secondary {
            background: var(--bg);
            border: 1px solid var(--border);
            color: var(--muted);
        }
        .btn-blue {
            background: var(--blue);
            color: #000;
        }
        .btn-row {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        /* Table */
        .table-wrap {
            max-height: 400px;
            overflow: auto;
            border-radius: 8px;
            border: 1px solid var(--border);
        }
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
        }
        th {
            text-align: left;
            padding: 0.6rem;
            font-size: 0.75rem;
            color: var(--muted);
            text-transform: uppercase;
            border-bottom: 1px solid var(--border);
            position: sticky;
            top: 0;
            background: var(--card);
        }
        td {
            padding: 0.6rem;
            border-bottom: 1px solid var(--border);
        }
        tr:hover {
            background: rgba(255, 255, 255, 0.02);
        }

        /* Match Cards */
        .match-cards {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            max-height: 500px;
            overflow-y: auto;
        }
        .match-card {
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 0.9rem;
        }
        .match-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.8rem;
            color: var(--muted);
        }
        .match-card-tournament {
            font-weight: 600;
            color: var(--orange);
        }
        .match-card-meta {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }
        .match-card-players {
            font-size: 1.05rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
        }
        .match-card-players .winner {
            color: var(--green);
        }
        .match-card-players .loser {
            color: var(--muted);
        }
        .match-card-score {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1rem;
            color: var(--blue);
            margin-bottom: 0.5rem;
        }
        .match-card-footer {
            display: flex;
            justify-content: space-between;
            font-size: 0.85rem;
            color: var(--muted);
        }
        .match-card-odds {
            font-family: 'JetBrains Mono', monospace;
        }

        /* Filters */
        .filter-row {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-bottom: 1rem;
            align-items: center;
        }
        .filter-select {
            padding: 0.5rem 0.75rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text);
            font-size: 0.85rem;
            font-family: inherit;
            min-width: 140px;
        }
        .mono {
            font-family: 'JetBrains Mono', monospace;
        }
        .badge {
            display: inline-block;
            padding: 0.15rem 0.4rem;
            border-radius: 3px;
            font-size: 0.6rem;
            font-weight: 600;
        }
        .badge-atp { background: var(--atp); color: #000; }
        .badge-wta { background: var(--wta); color: #000; }
        .badge-challenger { background: var(--challenger); color: #000; }
        .surface-hard { color: #4d9fff; }
        .surface-clay { color: #e57c35; }
        .surface-grass { color: #22c55e; }
        .surface-indoor { color: #a855f7; }
        .winner { font-weight: 700; color: var(--green); }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }
        .tab {
            padding: 0.5rem 1rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 6px;
            font-size: 0.8rem;
            cursor: pointer;
            color: var(--muted);
        }
        .tab.active {
            background: var(--orange);
            color: #000;
            border-color: var(--orange);
            font-weight: 600;
        }

        /* Missing days */
        .missing-days {
            display: flex;
            gap: 0.4rem;
            flex-wrap: wrap;
        }
        .missing-day {
            padding: 0.3rem 0.6rem;
            background: rgba(239, 68, 68, 0.2);
            border: 1px solid var(--red);
            border-radius: 4px;
            font-size: 0.75rem;
            color: var(--red);
            font-family: 'JetBrains Mono', monospace;
        }

        /* Toast */
        .toast {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 600;
            z-index: 10000;
            animation: slideIn 0.3s ease;
        }
        .toast.success { background: var(--green); color: #000; }
        .toast.error { background: var(--red); color: #fff; }
        @keyframes slideIn {
            from { transform: translateX(-50%) translateY(-20px); opacity: 0; }
            to { transform: translateX(-50%) translateY(0); opacity: 1; }
        }

        /* Responsive */
        @media (max-width: 400px) {
            body { font-size: 13px; padding: 0.75rem; }
            .header h1 { font-size: 1.2rem; }
            .stats { grid-template-columns: repeat(2, 1fr); gap: 0.5rem; }
            .stat { padding: 0.5rem; }
            .stat .val { font-size: 1rem; }
            .stat .lbl { font-size: 0.6rem; }
            textarea { height: 120px; font-size: 0.7rem; }
            .btn { padding: 0.5rem 0.8rem; font-size: 0.8rem; }
            table { font-size: 0.65rem; }
            th, td { padding: 0.35rem; }
            .tab { padding: 0.4rem 0.7rem; font-size: 0.75rem; }
        }

        /* Version */
        .version {
            position: fixed;
            bottom: 8px;
            right: 12px;
            font-size: 11px;
            color: #666;
            background: rgba(0,0,0,0.6);
            padding: 4px 10px;
            border-radius: 4px;
            z-index: 9999;
        }
        .version button {
            font-size: 10px;
            padding: 2px 8px;
            margin-left: 6px;
            cursor: pointer;
            background: #f59e0b;
            color: #000;
            border: none;
            border-radius: 3px;
            font-weight: 600;
        }
    </style>
</head>
<body>

    <div class="header">
        <h1>üì° TM DataHub Collector</h1>
        <div class="subtitle">Base de donn√©es Tennis Metrics</div>
    </div>

    <!-- Alert jours manquants -->
    <div id="alertBox" class="alert danger" style="display:none">
        <div class="alert-title">‚ö†Ô∏è <span id="alertTitle">Donn√©es manquantes</span></div>
        <div id="alertMessage"></div>
    </div>

    <!-- Stats -->
    <div class="stats">
        <div class="stat">
            <div class="val" id="statTotal">0</div>
            <div class="lbl">Matchs</div>
        </div>
        <div class="stat">
            <div class="val" id="statDays">0</div>
            <div class="lbl">Jours</div>
        </div>
        <div class="stat">
            <div class="val" id="statLastUpdate">-</div>
            <div class="lbl">Dernier import</div>
        </div>
        <div class="stat">
            <div class="val" id="statDaysSince">-</div>
            <div class="lbl">Jours sans import</div>
        </div>
    </div>

    <!-- Circuit breakdown -->
    <div class="circuit-stats" id="circuitStats"></div>

    <!-- Tabs -->
    <div class="tabs">
        <button class="tab active" onclick="setTab('import')">üì• Import</button>
        <button class="tab" onclick="setTab('data')">üìä Donn√©es</button>
        <button class="tab" onclick="setTab('tournaments')">üèÜ Tournois</button>
        <button class="tab" onclick="setTab('missing')">‚ö†Ô∏è Manquants</button>
        <button class="tab" onclick="setTab('export')">üíæ Export</button>
    </div>

    <!-- Tab: Import -->
    <div id="tabImport" class="card">
        <div class="card-title">üìã Coller les donn√©es TM</div>
        <textarea id="inputData" placeholder="Colle ici le texte copi√© du DataHub Tennis Metrics...

Exemple:
10h23
Horizontal fading line
Result
WTA Auckland, Svitolina E. / Jovic I. : 7/6 6/2. Cotes de d√©but de match : 1.382 / 3.33."></textarea>

        <div class="form-row">
            <div class="form-group">
                <label>üìÖ Date des matchs</label>
                <input type="date" id="inputDate">
            </div>
            <button class="btn btn-primary" onclick="importData()">üöÄ Importer</button>
            <button class="btn btn-secondary" onclick="clearInput()">üóëÔ∏è Effacer</button>
        </div>

        <div id="importResult" style="display:none"></div>
    </div>

    <!-- Tab: Data -->
    <div id="tabData" class="card" style="display:none">
        <div class="card-title">üìä Base de donn√©es (<span id="dataCount">0</span> matchs)</div>

        <!-- Filters: Tournament + Round (Circuit = badges en haut) -->
        <div class="filter-row">
            <select class="filter-select" id="filterTournament" onchange="applyFilters()">
                <option value="all">üìç Tous les tournois</option>
            </select>
            <select class="filter-select" id="filterRound" onchange="applyFilters()">
                <option value="all">üéØ Tous les rounds</option>
                <option value="F">Finale</option>
                <option value="SF">Demi-finale</option>
                <option value="QF">Quart</option>
                <option value="R16">1/8</option>
                <option value="R32">1/16</option>
                <option value="R64">1/32</option>
                <option value="R128">1/64</option>
            </select>
        </div>

        <!-- Match Cards -->
        <div class="match-cards" id="matchCards"></div>
    </div>

    <!-- Tab: Tournaments -->
    <div id="tabTournaments" class="card" style="display:none">
        <div class="card-title">üèÜ Analyse des tournois</div>
        <p style="font-size:0.8rem;color:var(--muted);margin-bottom:1rem">
            <strong>~</strong> = round estim√© (densit√© de matchs) ‚Ä¢ <strong>‚úì</strong> = round confirm√© (bracket analys√©)<br>
            <span style="color:#6b7280">Qualifs d√©tect√©es auto</span> si > 1.4√ó matchs attendus ‚Üí Q1, Q2, Q3
        </p>

        <div class="btn-row" style="margin-bottom:1rem;flex-wrap:wrap;gap:0.5rem">
            <button class="btn btn-primary" onclick="estimateAllRounds()">‚ö° Estimer rounds</button>
            <button class="btn btn-primary" onclick="calculateAllRounds()">‚úì Confirmer rounds (complets)</button>
            <button class="btn btn-secondary" onclick="clearAllRounds()">üóëÔ∏è Effacer</button>
            <button class="btn btn-blue" onclick="recalculateSurfaces()">üîß Recalc tournois + surfaces</button>
        </div>

        <div id="roundsResult" style="display:none;margin-bottom:1rem"></div>

        <div class="card-title" style="margin-top:1rem">üìã Tournois d√©tect√©s</div>
        <div class="table-wrap" style="max-height:500px">
            <table>
                <thead>
                    <tr>
                        <th>Tournoi</th>
                        <th>Circuit</th>
                        <th>Dates</th>
                        <th>Matchs</th>
                        <th>Statut</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody id="tournamentsTable"></tbody>
            </table>
        </div>
    </div>

    <!-- Tab: Missing -->
    <div id="tabMissing" class="card" style="display:none">
        <div class="card-title">‚ö†Ô∏è Jours manquants (30 derniers jours)</div>
        <p style="font-size:0.8rem;color:var(--muted);margin-bottom:1rem">
            Ces jours n'ont pas de donn√©es dans la base. Clique sur un jour pour le s√©lectionner comme date d'import.
        </p>
        <div class="missing-days" id="missingDaysList"></div>
    </div>

    <!-- Tab: Export -->
    <div id="tabExport" class="card" style="display:none">
        <div class="card-title">üíæ Sauvegardes</div>
        <p style="font-size:0.85rem;color:var(--muted);margin-bottom:1rem">
            Les donn√©es sont automatiquement sauvegard√©es en localStorage.
            Utilise les exports pour cr√©er des backups.
        </p>
        <div class="btn-row">
            <button class="btn btn-blue" onclick="exportJSON()">üì• Export JSON</button>
            <button class="btn btn-blue" onclick="exportCSV()">üì• Export CSV</button>
            <button class="btn btn-secondary" onclick="importFromFile()">üì§ Import JSON</button>
        </div>
        <input type="file" id="fileInput" accept=".json" style="display:none" onchange="handleFileImport(event)">

        <div style="margin-top:1.5rem;padding-top:1rem;border-top:1px solid var(--border)">
            <div class="card-title" style="color:var(--red)">üóëÔ∏è Zone danger</div>
            <button class="btn" style="background:var(--red);color:#fff" onclick="clearAllData()">Vider toute la base</button>
        </div>
    </div>

    <!-- Version -->
    <div class="version">
        v2 <button onclick="forceUpdate()">MAJ</button>
    </div>

    <script>
        // ==================== STORAGE ====================
        var STORAGE_KEY = 'tm_datahub_collector';
        var database = [];
        var currentFilter = 'all';
        var currentTab = 'import';

        function loadDatabase() {
            try {
                var stored = localStorage.getItem(STORAGE_KEY);
                if (stored) {
                    database = JSON.parse(stored);
                }
            } catch (e) {
                console.error('Erreur chargement:', e);
                database = [];
            }
        }

        function saveDatabase() {
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(database));
            } catch (e) {
                console.error('Erreur sauvegarde:', e);
            }
        }

        // ==================== TOURNAMENT MAPPING ====================
        var TOURNAMENT_SURFACES = {
            // ATP/WTA Majors
            'australian open': 'Hard', 'roland garros': 'Clay', 'wimbledon': 'Grass', 'us open': 'Hard',
            // ATP 1000
            'indian wells': 'Hard', 'miami': 'Hard', 'monte carlo': 'Clay', 'madrid': 'Clay',
            'rome': 'Clay', 'canada': 'Hard', 'montreal': 'Hard', 'toronto': 'Hard',
            'cincinnati': 'Hard', 'shanghai': 'Hard', 'paris': 'Indoor Hard',
            // ATP 500
            'rotterdam': 'Indoor Hard', 'rio': 'Clay', 'acapulco': 'Hard', 'dubai': 'Hard',
            'barcelona': 'Clay', 'queens': 'Grass', 'queen': 'Grass', 'halle': 'Grass',
            'hamburg': 'Clay', 'washington': 'Hard', 'tokyo': 'Hard', 'beijing': 'Hard', 'basel': 'Indoor Hard', 'vienna': 'Indoor Hard',
            // ATP 250
            'brisbane': 'Hard', 'adelaide': 'Hard', 'auckland': 'Hard', 'hong kong': 'Hard',
            'doha': 'Hard', 'montpellier': 'Indoor Hard', 'dallas': 'Indoor Hard', 'marseille': 'Indoor Hard',
            'delray beach': 'Hard', 'los cabos': 'Hard', 'atlanta': 'Hard', 'newport': 'Grass',
            'bastad': 'Clay', 'gstaad': 'Clay', 'kitzbuhel': 'Clay', 'umag': 'Clay',
            'winston-salem': 'Hard', 'metz': 'Indoor Hard', 'sofia': 'Indoor Hard',
            'astana': 'Indoor Hard', 'antwerp': 'Indoor Hard', 'stockholm': 'Indoor Hard',
            // WTA
            'hobart': 'Hard', 'sydney': 'Hard', 'charleston': 'Clay', 'stuttgart': 'Clay',
            'birmingham': 'Grass', 'eastbourne': 'Grass', 'san jose': 'Hard',
            'wuhan': 'Hard', 'zhengzhou': 'Hard', 'osaka': 'Hard', 'seoul': 'Hard',
            'guangzhou': 'Hard', 'linz': 'Indoor Hard', 'luxembourg': 'Indoor Hard',
            // United Cup
            'united cup': 'Hard',
            // ========== CHALLENGERS 2026 ==========
            // Janvier
            'canberra': 'Hard', 'bengaluru': 'Hard', 'nonthaburi': 'Hard', 'bangkok': 'Hard',
            'nottingham': 'Indoor Hard', 'noumea': 'Hard', 'glasgow': 'Indoor Hard',
            // F√©vrier
            'quimper': 'Indoor Hard', 'oeiras': 'Indoor Hard', 'koblenz': 'Indoor Hard',
            'cleveland': 'Indoor Hard', 'pau': 'Indoor Hard', 'baton rouge': 'Indoor Hard',
            'chennai': 'Hard', 'delhi': 'Hard', 'pune': 'Hard', 'lugano': 'Indoor Hard',
            'saint-brieuc': 'Indoor Hard', 'cherbourg': 'Indoor Hard', 'rennes': 'Indoor Hard',
            'orleans': 'Indoor Hard', 'playford': 'Hard', 'cesenatico': 'Indoor Hard',
            'tenerife': 'Hard', 'san diego': 'Hard', 'bahrain': 'Hard',
            // Mars
            'thionville': 'Indoor Hard', 'brasilia': 'Clay', 'kigali': 'Clay',
            'fujairah': 'Hard', 'crete': 'Hard', 'hersonissos': 'Hard', 'phoenix': 'Hard',
            'arizona': 'Hard', 'cap cana': 'Hard', 'dominican': 'Hard',
            // Avril-Mai (Clay season)
            'santiago': 'Clay', 'murcia': 'Clay', 'zadar': 'Clay', 'split': 'Clay',
            'girona': 'Clay', 'naples': 'Clay', 'napoli': 'Clay', 'barletta': 'Clay',
            'menorca': 'Clay', 'bucaramanga': 'Clay', 'concepcion': 'Clay',
            'rosario': 'Clay', 'paraguay': 'Clay', 'buenos aires': 'Clay',
            'sao paulo': 'Clay', 'sao leo': 'Clay', 'itajai': 'Clay',
            // Hard courts year-round
            'soma bay': 'Hard', 'phan thiet': 'Hard', 'cuernavaca': 'Hard',
            'morelia': 'Hard', 'metepec': 'Hard', 'yokkaichi': 'Hard', 'miyazaki': 'Hard',
            // Grass Season (Juin-Juillet UK)
            'ilkley': 'Grass', 'surbiton': 'Grass', 'roehampton': 'Grass',
            'birmingham': 'Grass', 'manchester': 'Grass',
            // Summer Clay (Europe Est)
            'prostejov': 'Clay', 'bratislava': 'Clay', 'liberec': 'Clay',
            'poznan': 'Clay', 'szczecin': 'Clay', 'sopot': 'Clay',
            'prague': 'Clay', 'pardubice': 'Clay', 'ostrava': 'Clay',
            'braunschweig': 'Clay', 'heilbronn': 'Clay', 'verona': 'Clay',
            'como': 'Clay', 'perugia': 'Clay', 'trieste': 'Clay', 'parma': 'Clay',
            'cordenons': 'Clay', 'genova': 'Clay', 'francavilla': 'Clay',
            'vicenza': 'Clay', 'casinalbo': 'Clay', 'san marino': 'Clay',
            'tampere': 'Clay', 'meerbusch': 'Clay', 'troisdorf': 'Clay',
            'ismaning': 'Clay', 'bucharest': 'Clay', 'iasi': 'Clay',
            'sibiu': 'Clay', 'arad': 'Clay',
            // Fall Indoor (Sept-Nov)
            'ortisei': 'Indoor Hard', 'eckental': 'Indoor Hard', 'helsinki': 'Indoor Hard',
            'brest': 'Indoor Hard', 'ismaning': 'Indoor Hard', 'loughborough': 'Indoor Hard',
            'maia': 'Hard', 'lisbon': 'Hard', 'porto': 'Hard',
            'grodzisk': 'Indoor Hard', 'wroclaw': 'Indoor Hard',
            'bergamo': 'Indoor Hard', 'andria': 'Indoor Hard', 'olbia': 'Indoor Hard',
            'rovereto': 'Indoor Hard', 'forli': 'Indoor Hard', 'lisbonne': 'Hard',
            'stockholm': 'Indoor Hard', 'mons': 'Indoor Hard', 'lille': 'Indoor Hard',
            'roanne': 'Indoor Hard', 'mouilleron': 'Indoor Hard', 'biel': 'Indoor Hard',
            'champaign': 'Indoor Hard', 'fairfield': 'Indoor Hard', 'charlottesville': 'Indoor Hard',
            'knoxville': 'Indoor Hard', 'columbus': 'Indoor Hard', 'tiburon': 'Hard',
            'vancouver': 'Hard', 'cary': 'Hard', 'savannah': 'Clay', 'tallahassee': 'Clay',
            // WTA 125 / Challenger Women
            'manila': 'Hard', 'austin': 'Hard', 'midland': 'Hard', 'newport': 'Grass'
        };

        function detectCircuit(tournament) {
            var t = tournament.toLowerCase();
            if (t.includes('wta') || t.includes('women')) return 'WTA';
            if (t.includes('challenger')) return 'Challenger';
            if (t.includes('itf')) return 'ITF';
            return 'ATP';
        }

        function detectCategory(tournament) {
            var t = tournament.toLowerCase();
            if (t.includes('australian open') || t.includes('roland garros') ||
                t.includes('wimbledon') || t.includes('us open')) return 'Grand Slam';
            if (t.includes('1000') || t.includes('masters')) return '1000';
            if (t.includes('500')) return '500';
            if (t.includes('250')) return '250';
            if (t.includes('challenger')) return 'Challenger';
            if (t.includes('itf')) return 'ITF';
            if (t.includes('united cup')) return 'United Cup';
            return '250';
        }

        function detectSurface(tournament) {
            var t = tournament.toLowerCase();
            for (var key in TOURNAMENT_SURFACES) {
                if (t.includes(key)) return { surface: TOURNAMENT_SURFACES[key], mapped: true };
            }
            if (t.includes('clay') || t.includes('terre')) return { surface: 'Clay', mapped: false };
            if (t.includes('grass') || t.includes('gazon')) return { surface: 'Grass', mapped: false };
            if (t.includes('indoor') || t.includes('covered')) return { surface: 'Indoor Hard', mapped: false };
            return { surface: 'Hard', mapped: false };
        }

        function cleanTournamentName(tournament) {
            return tournament
                // Remove "Challenger Men - Singles " or "Challenger Women - Singles "
                .replace(/^Challenger\s+(Men|Women)\s*-\s*Singles\s*/i, '')
                // Remove "ATP " or "WTA " prefix
                .replace(/^(ATP|WTA)\s+/i, '')
                // Remove trailing " - Singles..." if any
                .replace(/\s*-\s*Singles.*$/i, '')
                .trim();
        }

        // ==================== PARSING ====================
        function parseDatahubText(text, dateStr) {
            var matches = [];
            // Format TM: "16h43\nHorizontal...\nResult\nTournoi, J1 / J2 : 6/4 6/3. Cotes de d√©but de match : 1.85 / 2.10."
            var pattern = /(\d{1,2}h\d{2})[\s\S]*?Result\s*\n([^,]+),\s*([^\/]+)\s*\/\s*([^:]+)\s*:\s*([^.]+)\.\s*Cotes de d√©but de match\s*:\s*([\d.]+)\s*\/\s*([\d.]+)/gm;

            var match;
            while ((match = pattern.exec(text)) !== null) {
                var time = match[1];
                var tournament = match[2].trim();
                var player1 = match[3].trim();
                var player2 = match[4].trim();
                var score = match[5].trim();
                var odds1 = match[6] === 'None' ? null : parseFloat(match[6]);
                var odds2 = match[7] === 'None' ? null : parseFloat(match[7]);

                // Determiner le gagnant
                var sets = score.split(/\s+/);
                var p1Sets = 0, p2Sets = 0;
                sets.forEach(function(s) {
                    var parts = s.split('/');
                    if (parts.length === 2) {
                        var g1 = parseInt(parts[0]);
                        var g2 = parseInt(parts[1]);
                        if (!isNaN(g1) && !isNaN(g2)) {
                            if (g1 > g2) p1Sets++;
                            else p2Sets++;
                        }
                    }
                });
                var winner = p1Sets > p2Sets ? player1 : player2;

                var circuit = detectCircuit(tournament);
                var category = detectCategory(tournament);
                var surfaceInfo = detectSurface(tournament);
                var year = parseInt(dateStr.split('-')[0]) || new Date().getFullYear();

                matches.push({
                    id: dateStr + '_' + player1 + '_' + player2,
                    date: dateStr,
                    time: time,
                    year: year,
                    tournament: tournament,
                    tournament_clean: cleanTournamentName(tournament),
                    circuit: circuit,
                    category: category,
                    surface: surfaceInfo.surface,
                    surface_mapped: surfaceInfo.mapped,
                    player1: player1,
                    player2: player2,
                    score: score,
                    sets: sets,
                    winner: winner,
                    odds1: odds1,
                    odds2: odds2,
                    winner_odds: winner === player1 ? odds1 : odds2,
                    loser_odds: winner === player1 ? odds2 : odds1,
                    imported_at: new Date().toISOString()
                });
            }

            return matches;
        }

        // ==================== ROUND ESTIMATION ====================
        function estimateRoundsForNewMatches() {
            // Pour chaque tournoi, estimer les rounds bas√© sur:
            // 1. Densit√© de matchs par jour
            // 2. Nombre de victoires du joueur dans le tournoi

            var tournaments = {};

            // Grouper par tournoi
            database.forEach(function(m) {
                var key = m.tournament_clean + '_' + m.year;
                if (!tournaments[key]) {
                    tournaments[key] = {
                        matches: [],
                        category: m.category,
                        circuit: m.circuit
                    };
                }
                tournaments[key].matches.push(m);
            });

            // Pour chaque tournoi
            Object.keys(tournaments).forEach(function(tKey) {
                var t = tournaments[tKey];
                var matches = t.matches;

                // Skip si tous les matchs ont d√©j√† un round confirm√©
                var needsEstimation = matches.some(function(m) {
                    return !m.round || !m.round_confirmed;
                });
                if (!needsEstimation) return;

                // Grouper par date
                var byDate = {};
                matches.forEach(function(m) {
                    if (!byDate[m.date]) byDate[m.date] = [];
                    byDate[m.date].push(m);
                });

                var dates = Object.keys(byDate).sort();
                var totalDays = dates.length;

                // Tracker les victoires par joueur
                var playerWins = {};
                matches.forEach(function(m) {
                    if (!playerWins[m.player1]) playerWins[m.player1] = 0;
                    if (!playerWins[m.player2]) playerWins[m.player2] = 0;
                });

                // Trier les matchs par date pour tracker les victoires
                var sortedMatches = matches.slice().sort(function(a, b) {
                    return (a.date + ' ' + a.time).localeCompare(b.date + ' ' + b.time);
                });

                sortedMatches.forEach(function(m) {
                    playerWins[m.winner] = (playerWins[m.winner] || 0) + 1;
                });

                // Templates de rounds (main draw)
                var mainTemplates = {
                    'Grand Slam': ['R128', 'R64', 'R32', 'R16', 'QF', 'SF', 'F'],
                    '1000': ['R64', 'R32', 'R16', 'QF', 'SF', 'F'],
                    '500': ['R32', 'R16', 'QF', 'SF', 'F'],
                    '250': ['R32', 'R16', 'QF', 'SF', 'F'],
                    'Challenger': ['R32', 'R16', 'QF', 'SF', 'F']
                };

                // Nombre de matchs attendus pour le main draw
                var expectedMainMatches = {
                    'Grand Slam': 127,
                    '1000': 55,
                    '500': 31,
                    '250': 31,
                    'Challenger': 31
                };

                var mainTemplate = mainTemplates[t.category] || mainTemplates['250'];
                var expectedMain = expectedMainMatches[t.category] || 31;

                // D√©tecter si y'a des qualifs (> 1.4√ó matchs attendus)
                var hasQualifs = matches.length > expectedMain * 1.4;

                // Calculer le "pivot day" - jour o√π le main draw commence
                // En g√©n√©ral, apr√®s les jours avec beaucoup de matchs (qualifs)
                var pivotDayIdx = 0;
                if (hasQualifs && dates.length > 2) {
                    // Chercher le jour o√π la densit√© chute (fin des qualifs)
                    var maxDensity = 0;
                    for (var d = 0; d < dates.length - 2; d++) {
                        var density = byDate[dates[d]].length;
                        if (density > maxDensity) maxDensity = density;
                    }
                    // Le pivot est le premier jour avec moins de la moiti√© de la densit√© max
                    // et qui n'est pas dans les 2 premiers jours
                    for (var d = 2; d < dates.length; d++) {
                        var density = byDate[dates[d]].length;
                        var prevDensity = byDate[dates[d-1]].length;
                        // Si la densit√© chute significativement, c'est le d√©but du main draw
                        if (density < maxDensity * 0.6 && prevDensity >= maxDensity * 0.6) {
                            pivotDayIdx = d;
                            break;
                        }
                    }
                    // Fallback: si pas de chute claire, prendre jour 2-3
                    if (pivotDayIdx === 0) pivotDayIdx = Math.min(2, dates.length - 3);
                }

                // Estimer le round pour chaque match
                matches.forEach(function(m) {
                    // Skip si d√©j√† confirm√©
                    if (m.round_confirmed) return;

                    var dateIdx = dates.indexOf(m.date);
                    var matchesThisDay = byDate[m.date].length;
                    var estimatedRound;

                    // Est-ce un match de qualifs ?
                    var isQualif = hasQualifs && dateIdx < pivotDayIdx;

                    if (isQualif) {
                        // Qualifs: Q1, Q2, Q3 bas√© sur la position dans la p√©riode qualif
                        var qualifProgress = pivotDayIdx > 0 ? dateIdx / pivotDayIdx : 0;
                        if (qualifProgress < 0.4) {
                            estimatedRound = 'Q1';
                        } else if (qualifProgress < 0.7) {
                            estimatedRound = 'Q2';
                        } else {
                            estimatedRound = 'Q3';
                        }
                    } else {
                        // Main draw: estimer par densit√©
                        if (matchesThisDay >= 12) {
                            estimatedRound = mainTemplate[0]; // Premier tour (R32/R64/R128)
                        } else if (matchesThisDay >= 6) {
                            estimatedRound = mainTemplate[Math.min(1, mainTemplate.length - 1)];
                        } else if (matchesThisDay >= 3) {
                            estimatedRound = mainTemplate[Math.min(2, mainTemplate.length - 1)];
                        } else if (matchesThisDay === 2) {
                            estimatedRound = 'SF';
                        } else if (matchesThisDay === 1) {
                            estimatedRound = 'F';
                        } else {
                            // Fallback: position dans le main draw
                            var mainDayIdx = dateIdx - pivotDayIdx;
                            var mainDays = dates.length - pivotDayIdx;
                            var progress = mainDays > 1 ? mainDayIdx / (mainDays - 1) : 0;
                            var roundIdx = Math.floor(progress * (mainTemplate.length - 1));
                            estimatedRound = mainTemplate[Math.min(roundIdx, mainTemplate.length - 1)];
                        }
                    }

                    m.round = estimatedRound;
                    m.round_confirmed = false;
                });
            });
        }

        function checkAndConfirmCompleteTournaments() {
            // V√©rifie si des tournois sont devenus complets et recalcule leurs rounds
            var tournaments = getTournaments();
            var confirmed = 0;

            Object.keys(tournaments).forEach(function(key) {
                var t = tournaments[key];
                if (t.isComplete) {
                    // V√©rifier si les rounds ne sont pas encore confirm√©s
                    var hasUnconfirmed = t.matches.some(function(m) {
                        return !m.round_confirmed;
                    });

                    if (hasUnconfirmed) {
                        calculateRoundsForTournament(t);
                        // Marquer comme confirm√©s
                        t.matches.forEach(function(m) {
                            m.round_confirmed = true;
                        });
                        confirmed++;
                    }
                }
            });

            return confirmed;
        }

        // ==================== IMPORT ====================
        function importData() {
            var text = document.getElementById('inputData').value;
            var dateStr = document.getElementById('inputDate').value;

            if (!text.trim()) {
                showToast('Colle d\'abord les donn√©es TM', 'error');
                return;
            }
            if (!dateStr) {
                showToast('S√©lectionne une date', 'error');
                return;
            }

            var matches = parseDatahubText(text, dateStr);

            if (matches.length === 0) {
                showToast('Aucun match trouv√©. V√©rifie le format.', 'error');
                return;
            }

            // Ajouter sans doublons
            var added = 0;
            matches.forEach(function(m) {
                var exists = database.some(function(d) {
                    return d.date === m.date && d.player1 === m.player1 && d.player2 === m.player2;
                });
                if (!exists) {
                    database.push(m);
                    added++;
                }
            });

            // Trier par date d√©croissante
            database.sort(function(a, b) {
                return (b.date + ' ' + b.time).localeCompare(a.date + ' ' + a.time);
            });

            // Estimer les rounds pour les nouveaux matchs
            estimateRoundsForNewMatches();

            // V√©rifier si des tournois sont devenus complets ‚Üí confirmer les rounds
            var confirmed = checkAndConfirmCompleteTournaments();

            saveDatabase();
            updateUI();

            // Afficher r√©sultat
            var resultDiv = document.getElementById('importResult');
            resultDiv.style.display = 'block';
            resultDiv.className = 'alert success';
            var confirmMsg = confirmed > 0 ? '<br><span style="color:var(--green)">üèÜ ' + confirmed + ' tournoi(s) compl√©t√©(s) - rounds confirm√©s</span>' : '';
            resultDiv.innerHTML = '<div class="alert-title">‚úÖ Import r√©ussi</div>' +
                '<div>' + matches.length + ' matchs pars√©s, <strong>' + added + '</strong> nouveaux ajout√©s' + confirmMsg + '</div>';

            showToast(added + ' matchs ajout√©s', 'success');
            document.getElementById('inputData').value = '';
        }

        function clearInput() {
            document.getElementById('inputData').value = '';
            document.getElementById('importResult').style.display = 'none';
        }

        // ==================== UI UPDATE ====================
        function updateUI() {
            updateStats();
            updateCircuitStats();
            updateAlert();
            updateDataTable();
            updateMissingDays();
            updateTournamentsTable();
        }

        function updateStats() {
            document.getElementById('statTotal').textContent = database.length;

            // Jours uniques
            var days = {};
            database.forEach(function(m) { days[m.date] = true; });
            var daysList = Object.keys(days).sort();
            document.getElementById('statDays').textContent = daysList.length;

            // Dernier import
            if (database.length > 0) {
                var lastDate = database.reduce(function(latest, m) {
                    return m.date > latest ? m.date : latest;
                }, '');
                document.getElementById('statLastUpdate').textContent = formatDate(lastDate);

                // Jours depuis dernier import
                var today = new Date();
                today.setHours(0, 0, 0, 0);
                var last = new Date(lastDate);
                var diff = Math.floor((today - last) / (1000 * 60 * 60 * 24));
                var daysSinceEl = document.getElementById('statDaysSince');
                daysSinceEl.textContent = diff;
                daysSinceEl.className = 'val ' + (diff === 0 ? 'green' : diff <= 1 ? 'orange' : 'red');
            } else {
                document.getElementById('statLastUpdate').textContent = '-';
                document.getElementById('statDaysSince').textContent = '-';
            }
        }

        function updateCircuitStats() {
            var circuits = {};
            var unmapped = 0;
            database.forEach(function(m) {
                var c = m.circuit || 'ATP';
                if (!circuits[c]) circuits[c] = 0;
                circuits[c]++;
                if (m.surface_mapped === false) unmapped++;
            });

            var container = document.getElementById('circuitStats');
            var html = '';

            // Bouton "Tous"
            var allSelected = currentFilter === 'all';
            html += '<div class="circuit-badge selectable' + (allSelected ? ' selected' : '') + '" onclick="filterCircuit(\'all\')" style="background:#444;cursor:pointer">Tous: ' + database.length + '</div>';

            // Boutons par circuit
            if (circuits['ATP']) {
                var selected = currentFilter === 'ATP';
                html += '<div class="circuit-badge atp selectable' + (selected ? ' selected' : '') + '" onclick="filterCircuit(\'ATP\')" style="cursor:pointer">ATP: ' + circuits['ATP'] + '</div>';
            }
            if (circuits['WTA']) {
                var selected = currentFilter === 'WTA';
                html += '<div class="circuit-badge wta selectable' + (selected ? ' selected' : '') + '" onclick="filterCircuit(\'WTA\')" style="cursor:pointer">WTA: ' + circuits['WTA'] + '</div>';
            }
            if (circuits['Challenger']) {
                var selected = currentFilter === 'Challenger';
                html += '<div class="circuit-badge challenger selectable' + (selected ? ' selected' : '') + '" onclick="filterCircuit(\'Challenger\')" style="cursor:pointer">Challenger: ' + circuits['Challenger'] + '</div>';
            }
            if (unmapped > 0) html += '<div class="circuit-badge" style="background:#ef4444;color:#fff">‚ö†Ô∏è ' + unmapped + ' non mapp√©es</div>';
            container.innerHTML = html;
        }

        function updateAlert() {
            var alertBox = document.getElementById('alertBox');

            if (database.length === 0) {
                alertBox.style.display = 'block';
                alertBox.className = 'alert warning';
                document.getElementById('alertTitle').textContent = 'Base vide';
                document.getElementById('alertMessage').textContent = 'Commence par importer des donn√©es du DataHub TM.';
                return;
            }

            // Calculer jours manquants r√©cents
            var missing = getMissingDays(7);

            if (missing.length > 0) {
                alertBox.style.display = 'block';
                alertBox.className = 'alert danger';
                document.getElementById('alertTitle').textContent = missing.length + ' jour(s) manquant(s)';
                document.getElementById('alertMessage').textContent = 'Derniers 7 jours: ' + missing.join(', ');
            } else {
                // V√©rifier jours depuis dernier import
                var lastDate = database.reduce(function(latest, m) {
                    return m.date > latest ? m.date : latest;
                }, '');
                var today = new Date();
                today.setHours(0, 0, 0, 0);
                var last = new Date(lastDate);
                var diff = Math.floor((today - last) / (1000 * 60 * 60 * 24));

                if (diff >= 2) {
                    alertBox.style.display = 'block';
                    alertBox.className = 'alert warning';
                    document.getElementById('alertTitle').textContent = diff + ' jours sans import';
                    document.getElementById('alertMessage').textContent = 'Dernier import: ' + formatDate(lastDate);
                } else if (diff === 1) {
                    alertBox.style.display = 'block';
                    alertBox.className = 'alert warning';
                    document.getElementById('alertTitle').textContent = 'Import d\'hier manquant ?';
                    document.getElementById('alertMessage').textContent = 'V√©rifie si tu as des matchs d\'hier √† ajouter.';
                } else {
                    alertBox.style.display = 'block';
                    alertBox.className = 'alert success';
                    document.getElementById('alertTitle').textContent = 'Base √† jour ‚úì';
                    document.getElementById('alertMessage').textContent = database.length + ' matchs sur ' + Object.keys(getDaysMap()).length + ' jours';
                }
            }
        }

        function updateDataTable() {
            applyFilters();
        }

        function applyFilters() {
            var circuitFilter = currentFilter;
            var tournamentFilter = document.getElementById('filterTournament').value;
            var roundFilter = document.getElementById('filterRound').value;

            var filtered = database.filter(function(m) {
                if (circuitFilter !== 'all' && m.circuit !== circuitFilter) return false;
                if (tournamentFilter !== 'all' && m.tournament_clean !== tournamentFilter) return false;
                if (roundFilter !== 'all' && m.round !== roundFilter) return false;
                return true;
            });

            document.getElementById('dataCount').textContent = filtered.length;

            // Sort by date desc, then time desc
            filtered.sort(function(a, b) {
                if (a.date !== b.date) return b.date.localeCompare(a.date);
                return (b.time || '').localeCompare(a.time || '');
            });

            var container = document.getElementById('matchCards');
            var display = filtered.slice(0, 100);

            container.innerHTML = display.map(function(m) {
                var circuitBadge = '<span class="badge badge-' + (m.circuit || 'atp').toLowerCase() + '">' + m.circuit + '</span>';
                var roundBadge = '';
                if (m.round) {
                    var roundColors = {
                        'F': '#22c55e', 'SF': '#4d9fff', 'QF': '#f97316',
                        'R16': '#eab308', 'R32': '#888', 'R64': '#888', 'R128': '#888',
                        'Q1': '#6b7280', 'Q2': '#6b7280', 'Q3': '#6b7280'
                    };
                    var statusIcon = m.round_confirmed ? '‚úì' : '~';
                    var statusTitle = m.round_confirmed ? 'Round confirm√©' : 'Round estim√©';
                    roundBadge = '<span style="background:' + (roundColors[m.round] || '#888') + ';color:#000;padding:2px 6px;border-radius:4px;font-size:0.75rem;font-weight:600" title="' + statusTitle + '">' + m.round + ' ' + statusIcon + '</span>';
                }

                var p1Display = m.winner === m.player1
                    ? '<span class="winner">' + m.player1 + ' üèÜ</span>'
                    : '<span class="loser">' + m.player1 + '</span>';
                var p2Display = m.winner === m.player2
                    ? '<span class="winner">' + m.player2 + ' üèÜ</span>'
                    : '<span class="loser">' + m.player2 + '</span>';

                return '<div class="match-card">' +
                    '<div class="match-card-header">' +
                        '<span class="match-card-tournament">' + m.tournament_clean + '</span>' +
                        '<div class="match-card-meta">' + circuitBadge + ' ' + roundBadge + '</div>' +
                    '</div>' +
                    '<div class="match-card-players">' + p1Display + ' vs ' + p2Display + '</div>' +
                    '<div class="match-card-score">' + m.score + '</div>' +
                    '<div class="match-card-footer">' +
                        '<span>' + m.date + ' ' + (m.time || '') + '</span>' +
                        '<span class="match-card-odds">' +
                            (m.surface_mapped === false ? '<span style="color:#ef4444" title="Surface non mapp√©e">‚ö†Ô∏è </span>' : '') +
                            m.surface + ' ‚Ä¢ ' +
                            (m.odds1 ? m.odds1.toFixed(2) : '-') + ' / ' +
                            (m.odds2 ? m.odds2.toFixed(2) : '-') +
                        '</span>' +
                    '</div>' +
                '</div>';
            }).join('');

            // Populate tournament dropdown
            populateTournamentFilter();
        }

        function populateTournamentFilter() {
            var select = document.getElementById('filterTournament');
            var currentValue = select.value;

            // Get unique tournaments
            var tournaments = [];
            var seen = {};
            database.forEach(function(m) {
                if (m.tournament_clean && !seen[m.tournament_clean]) {
                    seen[m.tournament_clean] = true;
                    tournaments.push(m.tournament_clean);
                }
            });
            tournaments.sort();

            // Rebuild options
            select.innerHTML = '<option value="all">üìç Tous les tournois (' + tournaments.length + ')</option>';
            tournaments.forEach(function(t) {
                var count = database.filter(function(m) { return m.tournament_clean === t; }).length;
                select.innerHTML += '<option value="' + t + '">' + t + ' (' + count + ')</option>';
            });

            // Restore selection
            if (currentValue && select.querySelector('option[value="' + currentValue + '"]')) {
                select.value = currentValue;
            }
        }

        function updateMissingDays() {
            var missing = getMissingDays(30);
            var container = document.getElementById('missingDaysList');

            if (missing.length === 0) {
                container.innerHTML = '<div style="color:var(--green)">‚úÖ Aucun jour manquant sur les 30 derniers jours</div>';
                return;
            }

            container.innerHTML = missing.map(function(d) {
                return '<div class="missing-day" onclick="selectMissingDay(\'' + d + '\')">' + d + '</div>';
            }).join('');
        }

        // ==================== HELPERS ====================
        function getDaysMap() {
            var days = {};
            database.forEach(function(m) { days[m.date] = true; });
            return days;
        }

        function getMissingDays(lookback) {
            var existingDays = getDaysMap();
            var missing = [];
            var today = new Date();
            today.setHours(0, 0, 0, 0);

            for (var i = 1; i <= lookback; i++) {
                var d = new Date(today);
                d.setDate(d.getDate() - i);
                var dateStr = d.toISOString().split('T')[0];
                if (!existingDays[dateStr]) {
                    missing.push(dateStr);
                }
            }

            return missing;
        }

        function formatDate(dateStr) {
            var d = new Date(dateStr);
            return d.toLocaleDateString('fr-FR', { day: '2-digit', month: '2-digit' });
        }

        function selectMissingDay(dateStr) {
            document.getElementById('inputDate').value = dateStr;
            setTab('import');
            showToast('Date s√©lectionn√©e: ' + dateStr, 'success');
        }

        // ==================== TABS ====================
        function setTab(tab) {
            currentTab = tab;
            document.querySelectorAll('.tab').forEach(function(t) { t.classList.remove('active'); });
            document.querySelectorAll('.card').forEach(function(c) { c.style.display = 'none'; });

            event.target.classList.add('active');
            document.getElementById('tab' + tab.charAt(0).toUpperCase() + tab.slice(1)).style.display = 'block';
        }

        function filterCircuit(circuit) {
            currentFilter = circuit;
            // Update circuit stats (pour afficher la s√©lection)
            updateCircuitStats();
            // Update tournaments filter dropdown
            updateTournamentFilter();
            // Apply filters to data view
            applyFilters();
            // Update tournaments table
            updateTournamentsTable();
        }

        function updateTournamentFilter() {
            // Met √† jour le dropdown des tournois selon le circuit s√©lectionn√©
            var tournaments = {};
            database.forEach(function(m) {
                if (currentFilter !== 'all' && m.circuit !== currentFilter) return;
                tournaments[m.tournament_clean] = true;
            });
            var select = document.getElementById('filterTournament');
            var currentVal = select.value;
            select.innerHTML = '<option value="all">Tous les tournois</option>';
            Object.keys(tournaments).sort().forEach(function(t) {
                select.innerHTML += '<option value="' + t + '">' + t + '</option>';
            });
            // Restore selection if still valid
            if (tournaments[currentVal]) select.value = currentVal;
        }

        // ==================== EXPORT/IMPORT ====================
        function exportJSON() {
            if (database.length === 0) {
                showToast('Base vide', 'error');
                return;
            }
            var blob = new Blob([JSON.stringify(database, null, 2)], { type: 'application/json' });
            var url = URL.createObjectURL(blob);
            var a = document.createElement('a');
            a.href = url;
            a.download = 'tm_datahub_' + new Date().toISOString().split('T')[0] + '.json';
            a.click();
            URL.revokeObjectURL(url);
            showToast('Export JSON t√©l√©charg√©', 'success');
        }

        function exportCSV() {
            if (database.length === 0) {
                showToast('Base vide', 'error');
                return;
            }
            var headers = ['date', 'time', 'year', 'circuit', 'category', 'tournament', 'surface', 'round', 'player1', 'player2', 'score', 'winner', 'odds1', 'odds2', 'winner_odds'];
            var csv = headers.join(',') + '\n';
            database.forEach(function(m) {
                csv += [
                    m.date, m.time, m.year, m.circuit, m.category,
                    '"' + m.tournament.replace(/"/g, '""') + '"',
                    m.surface,
                    m.round || '',
                    '"' + m.player1 + '"', '"' + m.player2 + '"',
                    m.score, '"' + m.winner + '"',
                    m.odds1 || '', m.odds2 || '', m.winner_odds || ''
                ].join(',') + '\n';
            });

            var blob = new Blob([csv], { type: 'text/csv' });
            var url = URL.createObjectURL(blob);
            var a = document.createElement('a');
            a.href = url;
            a.download = 'tm_datahub_' + new Date().toISOString().split('T')[0] + '.csv';
            a.click();
            URL.revokeObjectURL(url);
            showToast('Export CSV t√©l√©charg√©', 'success');
        }

        function importFromFile() {
            document.getElementById('fileInput').click();
        }

        function handleFileImport(event) {
            var file = event.target.files[0];
            if (!file) return;

            var reader = new FileReader();
            reader.onload = function(e) {
                try {
                    var imported = JSON.parse(e.target.result);
                    if (!Array.isArray(imported)) {
                        showToast('Format invalide', 'error');
                        return;
                    }

                    var added = 0;
                    imported.forEach(function(m) {
                        var exists = database.some(function(d) {
                            return d.date === m.date && d.player1 === m.player1 && d.player2 === m.player2;
                        });
                        if (!exists) {
                            database.push(m);
                            added++;
                        }
                    });

                    database.sort(function(a, b) {
                        return (b.date + ' ' + b.time).localeCompare(a.date + ' ' + a.time);
                    });

                    saveDatabase();
                    updateUI();
                    showToast(added + ' matchs import√©s depuis le fichier', 'success');
                } catch (err) {
                    showToast('Erreur: ' + err.message, 'error');
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        function clearAllData() {
            if (!confirm('Vider toute la base ? Cette action est irr√©versible.')) return;
            if (!confirm('Tu es s√ªr ? Toutes les donn√©es seront perdues.')) return;
            database = [];
            saveDatabase();
            updateUI();
            showToast('Base vid√©e', 'success');
        }

        // ==================== TOURNAMENTS & ROUNDS ====================

        // Nombre de matchs attendus par cat√©gorie de tournoi
        var TOURNAMENT_SIZES = {
            'Grand Slam': { draw: 128, matches: 127, rounds: ['R128', 'R64', 'R32', 'R16', 'QF', 'SF', 'F'] },
            '1000': { draw: 56, matches: 55, rounds: ['R64', 'R32', 'R16', 'QF', 'SF', 'F'] },
            '500': { draw: 32, matches: 31, rounds: ['R32', 'R16', 'QF', 'SF', 'F'] },
            '250': { draw: 32, matches: 31, rounds: ['R32', 'R16', 'QF', 'SF', 'F'] },
            'Challenger': { draw: 32, matches: 31, rounds: ['R32', 'R16', 'QF', 'SF', 'F'] },
            'United Cup': { draw: 16, matches: 15, rounds: ['R16', 'QF', 'SF', 'F'] }
        };

        function getTournaments() {
            var tournaments = {};
            database.forEach(function(m) {
                var key = m.tournament_clean + '_' + m.year;
                if (!tournaments[key]) {
                    tournaments[key] = {
                        name: m.tournament_clean,
                        tournament_full: m.tournament,
                        year: m.year,
                        circuit: m.circuit,
                        category: m.category,
                        surface: m.surface,
                        matches: [],
                        dates: [],
                        players: {}
                    };
                }
                tournaments[key].matches.push(m);
                if (!tournaments[key].dates.includes(m.date)) {
                    tournaments[key].dates.push(m.date);
                }
                // Tracker les victoires/d√©faites de chaque joueur
                if (!tournaments[key].players[m.player1]) tournaments[key].players[m.player1] = { wins: 0, losses: 0 };
                if (!tournaments[key].players[m.player2]) tournaments[key].players[m.player2] = { wins: 0, losses: 0 };
                if (m.winner === m.player1) {
                    tournaments[key].players[m.player1].wins++;
                    tournaments[key].players[m.player2].losses++;
                } else {
                    tournaments[key].players[m.player2].wins++;
                    tournaments[key].players[m.player1].losses++;
                }
            });

            // Analyser chaque tournoi
            Object.keys(tournaments).forEach(function(key) {
                var t = tournaments[key];
                t.dates.sort();
                t.dateStart = t.dates[0];
                t.dateEnd = t.dates[t.dates.length - 1];
                t.matchCount = t.matches.length;

                // Trouver le vainqueur potentiel (joueur avec le plus de victoires et 0 d√©faites √† la fin)
                var potentialWinner = null;
                var maxWins = 0;
                Object.keys(t.players).forEach(function(player) {
                    var p = t.players[player];
                    if (p.losses === 0 && p.wins > maxWins) {
                        maxWins = p.wins;
                        potentialWinner = player;
                    }
                });
                t.potentialWinner = potentialWinner;
                t.maxWins = maxWins;

                // D√©terminer si le tournoi semble complet
                var expectedSize = TOURNAMENT_SIZES[t.category] || TOURNAMENT_SIZES['250'];
                var minMatchesForComplete = Math.floor(expectedSize.matches * 0.8); // Au moins 80% des matchs

                // Un tournoi est "complet" si:
                // 1. Il y a un joueur avec 0 d√©faites et au moins 4-7 victoires (selon la cat√©gorie)
                // 2. Le nombre de matchs est proche de l'attendu
                var winsForChampion = expectedSize.rounds.length; // F=1, SF=2, etc.
                t.isComplete = potentialWinner && maxWins >= Math.min(winsForChampion, 5) && t.matchCount >= Math.min(minMatchesForComplete, 20);
                t.status = t.isComplete ? 'complet' : 'en cours';
                t.expectedMatches = expectedSize.matches;
                t.roundsTemplate = expectedSize.rounds;
            });

            return tournaments;
        }

        function calculateRoundsForTournament(tournament) {
            if (!tournament.isComplete) return 0;

            var matches = tournament.matches;
            var roundsTemplate = tournament.roundsTemplate;

            // Trier les matchs par date
            matches.sort(function(a, b) {
                return (a.date + ' ' + a.time).localeCompare(b.date + ' ' + b.time);
            });

            // Construire le bracket en partant de la finale
            // Le vainqueur du tournoi a jou√© la finale en dernier
            var winner = tournament.potentialWinner;
            var winnerMatches = matches.filter(function(m) { return m.winner === winner; });

            // Assigner les rounds du vainqueur (de la finale vers le d√©but)
            var roundIdx = roundsTemplate.length - 1; // Commence par F
            for (var i = winnerMatches.length - 1; i >= 0 && roundIdx >= 0; i--) {
                winnerMatches[i].round = roundsTemplate[roundIdx];
                winnerMatches[i].round_confirmed = true;
                roundIdx--;
            }

            // Pour les autres joueurs, d√©duire le round de leur d√©faite
            // Un joueur qui perd contre le futur champion au round X a jou√© ce round
            matches.forEach(function(m) {
                if (m.round_confirmed) return; // D√©j√† confirm√©

                // Trouver √† quel round le perdant a √©t√© √©limin√©
                var loser = m.winner === m.player1 ? m.player2 : m.player1;
                var loserData = tournament.players[loser];

                // Le round d√©pend du nombre de victoires avant la d√©faite
                // 0 victoires = premier tour (R32 ou R64 ou R128)
                // 1 victoire = deuxi√®me tour
                // etc.
                var winsBeforeLoss = loserData.wins;
                var roundForLoser = roundsTemplate[Math.min(winsBeforeLoss, roundsTemplate.length - 1)];
                m.round = roundForLoser;
                m.round_confirmed = true;
            });

            // Compter les matchs avec round assign√©
            var assigned = matches.filter(function(m) { return m.round; }).length;
            return assigned;
        }

        function calculateAllRounds() {
            var tournaments = getTournaments();
            var totalAssigned = 0;
            var tournamentsProcessed = 0;

            Object.keys(tournaments).forEach(function(key) {
                var t = tournaments[key];
                if (t.isComplete) {
                    var assigned = calculateRoundsForTournament(t);
                    totalAssigned += assigned;
                    tournamentsProcessed++;
                }
            });

            saveDatabase();
            updateUI();

            var resultDiv = document.getElementById('roundsResult');
            resultDiv.style.display = 'block';
            if (tournamentsProcessed > 0) {
                resultDiv.className = 'alert success';
                resultDiv.innerHTML = '<div class="alert-title">‚úÖ Rounds calcul√©s</div>' +
                    '<div>' + totalAssigned + ' matchs mis √† jour sur ' + tournamentsProcessed + ' tournoi(s) complet(s)</div>';
                showToast(totalAssigned + ' rounds assign√©s', 'success');
            } else {
                resultDiv.className = 'alert warning';
                resultDiv.innerHTML = '<div class="alert-title">‚ö†Ô∏è Aucun tournoi complet</div>' +
                    '<div>Importe plus de donn√©es pour avoir des tournois complets.</div>';
                showToast('Aucun tournoi complet trouv√©', 'error');
            }
        }

        function calculateRoundsForOne(tournamentKey) {
            var tournaments = getTournaments();
            var t = tournaments[tournamentKey];
            if (!t) {
                showToast('Tournoi non trouv√©', 'error');
                return;
            }

            var assigned = calculateRoundsForTournament(t);
            saveDatabase();
            updateUI();
            showToast(assigned + ' rounds assign√©s pour ' + t.name, 'success');
        }

        function estimateAllRounds() {
            // R√©initialiser les rounds non confirm√©s et r√©-estimer
            database.forEach(function(m) {
                if (!m.round_confirmed) {
                    delete m.round;
                }
            });

            estimateRoundsForNewMatches();
            saveDatabase();
            updateUI();

            var estimated = database.filter(function(m) { return m.round && !m.round_confirmed; }).length;
            var confirmed = database.filter(function(m) { return m.round_confirmed; }).length;

            var resultDiv = document.getElementById('roundsResult');
            resultDiv.style.display = 'block';
            resultDiv.className = 'alert success';
            resultDiv.innerHTML = '<div class="alert-title">‚ö° Estimation termin√©e</div>' +
                '<div>' + estimated + ' rounds estim√©s, ' + confirmed + ' d√©j√† confirm√©s</div>';

            showToast(estimated + ' rounds estim√©s', 'success');
        }

        function clearAllRounds() {
            if (!confirm('Effacer tous les rounds ? Tu pourras les recalculer ensuite.')) return;

            database.forEach(function(m) {
                delete m.round;
                delete m.round_confirmed;
            });

            saveDatabase();
            updateUI();
            showToast('Rounds effac√©s', 'success');
        }

        function recalculateSurfaces() {
            var surfaceUpdated = 0;
            var nameUpdated = 0;
            var unmapped = 0;

            database.forEach(function(m) {
                // Recalculate tournament_clean
                var newClean = cleanTournamentName(m.tournament);
                if (m.tournament_clean !== newClean) {
                    m.tournament_clean = newClean;
                    nameUpdated++;
                }

                // Recalculate surface
                var surfaceInfo = detectSurface(m.tournament);
                if (m.surface !== surfaceInfo.surface) {
                    m.surface = surfaceInfo.surface;
                    surfaceUpdated++;
                }
                m.surface_mapped = surfaceInfo.mapped;
                if (!surfaceInfo.mapped) unmapped++;
            });

            saveDatabase();
            updateUI();

            var msg = '';
            if (nameUpdated > 0) msg += nameUpdated + ' tournois renomm√©s. ';
            if (surfaceUpdated > 0) msg += surfaceUpdated + ' surfaces MAJ. ';
            if (unmapped > 0) msg += unmapped + ' non mapp√©es.';
            if (!msg) msg = 'Tout est d√©j√† √† jour';
            showToast(msg, (nameUpdated > 0 || surfaceUpdated > 0) ? 'success' : 'warning');
        }

        function updateTournamentsTable() {
            var tbody = document.getElementById('tournamentsTable');
            if (!tbody) return;

            var tournaments = getTournaments();
            var tournamentsList = Object.keys(tournaments).map(function(k) { return tournaments[k]; });

            // Filtrer par circuit s√©lectionn√©
            if (currentFilter !== 'all') {
                tournamentsList = tournamentsList.filter(function(t) {
                    return t.circuit === currentFilter;
                });
            }

            // Trier par date d√©croissante
            tournamentsList.sort(function(a, b) {
                return b.dateEnd.localeCompare(a.dateEnd);
            });

            tbody.innerHTML = tournamentsList.map(function(t) {
                var circuitClass = 'badge-' + (t.circuit || 'atp').toLowerCase();
                var statusClass = t.isComplete ? 'color:var(--green)' : 'color:var(--yellow)';
                var statusIcon = t.isComplete ? '‚úÖ' : '‚è≥';

                // Compter les matchs avec rounds
                var withRounds = t.matches.filter(function(m) { return m.round; }).length;
                var roundsInfo = withRounds > 0 ? ' (' + withRounds + ' rounds)' : '';

                var actionBtn = t.isComplete ?
                    '<button class="btn btn-secondary" style="padding:0.3rem 0.5rem;font-size:0.7rem" onclick="calculateRoundsForOne(\'' + t.name + '_' + t.year + '\')">üîÑ Calc</button>' :
                    '<span style="color:var(--muted);font-size:0.7rem">En attente</span>';

                return '<tr>' +
                    '<td>' + t.name + (t.potentialWinner ? '<br><span style="font-size:0.65rem;color:var(--green)">üèÜ ' + t.potentialWinner + '</span>' : '') + '</td>' +
                    '<td><span class="badge ' + circuitClass + '">' + t.circuit + '</span></td>' +
                    '<td class="mono" style="font-size:0.7rem">' + t.dateStart.slice(5) + ' ‚Üí ' + t.dateEnd.slice(5) + '</td>' +
                    '<td class="mono">' + t.matchCount + '/' + t.expectedMatches + roundsInfo + '</td>' +
                    '<td style="' + statusClass + '">' + statusIcon + ' ' + t.status + '</td>' +
                    '<td>' + actionBtn + '</td>' +
                '</tr>';
            }).join('');
        }

        // ==================== TOAST ====================
        function showToast(message, type) {
            var existing = document.querySelector('.toast');
            if (existing) existing.remove();

            var toast = document.createElement('div');
            toast.className = 'toast ' + type;
            toast.textContent = message;
            document.body.appendChild(toast);

            setTimeout(function() { toast.remove(); }, 3000);
        }

        // ==================== FORCE UPDATE ====================
        function forceUpdate() {
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.getRegistrations().then(function(regs) {
                    regs.forEach(function(r) { r.unregister(); });
                }).then(function() {
                    return caches.keys();
                }).then(function(keys) {
                    keys.forEach(function(k) { caches.delete(k); });
                }).then(function() {
                    alert('Cache vid√©. Rechargement...');
                    location.reload(true);
                });
            } else {
                location.reload(true);
            }
        }

        // ==================== INIT ====================
        function init() {
            // Set today's date
            document.getElementById('inputDate').value = new Date().toISOString().split('T')[0];

            // Load database
            loadDatabase();

            // Update UI
            updateUI();
        }

        init();
    </script>
</body>
</html>
